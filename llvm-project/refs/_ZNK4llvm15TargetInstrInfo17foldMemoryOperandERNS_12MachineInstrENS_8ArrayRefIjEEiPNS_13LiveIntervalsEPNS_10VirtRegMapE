<dec f='llvm/llvm/include/llvm/CodeGen/TargetInstrInfo.h' l='939' type='llvm::MachineInstr * llvm::TargetInstrInfo::foldMemoryOperand(llvm::MachineInstr &amp; MI, ArrayRef&lt;unsigned int&gt; Ops, int FI, llvm::LiveIntervals * LIS = nullptr, llvm::VirtRegMap * VRM = nullptr) const'/>
<doc f='llvm/llvm/include/llvm/CodeGen/TargetInstrInfo.h' l='931'>/// Attempt to fold a load or store of the specified stack
  /// slot into the specified machine instruction for the specified operand(s).
  /// If this is possible, a new instruction is returned with the specified
  /// operand folded, otherwise NULL is returned.
  /// The new instruction is inserted before MI, and the client is responsible
  /// for removing the old instruction.
  /// If VRM is passed, the assigned physregs can be inspected by target to
  /// decide on using an opcode (note that those assignments can still change).</doc>
<use f='llvm/llvm/lib/CodeGen/InlineSpiller.cpp' l='850' u='c' c='_ZN12_GLOBAL__N_113InlineSpiller17foldMemoryOperandEN4llvm8ArrayRefISt4pairIPNS1_12MachineInstrEjEEES5_'/>
<def f='llvm/llvm/lib/CodeGen/TargetInstrInfo.cpp' l='525' ll='611' type='llvm::MachineInstr * llvm::TargetInstrInfo::foldMemoryOperand(llvm::MachineInstr &amp; MI, ArrayRef&lt;unsigned int&gt; Ops, int FI, llvm::LiveIntervals * LIS = nullptr, llvm::VirtRegMap * VRM = nullptr) const'/>
