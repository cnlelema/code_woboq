<dec f='llvm/llvm/include/llvm/CodeGen/GlobalISel/IRTranslator.h' l='194' type='bool llvm::IRTranslator::translate(const llvm::Instruction &amp; Inst)'/>
<def f='llvm/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp' l='1716' ll='1727' type='bool llvm::IRTranslator::translate(const llvm::Instruction &amp; Inst)'/>
<use f='llvm/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp' l='1942' u='c' c='_ZN4llvm12IRTranslator20runOnMachineFunctionERNS_15MachineFunctionE'/>
<doc f='llvm/llvm/include/llvm/CodeGen/GlobalISel/IRTranslator.h' l='169'>/// \name Methods for translating form LLVM IR to MachineInstr.
  /// \see ::translate for general information on the translate methods.
  /// @{

  /// Translate \p Inst into its corresponding MachineInstr instruction(s).
  /// Insert the newly translated instruction(s) right where the CurBuilder
  /// is set.
  ///
  /// The general algorithm is:
  /// 1. Look for a virtual register for each operand or
  ///    create one.
  /// 2 Update the VMap accordingly.
  /// 2.alt. For constant arguments, if they are compile time constants,
  ///   produce an immediate in the right operand and do not touch
  ///   ValToReg. Actually we will go with a virtual register for each
  ///   constants because it may be expensive to actually materialize the
  ///   constant. Moreover, if the constant spans on several instructions,
  ///   CSE may not catch them.
  ///   =&gt; Update ValToVReg and remember that we saw a constant in Constants.
  ///   We will materialize all the constants in finalize.
  /// Note: we would need to do something so that we can recognize such operand
  ///       as constants.
  /// 3. Create the generic instruction.
  ///
  /// \return true if the translation succeeded.</doc>
