<def f='llvm/llvm/include/llvm/IR/DiagnosticInfo.h' l='835' ll='840' type='void llvm::OptimizationRemarkAnalysisFPCommute::OptimizationRemarkAnalysisFPCommute(const char * PassName, llvm::StringRef RemarkName, const llvm::DiagnosticLocation &amp; Loc, const llvm::Value * CodeRegion)'/>
<doc f='llvm/llvm/include/llvm/IR/DiagnosticInfo.h' l='828'>/// \p PassName is the name of the pass emitting this diagnostic. If this name
  /// matches the regular expression given in -Rpass-analysis=, then the
  /// diagnostic will be emitted. \p RemarkName is a textual identifier for the
  /// remark (single-word, camel-case). \p Loc is the debug location and \p
  /// CodeRegion is the region that the optimization operates on (currently only
  /// block is supported). The front-end will append its own message related to
  /// options that address floating-point non-commutativity.</doc>
<use f='llvm/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp' l='271' u='c' c='_ZN4llvm29LoopVectorizationRequirements11doesNotMeetEPNS_8FunctionEPNS_4LoopERKNS_18LoopVectorizeHintsE'/>
