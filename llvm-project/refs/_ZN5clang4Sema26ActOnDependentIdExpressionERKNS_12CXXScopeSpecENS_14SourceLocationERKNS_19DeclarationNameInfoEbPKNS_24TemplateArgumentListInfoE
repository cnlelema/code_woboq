<dec f='llvm/clang/include/clang/Sema/Sema.h' l='4302' type='ExprResult clang::Sema::ActOnDependentIdExpression(const clang::CXXScopeSpec &amp; SS, clang::SourceLocation TemplateKWLoc, const clang::DeclarationNameInfo &amp; NameInfo, bool isAddressOfOperand, const clang::TemplateArgumentListInfo * TemplateArgs)'/>
<use f='llvm/clang/lib/Sema/SemaDecl.cpp' l='1021' u='c' c='_ZN5clang4Sema12ClassifyNameEPNS_5ScopeERNS_12CXXScopeSpecERPNS_14IdentifierInfoENS_14SourceLocationERKNS_5TokenEbPNS_27CorrectionCandidateCallbackE'/>
<use f='llvm/clang/lib/Sema/SemaExpr.cpp' l='2230' u='c' c='_ZN5clang4Sema17ActOnIdExpressionEPNS_5ScopeERNS_12CXXScopeSpecENS_14SourceLocationERNS_13UnqualifiedIdEbbPNS_27CorrectionCandidateCallbackEbPNS_5TokenE'/>
<use f='llvm/clang/lib/Sema/SemaExpr.cpp' l='2253' u='c' c='_ZN5clang4Sema17ActOnIdExpressionEPNS_5ScopeERNS_12CXXScopeSpecENS_14SourceLocationERNS_13UnqualifiedIdEbbPNS_27CorrectionCandidateCallbackEbPNS_5TokenE'/>
<use f='llvm/clang/lib/Sema/SemaExpr.cpp' l='2262' u='c' c='_ZN5clang4Sema17ActOnIdExpressionEPNS_5ScopeERNS_12CXXScopeSpecENS_14SourceLocationERNS_13UnqualifiedIdEbbPNS_27CorrectionCandidateCallbackEbPNS_5TokenE'/>
<def f='llvm/clang/lib/Sema/SemaTemplate.cpp' l='672' ll='714' type='ExprResult clang::Sema::ActOnDependentIdExpression(const clang::CXXScopeSpec &amp; SS, clang::SourceLocation TemplateKWLoc, const clang::DeclarationNameInfo &amp; NameInfo, bool isAddressOfOperand, const clang::TemplateArgumentListInfo * TemplateArgs)'/>
<doc f='llvm/clang/lib/Sema/SemaTemplate.cpp' l='669'>/// ActOnDependentIdExpression - Handle a dependent id-expression that
/// was just parsed.  This is only possible with an explicit scope
/// specifier naming a dependent type.</doc>
