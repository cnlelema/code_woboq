<dec f='llvm/llvm/utils/TableGen/CodeGenRegisters.h' l='589' type='void llvm::CodeGenRegBank::pruneUnitSets()'/>
<doc f='llvm/llvm/utils/TableGen/CodeGenRegisters.h' l='588'>// Iteratively prune unit sets.</doc>
<def f='llvm/llvm/utils/TableGen/CodeGenRegisters.cpp' l='1817' ll='1858' type='void llvm::CodeGenRegBank::pruneUnitSets()'/>
<use f='llvm/llvm/utils/TableGen/CodeGenRegisters.cpp' l='1900' u='c' c='_ZN4llvm14CodeGenRegBank18computeRegUnitSetsEv'/>
<use f='llvm/llvm/utils/TableGen/CodeGenRegisters.cpp' l='1959' u='c' c='_ZN4llvm14CodeGenRegBank18computeRegUnitSetsEv'/>
<doc f='llvm/llvm/utils/TableGen/CodeGenRegisters.cpp' l='1800'>/// Iteratively prune unit sets. Prune subsets that are close to the superset,
/// but with one or two registers removed. We occasionally have registers like
/// APSR and PC thrown in with the general registers. We also see many
/// special-purpose register subsets, such as tail-call and Thumb
/// encodings. Generating all possible overlapping sets is combinatorial and
/// overkill for modeling pressure. Ideally we could fix this statically in
/// tablegen by (1) having the target define register classes that only include
/// the allocatable registers and marking other classes as non-allocatable and
/// (2) having a way to mark special purpose classes as &quot;don&apos;t-care&quot; classes for
/// the purpose of pressure.  However, we make an attempt to handle targets that
/// are not nicely defined by merging nearly identical register unit sets
/// statically. This generates smaller tables. Then, dynamically, we adjust the
/// set limit by filtering the reserved registers.
///
/// Merge sets only if the units have the same weight. For example, on ARM,
/// Q-tuples with ssub index 0 include all S regs but also include D16+. We
/// should not expand the S set to include D regs.</doc>
