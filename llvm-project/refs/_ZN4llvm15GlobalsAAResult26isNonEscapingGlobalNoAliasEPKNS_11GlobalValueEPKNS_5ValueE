<dec f='llvm/llvm/include/llvm/Analysis/GlobalsModRef.h' l='116' type='bool llvm::GlobalsAAResult::isNonEscapingGlobalNoAlias(const llvm::GlobalValue * GV, const llvm::Value * V)'/>
<def f='llvm/llvm/lib/Analysis/GlobalsModRef.cpp' l='707' ll='803' type='bool llvm::GlobalsAAResult::isNonEscapingGlobalNoAlias(const llvm::GlobalValue * GV, const llvm::Value * V)'/>
<use f='llvm/llvm/lib/Analysis/GlobalsModRef.cpp' l='844' u='c' c='_ZN4llvm15GlobalsAAResult5aliasERKNS_14MemoryLocationES3_RNS_11AAQueryInfoE'/>
<doc f='llvm/llvm/lib/Analysis/GlobalsModRef.cpp' l='682'>// There are particular cases where we can conclude no-alias between
// a non-addr-taken global and some other underlying object. Specifically,
// a non-addr-taken global is known to not be escaped from any function. It is
// also incorrect for a transformation to introduce an escape of a global in
// a way that is observable when it was not there previously. One function
// being transformed to introduce an escape which could possibly be observed
// (via loading from a global or the return value for example) within another
// function is never safe. If the observation is made through non-atomic
// operations on different threads, it is a data-race and UB. If the
// observation is well defined, by being observed the transformation would have
// changed program behavior by introducing the observed escape, making it an
// invalid transform.
//
// This property does require that transformations which *temporarily* escape
// a global that was not previously escaped, prior to restoring it, cannot rely
// on the results of GMR::alias. This seems a reasonable restriction, although
// currently there is no way to enforce it. There is also no realistic
// optimization pass that would make this mistake. The closest example is
// a transformation pass which does reg2mem of SSA values but stores them into
// global variables temporarily before restoring the global variable&apos;s value.
// This could be useful to expose &quot;benign&quot; races for example. However, it seems
// reasonable to require that a pass which introduces escapes of global
// variables in this way to either not trust AA results while the escape is
// active, or to be forced to operate as a module pass that cannot co-exist
// with an alias analysis such as GMR.</doc>
