<dec f='llvm/llvm/lib/Target/Hexagon/RDFLiveness.h' l='58' type='NodeList llvm::rdf::Liveness::getAllReachingDefs(llvm::rdf::RegisterRef RefRR, NodeAddr&lt;llvm::rdf::RefNode *&gt; RefA, bool TopShadows, bool FullChain, const llvm::rdf::RegisterAggr &amp; DefRRs)'/>
<use f='llvm/llvm/lib/Target/Hexagon/RDFLiveness.h' l='62' u='c' c='_ZN4llvm3rdf8Liveness18getAllReachingDefsENS0_8NodeAddrIPNS0_7RefNodeEEE'/>
<use f='llvm/llvm/lib/Target/Hexagon/RDFLiveness.h' l='67' u='c' c='_ZN4llvm3rdf8Liveness18getAllReachingDefsENS0_11RegisterRefENS0_8NodeAddrIPNS0_7RefNodeEEE'/>
<def f='llvm/llvm/lib/Target/Hexagon/RDFLiveness.cpp' l='106' ll='266' type='NodeList llvm::rdf::Liveness::getAllReachingDefs(llvm::rdf::RegisterRef RefRR, NodeAddr&lt;llvm::rdf::RefNode *&gt; RefA, bool TopShadows, bool FullChain, const llvm::rdf::RegisterAggr &amp; DefRRs)'/>
<use f='llvm/llvm/lib/Target/Hexagon/RDFLiveness.cpp' l='288' u='c' c='_ZN4llvm3rdf8Liveness25getAllReachingDefsRecImplENS0_11RegisterRefENS0_8NodeAddrIPNS0_7RefNodeEEERSt3setIjSt4lessIjESaIjEERKSB_jj'/>
<use f='llvm/llvm/lib/Target/Hexagon/RDFLiveness.cpp' l='560' u='c' c='_ZN4llvm3rdf8Liveness14computePhiInfoEv'/>
<use f='llvm/llvm/lib/Target/Hexagon/RDFLiveness.cpp' l='778' u='c' c='_ZN4llvm3rdf8Liveness14computeLiveInsEv'/>
<doc f='llvm/llvm/lib/Target/Hexagon/RDFLiveness.cpp' l='78'>// The order in the returned sequence is the order of reaching defs in the
// upward traversal: the first def is the closest to the given reference RefA,
// the next one is further up, and so on.
// The list ends at a reaching phi def, or when the reference from RefA is
// covered by the defs in the list (see FullChain).
// This function provides two modes of operation:
// (1) Returning the sequence of reaching defs for a particular reference
// node. This sequence will terminate at the first phi node [1].
// (2) Returning a partial sequence of reaching defs, where the final goal
// is to traverse past phi nodes to the actual defs arising from the code
// itself.
// In mode (2), the register reference for which the search was started
// may be different from the reference node RefA, for which this call was
// made, hence the argument RefRR, which holds the original register.
// Also, some definitions may have already been encountered in a previous
// call that will influence register covering. The register references
// already defined are passed in through DefRRs.
// In mode (1), the &quot;continuation&quot; considerations do not apply, and the
// RefRR is the same as the register in RefA, and the set DefRRs is empty.
//
// [1] It is possible for multiple phi nodes to be included in the returned
// sequence:
//   SubA = phi ...
//   SubB = phi ...
//   ...  = SuperAB(rdef:SubA), SuperAB&quot;(rdef:SubB)
// However, these phi nodes are independent from one another in terms of
// the data-flow.</doc>
