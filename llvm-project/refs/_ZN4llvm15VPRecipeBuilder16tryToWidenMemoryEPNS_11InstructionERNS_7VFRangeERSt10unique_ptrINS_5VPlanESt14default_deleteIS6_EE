<dec f='llvm/llvm/lib/Transforms/Vectorize/VPRecipeBuilder.h' l='75' type='llvm::VPWidenMemoryInstructionRecipe * llvm::VPRecipeBuilder::tryToWidenMemory(llvm::Instruction * I, llvm::VFRange &amp; Range, VPlanPtr &amp; Plan)'/>
<def f='llvm/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp' l='6494' ll='6523' type='llvm::VPWidenMemoryInstructionRecipe * llvm::VPRecipeBuilder::tryToWidenMemory(llvm::Instruction * I, llvm::VFRange &amp; Range, VPlanPtr &amp; Plan)'/>
<use f='llvm/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp' l='6766' u='c' c='_ZN4llvm15VPRecipeBuilder17tryToCreateRecipeEPNS_11InstructionERNS_7VFRangeERSt10unique_ptrINS_5VPlanESt14default_deleteIS6_EEPNS_12VPBasicBlockE'/>
<doc f='llvm/llvm/lib/Transforms/Vectorize/VPRecipeBuilder.h' l='71'>/// Check if \I is a memory instruction to be widened for \p Range.Start and
  /// potentially masked. Such instructions are handled by a recipe that takes
  /// an additional VPInstruction for the mask.</doc>
