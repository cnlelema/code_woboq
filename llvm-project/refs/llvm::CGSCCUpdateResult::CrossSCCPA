<dec f='llvm/llvm/include/llvm/Analysis/CGSCCPassManager.h' l='307' type='llvm::PreservedAnalyses'/>
<use f='llvm/llvm/include/llvm/Analysis/CGSCCPassManager.h' l='836' u='r' c='_ZN4llvm33ModuleToPostOrderCGSCCPassAdaptor3runERNS_6ModuleERNS_15AnalysisManagerIS1_JEEE'/>
<use f='llvm/llvm/include/llvm/Analysis/CGSCCPassManager.h' l='886' u='m' c='_ZN4llvm33ModuleToPostOrderCGSCCPassAdaptor3runERNS_6ModuleERNS_15AnalysisManagerIS1_JEEE'/>
<offset>384</offset>
<doc f='llvm/llvm/include/llvm/Analysis/CGSCCPassManager.h' l='294'>/// Preserved analyses across SCCs.
  ///
  /// We specifically want to allow CGSCC passes to mutate ancestor IR
  /// (changing both the CG structure and the function IR itself). However,
  /// this means we need to take special care to correctly mark what analyses
  /// are preserved *across* SCCs. We have to track this out-of-band here
  /// because within the main `PassManeger` infrastructure we need to mark
  /// everything within an SCC as preserved in order to avoid repeatedly
  /// invalidating the same analyses as we unnest pass managers and adaptors.
  /// So we track the cross-SCC version of the preserved analyses here from any
  /// code that does direct invalidation of SCC analyses, and then use it
  /// whenever we move forward in the post-order walk of SCCs before running
  /// passes over the new SCC.</doc>
<use f='llvm/llvm/lib/Analysis/CGSCCPassManager.cpp' l='117' u='m' c='_ZN4llvm11PassManager3runERT_RT0_DpT1_'/>
