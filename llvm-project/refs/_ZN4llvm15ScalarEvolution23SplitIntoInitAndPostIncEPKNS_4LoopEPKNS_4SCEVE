<dec f='llvm/llvm/include/llvm/Analysis/ScalarEvolution.h' l='887' type='std::pair&lt;const SCEV *, const SCEV *&gt; llvm::ScalarEvolution::SplitIntoInitAndPostInc(const llvm::Loop * L, const llvm::SCEV * S)'/>
<doc f='llvm/llvm/include/llvm/Analysis/ScalarEvolution.h' l='871'>/// Splits SCEV expression \p S into two SCEVs. One of them is obtained from
  /// \p S by substitution of all AddRec sub-expression related to loop \p L
  /// with initial value of that SCEV. The second is obtained from \p S by
  /// substitution of all AddRec sub-expressions related to loop \p L with post
  /// increment of this AddRec in the loop \p L. In both cases all other AddRec
  /// sub-expressions (not related to \p L) remain the same.
  /// If the \p S contains non-invariant unknown SCEV the function returns
  /// CouldNotCompute SCEV in both values of std::pair.
  /// For example, for SCEV S={0, +, 1}&lt;L1&gt; + {0, +, 1}&lt;L2&gt; and loop L=L1
  /// the function returns pair:
  /// first = {0, +, 1}&lt;L2&gt;
  /// second = {1, +, 1}&lt;L1&gt; + {0, +, 1}&lt;L2&gt;
  /// We can see that for the first AddRec sub-expression it was replaced with
  /// 0 (initial value) for the first element and to {1, +, 1}&lt;L1&gt; (post
  /// increment value) for the second one. In both cases AddRec expression
  /// related to L2 remains the same.</doc>
<def f='llvm/llvm/lib/Analysis/ScalarEvolution.cpp' l='9058' ll='9068' type='std::pair&lt;const SCEV *, const SCEV *&gt; llvm::ScalarEvolution::SplitIntoInitAndPostInc(const llvm::Loop * L, const llvm::SCEV * S)'/>
<use f='llvm/llvm/lib/Analysis/ScalarEvolution.cpp' l='9096' u='c' c='_ZN4llvm15ScalarEvolution19isKnownViaInductionENS_7CmpInst9PredicateEPKNS_4SCEVES5_'/>
<use f='llvm/llvm/lib/Analysis/ScalarEvolution.cpp' l='9102' u='c' c='_ZN4llvm15ScalarEvolution19isKnownViaInductionENS_7CmpInst9PredicateEPKNS_4SCEVES5_'/>
