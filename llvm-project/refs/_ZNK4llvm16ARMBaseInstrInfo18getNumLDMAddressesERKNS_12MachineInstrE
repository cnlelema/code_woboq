<dec f='llvm/llvm/lib/Target/ARM/ARMBaseInstrInfo.h' l='334' type='unsigned int llvm::ARMBaseInstrInfo::getNumLDMAddresses(const llvm::MachineInstr &amp; MI) const'/>
<doc f='llvm/llvm/lib/Target/ARM/ARMBaseInstrInfo.h' l='333'>/// Get the number of addresses by LDM or VLDM or zero for unknown.</doc>
<def f='llvm/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp' l='3440' ll='3453' type='unsigned int llvm::ARMBaseInstrInfo::getNumLDMAddresses(const llvm::MachineInstr &amp; MI) const'/>
<doc f='llvm/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp' l='3418'>// Return the number of 32-bit words loaded by LDM or stored by STM. If this
// can&apos;t be easily determined return 0 (missing MachineMemOperand).
//
// FIXME: The current MachineInstr design does not support relying on machine
// mem operands to determine the width of a memory access. Instead, we expect
// the target to provide this information based on the instruction opcode and
// operands. However, using MachineMemOperand is the best solution now for
// two reasons:
//
// 1) getNumMicroOps tries to infer LDM memory width from the total number of MI
// operands. This is much more dangerous than using the MachineMemOperand
// sizes because CodeGen passes can insert/remove optional machine operands. In
// fact, it&apos;s totally incorrect for preRA passes and appears to be wrong for
// postRA passes as well.
//
// 2) getNumLDMAddresses is only used by the scheduling machine model and any
// machine model that calls this should handle the unknown (zero size) case.
//
// Long term, we should require a target hook that verifies MachineMemOperand
// sizes during MC lowering. That target hook should be local to MC lowering
// because we can&apos;t ensure that it is aware of other MI forms. Doing this will
// ensure that MachineMemOperands are correctly propagated through all passes.</doc>
