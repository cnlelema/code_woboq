<dec f='llvm/clang/include/clang/Sema/Sema.h' l='6131' type='clang::Decl * clang::Sema::ActOnFriendTypeDecl(clang::Scope * S, const clang::DeclSpec &amp; DS, MultiTemplateParamsArg TemplateParams)'/>
<use f='llvm/clang/lib/Sema/SemaDecl.cpp' l='4317' u='c' c='_ZN5clang4Sema26ParsedFreeStandingDeclSpecEPNS_5ScopeENS_15AccessSpecifierERNS_8DeclSpecEN4llvm15MutableArrayRefIPNS_21TemplateParameterListEEEbRPNS_10RecordDeclE'/>
<def f='llvm/clang/lib/Sema/SemaDeclCXX.cpp' l='14254' ll='14343' type='clang::Decl * clang::Sema::ActOnFriendTypeDecl(clang::Scope * S, const clang::DeclSpec &amp; DS, MultiTemplateParamsArg TempParams)'/>
<doc f='llvm/clang/lib/Sema/SemaDeclCXX.cpp' l='14237'>/// Handle a friend type declaration.  This works in tandem with
/// ActOnTag.
///
/// Notes on friend class templates:
///
/// We generally treat friend class declarations as if they were
/// declaring a class.  So, for example, the elaborated type specifier
/// in a friend declaration is required to obey the restrictions of a
/// class-head (i.e. no typedefs in the scope chain), template
/// parameters are required to match up with simple template-ids, &amp;c.
/// However, unlike when declaring a template specialization, it&apos;s
/// okay to refer to a template specialization without an empty
/// template parameter declaration, e.g.
///   friend class A&lt;T&gt;::B&lt;unsigned&gt;;
/// We permit this as a special case; if there are any template
/// parameters present at all, require proper matching, i.e.
///   template &lt;&gt; template \&lt;class T&gt; friend class A&lt;int&gt;::B;</doc>
