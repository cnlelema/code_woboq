<def f='llvm/llvm/tools/llvm-objcopy/MachO/Object.h' l='191' ll='193'/>
<size>16</size>
<doc f='llvm/llvm/tools/llvm-objcopy/MachO/Object.h' l='165'>/// The location of the export info inside the binary is described by
/// LC_DYLD_INFO load command. The symbols exported by a dylib are encoded in a
/// trie.  This is a compact representation that factors out common prefixes. It
/// also reduces LINKEDIT pages in RAM because it encodes all information (name,
/// address, flags) in one small, contiguous range. The export area is a stream
/// of nodes.  The first node sequentially is the start node for the trie. Nodes
/// for a symbol start with a uleb128 that is the length of the exported symbol
/// information for the string so far. If there is no exported symbol, the node
/// starts with a zero byte. If there is exported info, it follows the length.
/// First is a uleb128 containing flags. Normally, it is followed by
/// a uleb128 encoded offset which is location of the content named
/// by the symbol from the mach_header for the image.  If the flags
/// is EXPORT_SYMBOL_FLAGS_REEXPORT, then following the flags is
/// a uleb128 encoded library ordinal, then a zero terminated
/// UTF8 string.  If the string is zero length, then the symbol
/// is re-export from the specified dylib with the same name.
/// If the flags is EXPORT_SYMBOL_FLAGS_STUB_AND_RESOLVER, then following
/// the flags is two uleb128s: the stub offset and the resolver offset.
/// The stub is used by non-lazy pointers.  The resolver is used
/// by lazy pointers and must be called to get the actual address to use.
/// After the optional exported symbol information is a byte of
/// how many edges (0-255) that this node has leaving it,
/// followed by each edge.
/// Each edge is a zero terminated UTF8 of the addition chars
/// in the symbol, followed by a uleb128 offset for the node that
/// edge points to.</doc>
<mbr r='llvm::objcopy::macho::ExportInfo::Trie' o='0' t='ArrayRef&lt;uint8_t&gt;'/>
