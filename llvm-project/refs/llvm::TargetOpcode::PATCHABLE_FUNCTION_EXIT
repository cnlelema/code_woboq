<dec f='llvm/llvm/include/llvm/Support/TargetOpcodes.def' l='182' type='30'/>
<doc f='llvm/llvm/include/llvm/Support/TargetOpcodes.def' l='168'>/// This is a marker instruction which gets translated into a nop sled, useful
/// for inserting instrumentation instructions at runtime.
/// The patch here prepends the return instruction.
/// The same thing as in x86_64 is not possible for ARM because it has multiple
/// return instructions. Furthermore, CPU allows parametrized and even
/// conditional return instructions. In the current ARM implementation we are
/// making use of the fact that currently LLVM doesn&apos;t seem to generate
/// conditional return instructions.
/// On ARM, the same instruction can be used for popping multiple registers
/// from the stack and returning (it just pops pc register too), and LLVM
/// generates it sometimes. So we can&apos;t insert the sled between this stack
/// adjustment and the return without splitting the original instruction into 2
/// instructions. So on ARM, rather than jumping into the exit trampoline, we
/// call it, it does the tracing, preserves the stack and returns.</doc>
<use f='llvm/llvm/lib/CodeGen/XRayInstrumentation.cpp' l='129' u='r' c='_ZN12_GLOBAL__N_119XRayInstrumentation27prependRetWithPatchableExitERN4llvm15MachineFunctionEPKNS1_15TargetInstrInfoENS_22InstrumentationOptionsE'/>
<use f='llvm/llvm/lib/Target/AArch64/AArch64AsmPrinter.cpp' l='1018' c='_ZN12_GLOBAL__N_117AArch64AsmPrinter15EmitInstructionEPKN4llvm12MachineInstrE'/>
<use f='llvm/llvm/lib/Target/Mips/MipsAsmPrinter.cpp' l='246' c='_ZN4llvm14MipsAsmPrinter15EmitInstructionEPKNS_12MachineInstrE'/>
<use f='llvm/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp' l='1228' c='_ZN12_GLOBAL__N_118PPCLinuxAsmPrinter15EmitInstructionEPKN4llvm12MachineInstrE'/>
