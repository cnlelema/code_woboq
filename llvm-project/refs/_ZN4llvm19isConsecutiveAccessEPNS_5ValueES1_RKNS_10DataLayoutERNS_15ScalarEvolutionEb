<dec f='llvm/llvm/include/llvm/Analysis/LoopAccessAnalysis.h' l='713' type='bool llvm::isConsecutiveAccess(llvm::Value * A, llvm::Value * B, const llvm::DataLayout &amp; DL, llvm::ScalarEvolution &amp; SE, bool CheckType = true)'/>
<doc f='llvm/llvm/include/llvm/Analysis/LoopAccessAnalysis.h' l='711'>/// Returns true if the memory operations \p A and \p B are consecutive.
/// This is a simple API that does not depend on the analysis pass.</doc>
<def f='llvm/llvm/lib/Analysis/LoopAccessAnalysis.cpp' l='1171' ll='1220' type='bool llvm::isConsecutiveAccess(llvm::Value * A, llvm::Value * B, const llvm::DataLayout &amp; DL, llvm::ScalarEvolution &amp; SE, bool CheckType = true)'/>
<doc f='llvm/llvm/lib/Analysis/LoopAccessAnalysis.cpp' l='1170'>/// Returns true if the memory operations \p A and \p B are consecutive.</doc>
<use f='llvm/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp' l='670' u='c' c='_ZN12_GLOBAL__N_118LoopIdiomRecognize17processLoopStoresERN4llvm15SmallVectorImplIPNS1_9StoreInstEEEPKNS1_4SCEVENS0_9ForMemsetE'/>
<use f='llvm/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp' l='790' u='c' c='_ZN4llvm13slpvectorizer7BoUpSLP10VLOperands14getBestOperandEjiiNS_8ArrayRefINS2_14ReorderingModeEEE'/>
<use f='llvm/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp' l='2486' u='c' c='_ZN4llvm13slpvectorizer7BoUpSLP13buildTree_recENS_8ArrayRefIPNS_5ValueEEEjRKNS1_8EdgeInfoE'/>
<use f='llvm/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp' l='5155' u='c' c='_ZN4llvm17SLPVectorizerPass15vectorizeStoresENS_8ArrayRefIPNS_9StoreInstEEERNS_13slpvectorizer7BoUpSLPE'/>
