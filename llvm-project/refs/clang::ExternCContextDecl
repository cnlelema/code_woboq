<inh f='llvm/clang/include/clang/AST/DeclBase.h' l='88' c='clang::Decl'/>
<inh f='llvm/clang/include/clang/AST/DeclBase.h' l='1271' c='clang::DeclContext'/>
<def f='llvm/clang/include/clang/AST/Decl.h' l='221' ll='241'/>
<size>1</size>
<doc f='llvm/clang/include/clang/AST/Decl.h' l='204'>/// Declaration context for names declared as extern &quot;C&quot; in C++. This
/// is neither the semantic nor lexical context for such declarations, but is
/// used to check for conflicts with other extern &quot;C&quot; declarations. Example:
///
/// \code
///   namespace N { extern &quot;C&quot; void f(); } // #1
///   void N::f() {}                       // #2
///   namespace M { extern &quot;C&quot; void f(); } // #3
/// \endcode
///
/// The semantic context of #1 is namespace N and its lexical context is the
/// LinkageSpecDecl; the semantic context of #2 is namespace N and its lexical
/// context is the TU. However, both declarations are also visible in the
/// extern &quot;C&quot; context.
///
/// The declaration at #3 finds it is a redeclaration of \c N::f through
/// lookup in the extern &quot;C&quot; context.</doc>
<fun r='_ZN5clang18ExternCContextDeclC1EPNS_19TranslationUnitDeclE'/>
<fun r='_ZN5clang18ExternCContextDecl6anchorEv'/>
<fun r='_ZN5clang18ExternCContextDecl6CreateERKNS_10ASTContextEPNS_19TranslationUnitDeclE'/>
<fun r='_ZN5clang18ExternCContextDecl7classofEPKNS_4DeclE'/>
<fun r='_ZN5clang18ExternCContextDecl11classofKindENS_4Decl4KindE'/>
<fun r='_ZN5clang18ExternCContextDecl17castToDeclContextEPKS0_'/>
<fun r='_ZN5clang18ExternCContextDecl19castFromDeclContextEPKNS_11DeclContextE'/>
