<dec f='llvm/clang/include/clang/Lex/Token.h' l='62' type='void *'/>
<use f='llvm/clang/include/clang/Lex/Token.h' l='174' u='w' c='_ZN5clang5Token10startTokenEv'/>
<use f='llvm/clang/include/clang/Lex/Token.h' l='186' u='r' c='_ZNK5clang5Token17getIdentifierInfoEv'/>
<use f='llvm/clang/include/clang/Lex/Token.h' l='189' u='w' c='_ZN5clang5Token17setIdentifierInfoEPNS_14IdentifierInfoE'/>
<use f='llvm/clang/include/clang/Lex/Token.h' l='194' u='r' c='_ZNK5clang5Token10getEofDataEv'/>
<use f='llvm/clang/include/clang/Lex/Token.h' l='198' u='r' c='_ZN5clang5Token10setEofDataEPKv'/>
<use f='llvm/clang/include/clang/Lex/Token.h' l='199' u='w' c='_ZN5clang5Token10setEofDataEPKv'/>
<use f='llvm/clang/include/clang/Lex/Token.h' l='207' u='r' c='_ZNK5clang5Token16getRawIdentifierEv'/>
<use f='llvm/clang/include/clang/Lex/Token.h' l='211' u='w' c='_ZN5clang5Token20setRawIdentifierDataEPKc'/>
<use f='llvm/clang/include/clang/Lex/Token.h' l='219' u='r' c='_ZNK5clang5Token14getLiteralDataEv'/>
<use f='llvm/clang/include/clang/Lex/Token.h' l='223' u='w' c='_ZN5clang5Token14setLiteralDataEPKc'/>
<use f='llvm/clang/include/clang/Lex/Token.h' l='228' u='r' c='_ZNK5clang5Token18getAnnotationValueEv'/>
<use f='llvm/clang/include/clang/Lex/Token.h' l='232' u='w' c='_ZN5clang5Token18setAnnotationValueEPv'/>
<offset>64</offset>
<doc f='llvm/clang/include/clang/Lex/Token.h' l='48'>/// PtrData - This is a union of four different pointer types, which depends
  /// on what type of token this is:
  ///  Identifiers, keywords, etc:
  ///    This is an IdentifierInfo*, which contains the uniqued identifier
  ///    spelling.
  ///  Literals:  isLiteral() returns true.
  ///    This is a pointer to the start of the token in a text buffer, which
  ///    may be dirty (have trigraphs / escaped newlines).
  ///  Annotations (resolved type names, C++ scopes, etc): isAnnotation().
  ///    This is a pointer to sema-specific data for the annotation token.
  ///  Eof:
  //     This is a pointer to a Decl.
  ///  Other:
  ///    This is null.</doc>
