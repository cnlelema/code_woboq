<dec f='llvm/clang/include/clang/Lex/ModuleMap.h' l='443' type='void clang::ModuleMap::resolveHeaderDirectives(const clang::FileEntry * File) const'/>
<doc f='llvm/clang/include/clang/Lex/ModuleMap.h' l='439'>/// Resolve all lazy header directives for the specified file.
  ///
  /// This ensures that the HeaderFileInfo on HeaderSearch is up to date. This
  /// is effectively internal, but is exposed so HeaderSearch can call it.</doc>
<use f='llvm/clang/lib/Lex/HeaderSearch.cpp' l='1211' u='c' c='_ZN5clang12HeaderSearch22ShouldEnterIncludeFileERNS_12PreprocessorEPKNS_9FileEntryEbbPNS_6ModuleE'/>
<use f='llvm/clang/lib/Lex/ModuleMap.cpp' l='392' u='c' c='_ZN5clang9ModuleMap15findKnownHeaderEPKNS_9FileEntryE'/>
<use f='llvm/clang/lib/Lex/ModuleMap.cpp' l='660' u='c' c='_ZNK5clang9ModuleMap23findAllModulesForHeaderEPKNS_9FileEntryE'/>
<use f='llvm/clang/lib/Lex/ModuleMap.cpp' l='674' u='c' c='_ZNK5clang9ModuleMap27isHeaderUnavailableInModuleEPKNS_9FileEntryEPKNS_6ModuleE'/>
<def f='llvm/clang/lib/Lex/ModuleMap.cpp' l='1150' ll='1164' type='void clang::ModuleMap::resolveHeaderDirectives(const clang::FileEntry * File) const'/>
