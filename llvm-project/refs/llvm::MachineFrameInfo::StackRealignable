<dec f='llvm/llvm/include/llvm/CodeGen/MachineFrameInfo.h' l='206' type='bool'/>
<use f='llvm/llvm/include/llvm/CodeGen/MachineFrameInfo.h' l='341' u='w' c='_ZN4llvm16MachineFrameInfoC1Ejbb'/>
<offset>32</offset>
<doc f='llvm/llvm/include/llvm/CodeGen/MachineFrameInfo.h' l='195'>/// Can the stack be realigned. This can be false if the target does not
  /// support stack realignment, or if the user asks us not to realign the
  /// stack. In this situation, overaligned allocas are all treated as dynamic
  /// allocations and the target must handle them as part of DYNAMIC_STACKALLOC
  /// lowering. All non-alloca stack objects have their alignment clamped to the
  /// base ABI stack alignment.
  /// FIXME: There is room for improvement in this case, in terms of
  /// grouping overaligned allocas into a &quot;secondary stack frame&quot; and
  /// then only use a single alloca to allocate this frame and only a
  /// single virtual register to access it. Currently, without such an
  /// optimization, each such alloca gets its own dynamic realignment.</doc>
<use f='llvm/llvm/lib/CodeGen/MachineFrameInfo.cpp' l='32' u='r' c='_ZN4llvm16MachineFrameInfo18ensureMaxAlignmentEj'/>
<use f='llvm/llvm/lib/CodeGen/MachineFrameInfo.cpp' l='54' u='r' c='_ZN4llvm16MachineFrameInfo17CreateStackObjectEmjbPKNS_10AllocaInstEh'/>
<use f='llvm/llvm/lib/CodeGen/MachineFrameInfo.cpp' l='66' u='r' c='_ZN4llvm16MachineFrameInfo22CreateSpillStackObjectEmj'/>
<use f='llvm/llvm/lib/CodeGen/MachineFrameInfo.cpp' l='76' u='r' c='_ZN4llvm16MachineFrameInfo25CreateVariableSizedObjectEjPKNS_10AllocaInstE'/>
<use f='llvm/llvm/lib/CodeGen/MachineFrameInfo.cpp' l='92' u='r' c='_ZN4llvm16MachineFrameInfo17CreateFixedObjectEmlbb'/>
<use f='llvm/llvm/lib/CodeGen/MachineFrameInfo.cpp' l='104' u='r' c='_ZN4llvm16MachineFrameInfo27CreateFixedSpillStackObjectEmlb'/>
