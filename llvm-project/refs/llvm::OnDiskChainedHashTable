<def f='llvm/llvm/include/llvm/Support/OnDiskHashTable.h' l='273' ll='424'/>
<doc f='llvm/llvm/include/llvm/Support/OnDiskHashTable.h' l='235'>/// Provides lookup on an on disk hash table.
///
/// This needs an \c Info that handles reading values from the hash table&apos;s
/// payload and computes the hash for a given key. This should provide the
/// following interface:
///
/// \code
/// class ExampleLookupInfo {
/// public:
///   typedef ExampleData data_type;
///   typedef ExampleInternalKey internal_key_type; // The stored key type.
///   typedef ExampleKey external_key_type; // The type to pass to find().
///   typedef uint32_t hash_value_type; // The type the hash function returns.
///   typedef uint32_t offset_type; // The type for offsets into the table.
///
///   /// Compare two keys for equality.
///   static bool EqualKey(internal_key_type &amp;Key1, internal_key_type &amp;Key2);
///   /// Calculate the hash for the given key.
///   static hash_value_type ComputeHash(internal_key_type &amp;IKey);
///   /// Translate from the semantic type of a key in the hash table to the
///   /// type that is actually stored and used for hashing and comparisons.
///   /// The internal and external types are often the same, in which case this
///   /// can simply return the passed in value.
///   static const internal_key_type &amp;GetInternalKey(external_key_type &amp;EKey);
///   /// Read the key and data length from Buffer, leaving it pointing at the
///   /// following byte.
///   static std::pair&lt;offset_type, offset_type&gt;
///   ReadKeyDataLength(const unsigned char *&amp;Buffer);
///   /// Read the key from Buffer, given the KeyLen as reported from
///   /// ReadKeyDataLength.
///   const internal_key_type &amp;ReadKey(const unsigned char *Buffer,
///                                    offset_type KeyLen);
///   /// Read the data for Key from Buffer, given the DataLen as reported from
///   /// ReadKeyDataLength.
///   data_type ReadData(StringRef Key, const unsigned char *Buffer,
///                      offset_type DataLen);
/// };
/// \endcode</doc>
<mbr r='llvm::OnDiskChainedHashTable::NumBuckets' t='const typename Info::offset_type'/>
<mbr r='llvm::OnDiskChainedHashTable::NumEntries' t='const typename Info::offset_type'/>
<mbr r='llvm::OnDiskChainedHashTable::Buckets' t='const unsigned char *const'/>
<mbr r='llvm::OnDiskChainedHashTable::Base' t='const unsigned char *const'/>
<mbr r='llvm::OnDiskChainedHashTable::InfoObj' t='Info'/>
<fun r='_ZN4llvm22OnDiskChainedHashTableC1ENT_11offset_typeES2_PKhS4_RKS1_'/>
<fun r='_ZN4llvm22OnDiskChainedHashTable24readNumBucketsAndEntriesERPKh'/>
<fun r='_ZNK4llvm22OnDiskChainedHashTable13getNumBucketsEv'/>
<fun r='_ZNK4llvm22OnDiskChainedHashTable13getNumEntriesEv'/>
<fun r='_ZNK4llvm22OnDiskChainedHashTable7getBaseEv'/>
<fun r='_ZNK4llvm22OnDiskChainedHashTable10getBucketsEv'/>
<fun r='_ZNK4llvm22OnDiskChainedHashTable7isEmptyEv'/>
<fun r='_ZN4llvm22OnDiskChainedHashTable4findERKNT_17external_key_typeEPS1_'/>
<fun r='_ZN4llvm22OnDiskChainedHashTable11find_hashedERKNT_17internal_key_typeENS1_15hash_value_typeEPS1_'/>
<fun r='_ZNK4llvm22OnDiskChainedHashTable3endEv'/>
<fun r='_ZN4llvm22OnDiskChainedHashTable10getInfoObjEv'/>
<fun r='_ZN4llvm22OnDiskChainedHashTable6CreateEPKhS2_RKT_'/>
