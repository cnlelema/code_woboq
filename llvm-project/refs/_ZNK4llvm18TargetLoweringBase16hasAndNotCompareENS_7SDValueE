<def f='llvm/llvm/include/llvm/CodeGen/TargetLowering.h' l='550' ll='552' type='bool llvm::TargetLoweringBase::hasAndNotCompare(llvm::SDValue Y) const'/>
<use f='llvm/llvm/include/llvm/CodeGen/TargetLowering.h' l='560' u='c' c='_ZNK4llvm18TargetLoweringBase9hasAndNotENS_7SDValueE'/>
<doc f='llvm/llvm/include/llvm/CodeGen/TargetLowering.h' l='538'>/// Return true if the target should transform:
  /// (X &amp; Y) == Y ---&gt; (~X &amp; Y) == 0
  /// (X &amp; Y) != Y ---&gt; (~X &amp; Y) != 0
  ///
  /// This may be profitable if the target has a bitwise and-not operation that
  /// sets comparison flags. A target may want to limit the transformation based
  /// on the type of Y or if Y is a constant.
  ///
  /// Note that the transform will not occur if Y is known to be a power-of-2
  /// because a mask and compare of a single bit can be handled by inverting the
  /// predicate, for example:
  /// (X &amp; 8) == 8 ---&gt; (X &amp; 8) != 0</doc>
<use f='llvm/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp' l='2492' u='c' c='_ZNK4llvm14TargetLowering16foldSetCCWithAndENS_3EVTENS_7SDValueES2_NS_3ISD8CondCodeERKNS_5SDLocERNS0_15DAGCombinerInfoE'/>
<ovr f='llvm/llvm/lib/Target/AArch64/AArch64ISelLowering.h' l='463' c='_ZNK4llvm21AArch64TargetLowering16hasAndNotCompareENS_7SDValueE'/>
<ovr f='llvm/llvm/lib/Target/PowerPC/PPCISelLowering.h' l='624' c='_ZNK4llvm17PPCTargetLowering16hasAndNotCompareENS_7SDValueE'/>
<ovr f='llvm/llvm/lib/Target/X86/X86ISelLowering.cpp' l='4945' c='_ZNK4llvm17X86TargetLowering16hasAndNotCompareENS_7SDValueE'/>
