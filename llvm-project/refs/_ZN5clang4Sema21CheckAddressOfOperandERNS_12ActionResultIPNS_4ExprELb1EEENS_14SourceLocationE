<dec f='llvm/clang/include/clang/Sema/Sema.h' l='4423' type='clang::QualType clang::Sema::CheckAddressOfOperand(ExprResult &amp; Operand, clang::SourceLocation OpLoc)'/>
<use f='llvm/clang/lib/Sema/SemaChecking.cpp' l='209' u='c' c='_ZL20SemaBuiltinAddressofRN5clang4SemaEPNS_8CallExprE'/>
<def f='llvm/clang/lib/Sema/SemaExpr.cpp' l='12114' ll='12330' type='clang::QualType clang::Sema::CheckAddressOfOperand(ExprResult &amp; OrigOp, clang::SourceLocation OpLoc)'/>
<use f='llvm/clang/lib/Sema/SemaExpr.cpp' l='13320' u='c' c='_ZN5clang4Sema20CreateBuiltinUnaryOpENS_14SourceLocationENS_17UnaryOperatorKindEPNS_4ExprE'/>
<doc f='llvm/clang/lib/Sema/SemaExpr.cpp' l='12107'>/// CheckAddressOfOperand - The operand of &amp; must be either a function
/// designator or an lvalue designating an object. If it is an lvalue, the
/// object cannot be declared with storage class register or be a bit field.
/// Note: The usual conversions are *not* applied to the operand of the &amp;
/// operator (C99 6.3.2.1p[2-4]), and its result is never an lvalue.
/// In C++, the operand might be an overloaded function name, in which case
/// we allow the &apos;&amp;&apos; but retain the overloaded-function type.</doc>
