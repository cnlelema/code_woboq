<dec f='llvm/llvm/lib/Target/ARM/MCTargetDesc/ARMFixupKinds.h' l='70' type='143'/>
<use f='llvm/llvm/lib/Target/ARM/MCTargetDesc/ARMAsmBackend.cpp' l='539' c='_ZNK4llvm13ARMAsmBackend16adjustFixupValueERKNS_11MCAssemblerERKNS_7MCFixupERKNS_7MCValueEmbRNS_9MCContextEPKNS_15MCSubtargetInfoE'/>
<use f='llvm/llvm/lib/Target/ARM/MCTargetDesc/ARMAsmBackend.cpp' l='906' u='r' c='_ZN4llvm13ARMAsmBackend21shouldForceRelocationERKNS_11MCAssemblerERKNS_7MCFixupERKNS_7MCValueE'/>
<use f='llvm/llvm/lib/Target/ARM/MCTargetDesc/ARMAsmBackend.cpp' l='938' c='_ZL20getFixupKindNumBytesj'/>
<use f='llvm/llvm/lib/Target/ARM/MCTargetDesc/ARMAsmBackend.cpp' l='1004' c='_ZL30getFixupKindContainerSizeBytesj'/>
<doc f='llvm/llvm/lib/Target/ARM/MCTargetDesc/ARMFixupKinds.h' l='60'>// The following fixups handle the ARM BL instructions. These can be
  // conditionalised; however, the ARM ELF ABI requires a different relocation
  // in that case: R_ARM_JUMP24 instead of R_ARM_CALL. The difference is that
  // R_ARM_CALL is allowed to change the instruction to a BLX inline, which has
  // no conditional version; R_ARM_JUMP24 would have to insert a veneer.
  //
  // MachO does not draw a distinction between the two cases, so it will treat
  // fixup_arm_uncondbl and fixup_arm_condbl as identical fixups.

  // Fixup for unconditional ARM BL instructions.</doc>
<use f='llvm/llvm/lib/Target/ARM/MCTargetDesc/ARMELFObjectWriter.cpp' l='103' c='_ZNK12_GLOBAL__N_118ARMELFObjectWriter17GetRelocTypeInnerERKN4llvm7MCValueERKNS1_7MCFixupEbRNS1_9MCContextE'/>
<use f='llvm/llvm/lib/Target/ARM/MCTargetDesc/ARMMCCodeEmitter.cpp' l='728' u='r' c='_ZNK12_GLOBAL__N_116ARMMCCodeEmitter21getARMBLTargetOpValueERKN4llvm6MCInstEjRNS1_15SmallVectorImplINS1_7MCFixupEEERKNS1_15MCSubtargetInfoE'/>
<use f='llvm/llvm/lib/Target/ARM/MCTargetDesc/ARMMachObjectWriter.cpp' l='95' c='_ZL24getARMFixupKindMachOInfojRjS_'/>
