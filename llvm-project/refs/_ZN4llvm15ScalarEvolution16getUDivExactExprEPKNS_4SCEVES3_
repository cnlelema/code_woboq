<dec f='llvm/llvm/include/llvm/Analysis/ScalarEvolution.h' l='575' type='const llvm::SCEV * llvm::ScalarEvolution::getUDivExactExpr(const llvm::SCEV * LHS, const llvm::SCEV * RHS)'/>
<def f='llvm/llvm/lib/Analysis/ScalarEvolution.cpp' l='3333' ll='3384' type='const llvm::SCEV * llvm::ScalarEvolution::getUDivExactExpr(const llvm::SCEV * LHS, const llvm::SCEV * RHS)'/>
<use f='llvm/llvm/lib/Analysis/ScalarEvolution.cpp' l='3369' u='c' c='_ZN4llvm15ScalarEvolution16getUDivExactExprEPKNS_4SCEVES3_'/>
<use f='llvm/llvm/lib/Analysis/ScalarEvolution.cpp' l='8376' u='c' c='_ZL28SolveLinEquationWithOverflowRKN4llvm5APIntEPKNS_4SCEVERNS_15ScalarEvolutionE'/>
<doc f='llvm/llvm/lib/Analysis/ScalarEvolution.cpp' l='3329'>/// Get a canonical unsigned division expression, or something simpler if
/// possible. There is no representation for an exact udiv in SCEV IR, but we
/// can attempt to remove factors from the LHS and RHS.  We can&apos;t do this when
/// it&apos;s not exact because the udiv may be clearing bits.</doc>
