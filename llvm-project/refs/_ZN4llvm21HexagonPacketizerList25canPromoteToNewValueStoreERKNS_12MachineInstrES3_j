<dec f='llvm/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.h' l='128' type='bool llvm::HexagonPacketizerList::canPromoteToNewValueStore(const llvm::MachineInstr &amp; MI, const llvm::MachineInstr &amp; PacketMI, unsigned int DepReg)'/>
<def f='llvm/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp' l='642' ll='808' type='bool llvm::HexagonPacketizerList::canPromoteToNewValueStore(const llvm::MachineInstr &amp; MI, const llvm::MachineInstr &amp; PacketMI, unsigned int DepReg)'/>
<use f='llvm/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp' l='819' u='c' c='_ZN4llvm21HexagonPacketizerList20canPromoteToNewValueERKNS_12MachineInstrEPKNS_5SUnitEjRNS_26MachineInstrBundleIteratorIS1_Lb0EEE'/>
<doc f='llvm/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp' l='625'>// Can be new value store?
// Following restrictions are to be respected in convert a store into
// a new value store.
// 1. If an instruction uses auto-increment, its address register cannot
//    be a new-value register. Arch Spec 5.4.2.1
// 2. If an instruction uses absolute-set addressing mode, its address
//    register cannot be a new-value register. Arch Spec 5.4.2.1.
// 3. If an instruction produces a 64-bit result, its registers cannot be used
//    as new-value registers. Arch Spec 5.4.2.2.
// 4. If the instruction that sets the new-value register is conditional, then
//    the instruction that uses the new-value register must also be conditional,
//    and both must always have their predicates evaluate identically.
//    Arch Spec 5.4.2.3.
// 5. There is an implied restriction that a packet cannot have another store,
//    if there is a new value store in the packet. Corollary: if there is
//    already a store in a packet, there can not be a new value store.
//    Arch Spec: 3.4.4.2</doc>
