<dec f='llvm/llvm/include/llvm/Transforms/Utils/FunctionComparator.h' l='222' type='int llvm::FunctionComparator::cmpConstants(const llvm::Constant * L, const llvm::Constant * R) const'/>
<doc f='llvm/llvm/include/llvm/Transforms/Utils/FunctionComparator.h' l='120'>/// Constants comparison.
  /// Its analog to lexicographical comparison between hypothetical numbers
  /// of next format:
  /// &lt;bitcastability-trait&gt;&lt;raw-bit-contents&gt;
  ///
  /// 1. Bitcastability.
  /// Check whether L&apos;s type could be losslessly bitcasted to R&apos;s type.
  /// On this stage method, in case when lossless bitcast is not possible
  /// method returns -1 or 1, thus also defining which type is greater in
  /// context of bitcastability.
  /// Stage 0: If types are equal in terms of cmpTypes, then we can go straight
  ///          to the contents comparison.
  ///          If types differ, remember types comparison result and check
  ///          whether we still can bitcast types.
  /// Stage 1: Types that satisfies isFirstClassType conditions are always
  ///          greater then others.
  /// Stage 2: Vector is greater then non-vector.
  ///          If both types are vectors, then vector with greater bitwidth is
  ///          greater.
  ///          If both types are vectors with the same bitwidth, then types
  ///          are bitcastable, and we can skip other stages, and go to contents
  ///          comparison.
  /// Stage 3: Pointer types are greater than non-pointers. If both types are
  ///          pointers of the same address space - go to contents comparison.
  ///          Different address spaces: pointer with greater address space is
  ///          greater.
  /// Stage 4: Types are neither vectors, nor pointers. And they differ.
  ///          We don&apos;t know how to bitcast them. So, we better don&apos;t do it,
  ///          and return types comparison result (so it determines the
  ///          relationship among constants we don&apos;t know how to bitcast).
  ///
  /// Just for clearance, let&apos;s see how the set of constants could look
  /// on single dimension axis:
  ///
  /// [NFCT], [FCT, &quot;others&quot;], [FCT, pointers], [FCT, vectors]
  /// Where: NFCT - Not a FirstClassType
  ///        FCT - FirstClassTyp:
  ///
  /// 2. Compare raw contents.
  /// It ignores types on this stage and only compares bits from L and R.
  /// Returns 0, if L and R has equivalent contents.
  /// -1 or 1 if values are different.
  /// Pretty trivial:
  /// 2.1. If contents are numbers, compare numbers.
  ///    Ints with greater bitwidth are greater. Ints with same bitwidths
  ///    compared by their contents.
  /// 2.2. &quot;And so on&quot;. Just to avoid discrepancies with comments
  /// perhaps it would be better to read the implementation itself.
  /// 3. And again about overall picture. Let&apos;s look back at how the ordered set
  /// of constants will look like:
  /// [NFCT], [FCT, &quot;others&quot;], [FCT, pointers], [FCT, vectors]
  ///
  /// Now look, what could be inside [FCT, &quot;others&quot;], for example:
  /// [FCT, &quot;others&quot;] =
  /// [
  ///   [double 0.1], [double 1.23],
  ///   [i32 1], [i32 2],
  ///   { double 1.0 },       ; StructTyID, NumElements = 1
  ///   { i32 1 },            ; StructTyID, NumElements = 1
  ///   { double 1, i32 1 },  ; StructTyID, NumElements = 2
  ///   { i32 1, double 1 }   ; StructTyID, NumElements = 2
  /// ]
  ///
  /// Let&apos;s explain the order. Float numbers will be less than integers, just
  /// because of cmpType terms: FloatTyID &lt; IntegerTyID.
  /// Floats (with same fltSemantics) are sorted according to their value.
  /// Then you can see integers, and they are, like a floats,
  /// could be easy sorted among each others.
  /// The structures. Structures are grouped at the tail, again because of their
  /// TypeID: StructTyID &gt; IntegerTyID &gt; FloatTyID.
  /// Structures with greater number of elements are greater. Structures with
  /// greater elements going first are greater.
  /// The same logic with vectors, arrays and other possible complex types.
  ///
  /// Bitcastable constants.
  /// Let&apos;s assume, that some constant, belongs to some group of
  /// &quot;so-called-equal&quot; values with different types, and at the same time
  /// belongs to another group of constants with equal types
  /// and &quot;really&quot; equal values.
  ///
  /// Now, prove that this is impossible:
  ///
  /// If constant A with type TyA is bitcastable to B with type TyB, then:
  /// 1. All constants with equal types to TyA, are bitcastable to B. Since
  ///    those should be vectors (if TyA is vector), pointers
  ///    (if TyA is pointer), or else (if TyA equal to TyB), those types should
  ///    be equal to TyB.
  /// 2. All constants with non-equal, but bitcastable types to TyA, are
  ///    bitcastable to B.
  ///    Once again, just because we allow it to vectors and pointers only.
  ///    This statement could be expanded as below:
  /// 2.1. All vectors with equal bitwidth to vector A, has equal bitwidth to
  ///      vector B, and thus bitcastable to B as well.
  /// 2.2. All pointers of the same address space, no matter what they point to,
  ///      bitcastable. So if C is pointer, it could be bitcasted to A and to B.
  /// So any constant equal or bitcastable to A is equal or bitcastable to B.
  /// QED.
  ///
  /// In another words, for pointers and vectors, we ignore top-level type and
  /// look at their particular properties (bit-width for vectors, and
  /// address space for pointers).
  /// If these properties are equal - compare their contents.</doc>
<def f='llvm/llvm/lib/Transforms/Utils/FunctionComparator.cpp' l='187' ll='382' type='int llvm::FunctionComparator::cmpConstants(const llvm::Constant * L, const llvm::Constant * R) const'/>
<use f='llvm/llvm/lib/Transforms/Utils/FunctionComparator.cpp' l='295' u='c' c='_ZNK4llvm18FunctionComparator12cmpConstantsEPKNS_8ConstantES3_'/>
<use f='llvm/llvm/lib/Transforms/Utils/FunctionComparator.cpp' l='309' u='c' c='_ZNK4llvm18FunctionComparator12cmpConstantsEPKNS_8ConstantES3_'/>
<use f='llvm/llvm/lib/Transforms/Utils/FunctionComparator.cpp' l='323' u='c' c='_ZNK4llvm18FunctionComparator12cmpConstantsEPKNS_8ConstantES3_'/>
<use f='llvm/llvm/lib/Transforms/Utils/FunctionComparator.cpp' l='337' u='c' c='_ZNK4llvm18FunctionComparator12cmpConstantsEPKNS_8ConstantES3_'/>
<use f='llvm/llvm/lib/Transforms/Utils/FunctionComparator.cpp' l='724' u='c' c='_ZNK4llvm18FunctionComparator9cmpValuesEPKNS_5ValueES3_'/>
<doc f='llvm/llvm/lib/Transforms/Utils/FunctionComparator.cpp' l='182'>/// Constants comparison:
/// 1. Check whether type of L constant could be losslessly bitcasted to R
/// type.
/// 2. Compare constant contents.
/// For more details see declaration comments.</doc>
<use f='llvm/llvm/unittests/Transforms/Utils/FunctionComparatorTest.cpp' l='73' u='c' c='_ZN14TestComparator16testCmpConstantsEPKN4llvm8ConstantES3_'/>
