<dec f='llvm/llvm/include/llvm/Analysis/ScalarEvolutionExpressions.h' l='148' type='const llvm::SCEV *const *'/>
<use f='llvm/llvm/include/llvm/Analysis/ScalarEvolutionExpressions.h' l='153' u='w' c='_ZN4llvm12SCEVNAryExprC1ENS_19FoldingSetNodeIDRefENS_9SCEVTypesEPKPKNS_4SCEVEm'/>
<use f='llvm/llvm/include/llvm/Analysis/ScalarEvolutionExpressions.h' l='161' u='r' c='_ZNK4llvm12SCEVNAryExpr10getOperandEj'/>
<use f='llvm/llvm/include/llvm/Analysis/ScalarEvolutionExpressions.h' l='167' u='r' c='_ZNK4llvm12SCEVNAryExpr8op_beginEv'/>
<use f='llvm/llvm/include/llvm/Analysis/ScalarEvolutionExpressions.h' l='168' u='r' c='_ZNK4llvm12SCEVNAryExpr6op_endEv'/>
<use f='llvm/llvm/include/llvm/Analysis/ScalarEvolutionExpressions.h' l='306' u='r' c='_ZNK4llvm14SCEVAddRecExpr8getStartEv'/>
<offset>256</offset>
<doc f='llvm/llvm/include/llvm/Analysis/ScalarEvolutionExpressions.h' l='144'>// Since SCEVs are immutable, ScalarEvolution allocates operand
    // arrays with its SCEVAllocator, so this class just needs a simple
    // pointer rather than a more elaborate vector-like data structure.
    // This also avoids the need for a non-trivial destructor.</doc>
