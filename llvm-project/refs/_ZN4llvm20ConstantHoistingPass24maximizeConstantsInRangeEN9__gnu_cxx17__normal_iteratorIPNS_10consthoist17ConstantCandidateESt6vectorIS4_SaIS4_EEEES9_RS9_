<dec f='llvm/llvm/include/llvm/Transforms/Scalar/ConstantHoisting.h' l='187' type='unsigned int llvm::ConstantHoistingPass::maximizeConstantsInRange(ConstCandVecType::iterator S, ConstCandVecType::iterator E, ConstCandVecType::iterator &amp; MaxCostItr)'/>
<def f='llvm/llvm/lib/Transforms/Scalar/ConstantHoisting.cpp' l='550' ll='606' type='unsigned int llvm::ConstantHoistingPass::maximizeConstantsInRange(ConstCandVecType::iterator S, ConstCandVecType::iterator E, ConstCandVecType::iterator &amp; MaxCostItr)'/>
<use f='llvm/llvm/lib/Transforms/Scalar/ConstantHoisting.cpp' l='614' u='c' c='_ZN4llvm20ConstantHoistingPass23findAndMakeBaseConstantEN9__gnu_cxx17__normal_iteratorIPNS_10consthoist17ConstantCandidateESt6vectorIS4_SaIS4_EEEES9_R16621152'/>
<doc f='llvm/llvm/lib/Transforms/Scalar/ConstantHoisting.cpp' l='527'>// From a list of constants, one needs to picked as the base and the other
// constants will be transformed into an offset from that base constant. The
// question is which we can pick best? For example, consider these constants
// and their number of uses:
//
//  Constants| 2 | 4 | 12 | 42 |
//  NumUses  | 3 | 2 |  8 |  7 |
//
// Selecting constant 12 because it has the most uses will generate negative
// offsets for constants 2 and 4 (i.e. -10 and -8 respectively). If negative
// offsets lead to less optimal code generation, then there might be better
// solutions. Suppose immediates in the range of 0..35 are most optimally
// supported by the architecture, then selecting constant 2 is most optimal
// because this will generate offsets: 0, 2, 10, 40. Offsets 0, 2 and 10 are in
// range 0..35, and thus 3 + 2 + 8 = 13 uses are in range. Selecting 12 would
// have only 8 uses in range, so choosing 2 as a base is more optimal. Thus, in
// selecting the base constant the range of the offsets is a very important
// factor too that we take into account here. This algorithm calculates a total
// costs for selecting a constant as the base and substract the costs if
// immediates are out of range. It has quadratic complexity, so we call this
// function only when we&apos;re optimising for size and there are less than 100
// constants, we fall back to the straightforward algorithm otherwise
// which does not do all the offset calculations.</doc>
