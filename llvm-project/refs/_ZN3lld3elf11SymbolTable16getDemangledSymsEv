<dec f='llvm/lld/ELF/SymbolTable.h' l='72' type='llvm::StringMap&lt;std::vector&lt;Symbol *&gt; &gt; &amp; lld::elf::SymbolTable::getDemangledSyms()'/>
<def f='llvm/lld/ELF/SymbolTable.cpp' l='152' ll='165' type='StringMap&lt;std::vector&lt;Symbol *&gt; &gt; &amp; lld::elf::SymbolTable::getDemangledSyms()'/>
<use f='llvm/lld/ELF/SymbolTable.cpp' l='169' u='c' c='_ZN3lld3elf11SymbolTable13findByVersionENS0_13SymbolVersionE'/>
<use f='llvm/lld/ELF/SymbolTable.cpp' l='181' u='c' c='_ZN3lld3elf11SymbolTable16findAllByVersionENS0_13SymbolVersionE'/>
<doc f='llvm/lld/ELF/SymbolTable.cpp' l='139'>// Initialize DemangledSyms with a map from demangled symbols to symbol
// objects. Used to handle &quot;extern C++&quot; directive in version scripts.
//
// The map will contain all demangled symbols. That can be very large,
// and in LLD we generally want to avoid do anything for each symbol.
// Then, why are we doing this? Here&apos;s why.
//
// Users can use &quot;extern C++ {}&quot; directive to match against demangled
// C++ symbols. For example, you can write a pattern such as
// &quot;llvm::*::foo(int, ?)&quot;. Obviously, there&apos;s no way to handle this
// other than trying to match a pattern against all demangled symbols.
// So, if &quot;extern C++&quot; feature is used, we need to demangle all known
// symbols.</doc>
