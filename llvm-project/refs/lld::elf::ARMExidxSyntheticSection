<inh f='llvm/lld/ELF/SyntheticSections.h' l='38' c='lld::elf::SyntheticSection'/>
<def f='llvm/lld/ELF/SyntheticSections.h' l='987' ll='1025'/>
<size>264</size>
<doc f='llvm/lld/ELF/SyntheticSections.h' l='953'>// Representation of the combined .ARM.Exidx input sections. We process these
// as a SyntheticSection like .eh_frame as we need to merge duplicate entries
// and add terminating sentinel entries.
//
// The .ARM.exidx input sections after SHF_LINK_ORDER processing is done form
// a table that the unwinder can derive (Addresses are encoded as offsets from
// table):
// | Address of function | Unwind instructions for function |
// where the unwind instructions are either a small number of unwind or the
// special EXIDX_CANTUNWIND entry representing no unwinding information.
// When an exception is thrown from an address A, the unwinder searches the
// table for the closest table entry with Address of function &lt;= A. This means
// that for two consecutive table entries:
// | A1 | U1 |
// | A2 | U2 |
// The range of addresses described by U1 is [A1, A2)
//
// There are two cases where we need a linker generated table entry to fixup
// the address ranges in the table
// Case 1:
// - A sentinel entry added with an address higher than all
// executable sections. This was needed to work around libunwind bug pr31091.
// - After address assignment we need to find the highest addressed executable
// section and use the limit of that section so that the unwinder never
// matches it.
// Case 2:
// - InputSections without a .ARM.exidx section (usually from Assembly)
// need a table entry so that they terminate the range of the previously
// function. This is pr40277.
//
// Instead of storing pointers to the .ARM.exidx InputSections from
// InputObjects, we store pointers to the executable sections that need
// .ARM.exidx sections. We can then use the dependentSections of these to
// either find the .ARM.exidx section or know that we need to generate one.</doc>
<fun r='_ZN3lld3elf24ARMExidxSyntheticSectionC1Ev'/>
<fun r='_ZN3lld3elf24ARMExidxSyntheticSection10addSectionEPNS0_12InputSectionE'/>
<fun r='_ZNK3lld3elf24ARMExidxSyntheticSection7getSizeEv'/>
<fun r='_ZN3lld3elf24ARMExidxSyntheticSection7writeToEPh'/>
<fun r='_ZNK3lld3elf24ARMExidxSyntheticSection8isNeededEv'/>
<fun r='_ZN3lld3elf24ARMExidxSyntheticSection16finalizeContentsEv'/>
<fun r='_ZNK3lld3elf24ARMExidxSyntheticSection15getLinkOrderDepEv'/>
<fun r='_ZN3lld3elf24ARMExidxSyntheticSection7classofEPKNS0_11SectionBaseE'/>
<mbr r='lld::elf::ARMExidxSyntheticSection::ExidxSections' o='1536' t='std::vector&lt;InputSection *&gt;'/>
<mbr r='lld::elf::ARMExidxSyntheticSection::Size' o='1728' t='size_t'/>
<mbr r='lld::elf::ARMExidxSyntheticSection::Empty' o='1792' t='bool'/>
<mbr r='lld::elf::ARMExidxSyntheticSection::ExecutableSections' o='1856' t='std::vector&lt;InputSection *&gt;'/>
<mbr r='lld::elf::ARMExidxSyntheticSection::Sentinel' o='2048' t='lld::elf::InputSection *'/>
