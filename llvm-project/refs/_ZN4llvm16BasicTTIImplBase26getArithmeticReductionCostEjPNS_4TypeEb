<def f='llvm/llvm/include/llvm/CodeGen/BasicTTIImpl.h' l='1567' ll='1613' type='unsigned int llvm::BasicTTIImplBase::getArithmeticReductionCost(unsigned int Opcode, llvm::Type * Ty, bool IsPairwise)'/>
<doc f='llvm/llvm/include/llvm/CodeGen/BasicTTIImpl.h' l='1532'>/// Try to calculate arithmetic and shuffle op costs for reduction operations.
  /// We&apos;re assuming that reduction operation are performing the following way:
  /// 1. Non-pairwise reduction
  /// %val1 = shufflevector&lt;n x t&gt; %val, &lt;n x t&gt; %undef,
  /// &lt;n x i32&gt; &lt;i32 n/2, i32 n/2 + 1, ..., i32 n, i32 undef, ..., i32 undef&gt;
  ///            \----------------v-------------/  \----------v------------/
  ///                            n/2 elements               n/2 elements
  /// %red1 = op &lt;n x t&gt; %val, &lt;n x t&gt; val1
  /// After this operation we have a vector %red1 where only the first n/2
  /// elements are meaningful, the second n/2 elements are undefined and can be
  /// dropped. All other operations are actually working with the vector of
  /// length n/2, not n, though the real vector length is still n.
  /// %val2 = shufflevector&lt;n x t&gt; %red1, &lt;n x t&gt; %undef,
  /// &lt;n x i32&gt; &lt;i32 n/4, i32 n/4 + 1, ..., i32 n/2, i32 undef, ..., i32 undef&gt;
  ///            \----------------v-------------/  \----------v------------/
  ///                            n/4 elements               3*n/4 elements
  /// %red2 = op &lt;n x t&gt; %red1, &lt;n x t&gt; val2  - working with the vector of
  /// length n/2, the resulting vector has length n/4 etc.
  /// 2. Pairwise reduction:
  /// Everything is the same except for an additional shuffle operation which
  /// is used to produce operands for pairwise kind of reductions.
  /// %val1 = shufflevector&lt;n x t&gt; %val, &lt;n x t&gt; %undef,
  /// &lt;n x i32&gt; &lt;i32 0, i32 2, ..., i32 n-2, i32 undef, ..., i32 undef&gt;
  ///            \-------------v----------/  \----------v------------/
  ///                   n/2 elements               n/2 elements
  /// %val2 = shufflevector&lt;n x t&gt; %val, &lt;n x t&gt; %undef,
  /// &lt;n x i32&gt; &lt;i32 1, i32 3, ..., i32 n-1, i32 undef, ..., i32 undef&gt;
  ///            \-------------v----------/  \----------v------------/
  ///                   n/2 elements               n/2 elements
  /// %red1 = op &lt;n x t&gt; %val1, &lt;n x t&gt; val2
  /// Again, the operation is performed on &lt;n x t&gt; vector, but the resulting
  /// vector %red1 is &lt;n/2 x t&gt; vector.
  ///
  /// The cost model should take into account that the actual length of the
  /// vector is reduced on each iteration.</doc>
<use f='llvm/llvm/lib/Target/AArch64/AArch64TargetTransformInfo.cpp' l='927' u='c' c='_ZN4llvm14AArch64TTIImpl26getArithmeticReductionCostEjPNS_4TypeEb'/>
<use f='llvm/llvm/lib/Target/AArch64/AArch64TargetTransformInfo.cpp' l='948' u='c' c='_ZN4llvm14AArch64TTIImpl26getArithmeticReductionCostEjPNS_4TypeEb'/>
<use f='llvm/llvm/lib/Target/AMDGPU/AMDGPUTargetTransformInfo.cpp' l='467' u='c' c='_ZN4llvm10GCNTTIImpl26getArithmeticReductionCostEjPNS_4TypeEb'/>
<use f='llvm/llvm/lib/Target/X86/X86TargetTransformInfo.cpp' l='2537' u='c' c='_ZN4llvm10X86TTIImpl26getArithmeticReductionCostEjPNS_4TypeEb'/>
