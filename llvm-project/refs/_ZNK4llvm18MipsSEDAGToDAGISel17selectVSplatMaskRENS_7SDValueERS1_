<dec f='llvm/llvm/lib/Target/Mips/MipsSEISelDAGToDAG.h' l='130' type='bool llvm::MipsSEDAGToDAGISel::selectVSplatMaskR(llvm::SDValue N, llvm::SDValue &amp; Imm) const'/>
<doc f='llvm/llvm/lib/Target/Mips/MipsSEISelDAGToDAG.h' l='128'>/// Select constant vector splats whose value is a run of set bits
  /// starting at bit zero.</doc>
<inh f='llvm/llvm/lib/Target/Mips/MipsISelDAGToDAG.h' l='127' c='_ZNK4llvm16MipsDAGToDAGISel17selectVSplatMaskRENS_7SDValueERS1_'/>
<def f='llvm/llvm/lib/Target/Mips/MipsSEISelDAGToDAG.cpp' l='800' ll='819' type='bool llvm::MipsSEDAGToDAGISel::selectVSplatMaskR(llvm::SDValue N, llvm::SDValue &amp; Imm) const'/>
<doc f='llvm/llvm/lib/Target/Mips/MipsSEISelDAGToDAG.cpp' l='789'>// Select constant vector splats whose value only has a consecutive sequence
// of right-most bits set (e.g. 0b00...0011...11).
//
// In addition to the requirements of selectVSplat(), this function returns
// true and sets Imm if:
// * The splat value is the same width as the elements of the vector
// * The splat value is a consecutive sequence of right-most bits.
//
// This function looks through ISD::BITCAST nodes.
// TODO: This might not be appropriate for big-endian MSA since BITCAST is
//       sometimes a shuffle in big-endian mode.</doc>
