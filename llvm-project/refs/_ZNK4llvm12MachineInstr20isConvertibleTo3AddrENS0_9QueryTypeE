<def f='llvm/llvm/include/llvm/CodeGen/MachineInstr.h' l='878' ll='880' type='bool llvm::MachineInstr::isConvertibleTo3Addr(llvm::MachineInstr::QueryType Type = IgnoreBundle) const'/>
<doc f='llvm/llvm/include/llvm/CodeGen/MachineInstr.h' l='864'>/// Return true if this is a 2-address instruction
  /// which can be changed into a 3-address instruction if needed.  Doing this
  /// transformation can be profitable in the register allocator, because it
  /// means that the instruction can use a 2-address form if possible, but
  /// degrade into a less efficient form if the source and dest register cannot
  /// be assigned to the same register.  For example, this allows the x86
  /// backend to turn a &quot;shl reg, 3&quot; instruction into an LEA instruction, which
  /// is the same speed as the shift but has bigger code size.
  ///
  /// If this returns true, then the target must implement the
  /// TargetInstrInfo::convertToThreeAddress method for this instruction, which
  /// is allowed to fail if the transformation isn&apos;t valid for this specific
  /// instruction (e.g. shl reg, 4 on x86).
  ///</doc>
<use f='llvm/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp' l='1299' u='c' c='_ZN12_GLOBAL__N_125TwoAddressInstructionPass23tryInstructionTransformERN4llvm26MachineInstrBundleIteratorINS1_12MachineInstrELb0EEES5_jjjb'/>
<use f='llvm/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp' l='1319' u='c' c='_ZN12_GLOBAL__N_125TwoAddressInstructionPass23tryInstructionTransformERN4llvm26MachineInstrBundleIteratorINS1_12MachineInstrELb0EEES5_jjjb'/>
<use f='llvm/llvm/lib/Target/X86/X86FixupLEAs.cpp' l='148' u='c' c='_ZNK12_GLOBAL__N_112FixupLEAPass18postRAConvertToLEAERN4llvm17MachineBasicBlockERNS1_26MachineInstrBundleIteratorINS1_12MachineInstrELb0EEE'/>
