<dec f='llvm/llvm/include/llvm/Transforms/Scalar/GVN.h' l='287' type='bool llvm::GVN::processFoldableCondBr(llvm::BranchInst * BI)'/>
<use f='llvm/llvm/lib/Transforms/Scalar/GVN.cpp' l='1903' u='c' c='_ZN4llvm3GVN18processInstructionEPNS_11InstructionE'/>
<def f='llvm/llvm/lib/Transforms/Scalar/GVN.cpp' l='2520' ll='2542' type='bool llvm::GVN::processFoldableCondBr(llvm::BranchInst * BI)'/>
<doc f='llvm/llvm/lib/Transforms/Scalar/GVN.cpp' l='2507'>// If the given branch is recognized as a foldable branch (i.e. conditional
// branch with constant condition), it will perform following analyses and
// transformation.
//  1) If the dead out-coming edge is a critical-edge, split it. Let
//     R be the target of the dead out-coming edge.
//  1) Identify the set of dead blocks implied by the branch&apos;s dead outcoming
//     edge. The result of this step will be {X| X is dominated by R}
//  2) Identify those blocks which haves at least one dead predecessor. The
//     result of this step will be dominance-frontier(R).
//  3) Update the PHIs in DF(R) by replacing the operands corresponding to
//     dead blocks with &quot;UndefVal&quot; in an hope these PHIs will optimized away.
//
// Return true iff *NEW* dead code are found.</doc>
