<dec f='llvm/llvm/include/llvm/Analysis/GlobalsModRef.h' l='113' type='bool llvm::GlobalsAAResult::AnalyzeIndirectGlobalMemory(llvm::GlobalVariable * GV)'/>
<use f='llvm/llvm/lib/Analysis/GlobalsModRef.cpp' l='329' u='c' c='_ZN4llvm15GlobalsAAResult14AnalyzeGlobalsERNS_6ModuleE'/>
<def f='llvm/llvm/lib/Analysis/GlobalsModRef.cpp' l='402' ll='464' type='bool llvm::GlobalsAAResult::AnalyzeIndirectGlobalMemory(llvm::GlobalVariable * GV)'/>
<doc f='llvm/llvm/lib/Analysis/GlobalsModRef.cpp' l='395'>/// AnalyzeIndirectGlobalMemory - We found an non-address-taken global variable
/// which holds a pointer type.  See if the global always points to non-aliased
/// heap memory: that is, all initializers of the globals are allocations, and
/// those allocations have no use other than initialization of the global.
/// Further, all loads out of GV must directly use the memory, not store the
/// pointer somewhere.  If this is true, we consider the memory pointed to by
/// GV to be owned by GV and can disambiguate other pointers from it.</doc>
