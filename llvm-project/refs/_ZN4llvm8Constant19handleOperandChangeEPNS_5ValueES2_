<dec f='llvm/llvm/include/llvm/IR/Constant.h' l='158' type='void llvm::Constant::handleOperandChange(llvm::Value * , llvm::Value * )'/>
<doc f='llvm/llvm/include/llvm/IR/Constant.h' l='148'>/// This method is a special form of User::replaceUsesOfWith
  /// (which does not work on constants) that does work
  /// on constants.  Basically this method goes through the trouble of building
  /// a new constant that is equivalent to the current one, with all uses of
  /// From replaced with uses of To.  After this construction is completed, all
  /// of the users of &apos;this&apos; are replaced to use the new constant, and then
  /// &apos;this&apos; is deleted.  In general, you should not call this method, instead,
  /// use Value::replaceAllUsesWith, which automatically dispatches to this
  /// method as needed.
  ///</doc>
<def f='llvm/llvm/lib/IR/Constants.cpp' l='2836' ll='2861' type='void llvm::Constant::handleOperandChange(llvm::Value * From, llvm::Value * To)'/>
<doc f='llvm/llvm/lib/IR/Constants.cpp' l='2822'>//===----------------------------------------------------------------------===//
//                handleOperandChange implementations

/// Update this constant array to change uses of
/// &apos;From&apos; to be uses of &apos;To&apos;.  This must update the uniquing data structures
/// etc.
///
/// Note that we intentionally replace all uses of From with To here.  Consider
/// a large array that uses &apos;From&apos; 1000 times.  By handling this case all here,
/// ConstantArray::handleOperandChange is only invoked once, and that
/// single invocation handles all 1000 uses.  Handling them one at a time would
/// work, but would be really slow because it would have to unique each updated
/// array instance.
///</doc>
<use f='llvm/llvm/lib/IR/Value.cpp' l='417' u='c' c='_ZN4llvm5Value6doRAUWEPS0_NS0_19ReplaceMetadataUsesE'/>
<use f='llvm/llvm/lib/Transforms/IPO/LowerTypeTests.cpp' l='1677' u='c' c='_ZN12_GLOBAL__N_120LowerTypeTestsModule14replaceCfiUsesEPN4llvm8FunctionEPNS1_5ValueEb'/>
