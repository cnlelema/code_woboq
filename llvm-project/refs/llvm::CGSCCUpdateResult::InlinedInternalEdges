<dec f='llvm/llvm/include/llvm/Analysis/CGSCCPassManager.h' l='316' type='SmallDenseSet&lt;std::pair&lt;LazyCallGraph::Node *, LazyCallGraph::SCC *&gt;, 4&gt; &amp;'/>
<offset>1280</offset>
<doc f='llvm/llvm/include/llvm/Analysis/CGSCCPassManager.h' l='309'>/// A hacky area where the inliner can retain history about inlining
  /// decisions that mutated the call graph&apos;s SCC structure in order to avoid
  /// infinite inlining. See the comments in the inliner&apos;s CG update logic.
  ///
  /// FIXME: Keeping this here seems like a big layering issue, we should look
  /// for a better technique.</doc>
<use f='llvm/llvm/lib/Transforms/IPO/Inliner.cpp' l='1038' u='m' c='_ZN4llvm11InlinerPass3runERNS_13LazyCallGraph3SCCERNS_15AnalysisManagerIS2_JRS1_EEES5_RNS_17CGSCCUpdateResultE'/>
<use f='llvm/llvm/lib/Transforms/IPO/Inliner.cpp' l='1192' u='m' c='_ZN4llvm11InlinerPass3runERNS_13LazyCallGraph3SCCERNS_15AnalysisManagerIS2_JRS1_EEES5_RNS_17CGSCCUpdateResultE'/>
