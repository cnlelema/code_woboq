<dec f='llvm/llvm/include/llvm/CodeGen/TargetInstrInfo.h' l='509' type='bool llvm::TargetInstrInfo::getInsertSubregInputs(const llvm::MachineInstr &amp; MI, unsigned int DefIdx, llvm::TargetInstrInfo::RegSubRegPair &amp; BaseReg, llvm::TargetInstrInfo::RegSubRegPairAndIdx &amp; InsertedReg) const'/>
<doc f='llvm/llvm/include/llvm/CodeGen/TargetInstrInfo.h' l='492'>/// Build the equivalent inputs of a INSERT_SUBREG for the given \p MI
  /// and \p DefIdx.
  /// \p [out] BaseReg and \p [out] InsertedReg contain
  /// the equivalent inputs of INSERT_SUBREG.
  /// E.g., INSERT_SUBREG %0:sub0, %1:sub1, sub3 would produce:
  /// - BaseReg: %0:sub0
  /// - InsertedReg: %1:sub1, sub3
  ///
  /// \returns true if it is possible to build such an input sequence
  /// with the pair \p MI, \p DefIdx and the operand has no undef flag set.
  /// False otherwise.
  ///
  /// \pre MI.isInsertSubreg() or MI.isInsertSubregLike().
  ///
  /// \note The generic implementation does not provide any support for
  /// MI.isInsertSubregLike(). In other words, one has to override
  /// getInsertSubregLikeInputs for target specific instructions.</doc>
<use f='llvm/llvm/lib/CodeGen/PeepholeOptimizer.cpp' l='1930' u='c' c='_ZN12_GLOBAL__N_112ValueTracker29getNextSourceFromInsertSubregEv'/>
<def f='llvm/llvm/lib/CodeGen/TargetInstrInfo.cpp' l='1197' ll='1223' type='bool llvm::TargetInstrInfo::getInsertSubregInputs(const llvm::MachineInstr &amp; MI, unsigned int DefIdx, llvm::TargetInstrInfo::RegSubRegPair &amp; BaseReg, llvm::TargetInstrInfo::RegSubRegPairAndIdx &amp; InsertedReg) const'/>
