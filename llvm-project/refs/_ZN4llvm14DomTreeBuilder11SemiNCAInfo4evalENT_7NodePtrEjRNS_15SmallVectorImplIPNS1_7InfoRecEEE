<def f='llvm/llvm/include/llvm/Support/GenericDomTreeConstruction.h' l='273' ll='301' type='NodePtr llvm::DomTreeBuilder::SemiNCAInfo::eval(NodePtr V, unsigned int LastLinked, SmallVectorImpl&lt;llvm::DomTreeBuilder::SemiNCAInfo::InfoRec *&gt; &amp; Stack)'/>
<use f='llvm/llvm/include/llvm/Support/GenericDomTreeConstruction.h' l='330' u='c' c='_ZN4llvm14DomTreeBuilder11SemiNCAInfo10runSemiNCAERT_j'/>
<doc f='llvm/llvm/include/llvm/Support/GenericDomTreeConstruction.h' l='260'>// V is a predecessor of W. eval() returns V if V &lt; W, otherwise the minimum
  // of sdom(U), where U &gt; W and there is a virtual forest path from U to V. The
  // virtual forest consists of linked edges of processed vertices.
  //
  // We can follow Parent pointers (virtual forest edges) to determine the
  // ancestor U with minimum sdom(U). But it is slow and thus we employ the path
  // compression technique to speed up to O(m*log(n)). Theoretically the virtual
  // forest can be organized as balanced trees to achieve almost linear
  // O(m*alpha(m,n)) running time. But it requires two auxiliary arrays (Size
  // and Child) and is unlikely to be faster than the simple implementation.
  //
  // For each vertex V, its Label points to the vertex with the minimal sdom(U)
  // (Semi) in its path from V (included) to NodeToInfo[V].Parent (excluded).</doc>
