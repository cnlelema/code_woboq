<dec f='llvm/llvm/include/llvm/Transforms/Scalar/Reassociate.h' l='114' type='bool llvm::ReassociatePass::CombineXorOpnd(llvm::Instruction * I, reassociate::XorOpnd * Opnd1, reassociate::XorOpnd * Opnd2, llvm::APInt &amp; ConstOpnd, llvm::Value *&amp; Res)'/>
<def f='llvm/llvm/lib/Transforms/Scalar/Reassociate.cpp' l='1230' ll='1300' type='bool llvm::ReassociatePass::CombineXorOpnd(llvm::Instruction * I, llvm::reassociate::XorOpnd * Opnd1, llvm::reassociate::XorOpnd * Opnd2, llvm::APInt &amp; ConstOpnd, llvm::Value *&amp; Res)'/>
<use f='llvm/llvm/lib/Transforms/Scalar/Reassociate.cpp' l='1384' u='c' c='_ZN4llvm15ReassociatePass11OptimizeXorEPNS_11InstructionERNS_15SmallVectorImplINS_11reassociate10ValueEntryEEE'/>
<doc f='llvm/llvm/lib/Transforms/Scalar/Reassociate.cpp' l='1222'>// Helper function of OptimizeXor(). It tries to simplify
// &quot;Opnd1 ^ Opnd2 ^ ConstOpnd&quot; into &quot;R ^ C&quot;, where C would be 0, and R is a
// symbolic value.
//
// If it was successful, true is returned, and the &quot;R&quot; and &quot;C&quot; is returned
// via &quot;Res&quot; and &quot;ConstOpnd&quot;, respectively (If the entire expression is
// evaluated to a constant, the Res is set to NULL); otherwise, false is
// returned, and both &quot;Res&quot; and &quot;ConstOpnd&quot; remain unchanged.</doc>
