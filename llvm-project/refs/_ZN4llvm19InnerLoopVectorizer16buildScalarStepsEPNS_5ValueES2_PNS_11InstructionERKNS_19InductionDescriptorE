<dec f='llvm/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp' l='534' type='void llvm::InnerLoopVectorizer::buildScalarSteps(llvm::Value * ScalarIV, llvm::Value * Step, llvm::Instruction * EntryVal, const llvm::InductionDescriptor &amp; ID)'/>
<use f='llvm/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp' l='1757' u='c' c='_ZN4llvm19InnerLoopVectorizer21widenIntOrFpInductionEPNS_7PHINodeEPNS_9TruncInstE'/>
<def f='llvm/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp' l='1816' ll='1855' type='void llvm::InnerLoopVectorizer::buildScalarSteps(llvm::Value * ScalarIV, llvm::Value * Step, llvm::Instruction * EntryVal, const llvm::InductionDescriptor &amp; ID)'/>
<doc f='llvm/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp' l='529'>/// Compute scalar induction steps. \p ScalarIV is the scalar induction
  /// variable on which to base the steps, \p Step is the size of the step, and
  /// \p EntryVal is the value from the original loop that maps to the steps.
  /// Note that \p EntryVal doesn&apos;t have to be an induction variable - it
  /// can also be a truncate instruction.</doc>
