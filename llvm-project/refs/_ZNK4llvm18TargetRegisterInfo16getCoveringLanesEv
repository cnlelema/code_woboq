<def f='llvm/llvm/include/llvm/CodeGen/TargetRegisterInfo.h' l='418' type='llvm::LaneBitmask llvm::TargetRegisterInfo::getCoveringLanes() const'/>
<doc f='llvm/llvm/include/llvm/CodeGen/TargetRegisterInfo.h' l='395'>/// The lane masks returned by getSubRegIndexLaneMask() above can only be
  /// used to determine if sub-registers overlap - they can&apos;t be used to
  /// determine if a set of sub-registers completely cover another
  /// sub-register.
  ///
  /// The X86 general purpose registers have two lanes corresponding to the
  /// sub_8bit and sub_8bit_hi sub-registers. Both sub_32bit and sub_16bit have
  /// lane masks &apos;3&apos;, but the sub_16bit sub-register doesn&apos;t fully cover the
  /// sub_32bit sub-register.
  ///
  /// On the other hand, the ARM NEON lanes fully cover their registers: The
  /// dsub_0 sub-register is completely covered by the ssub_0 and ssub_1 lanes.
  /// This is related to the CoveredBySubRegs property on register definitions.
  ///
  /// This function returns a bit mask of lanes that completely cover their
  /// sub-registers. More precisely, given:
  ///
  ///   Covering = getCoveringLanes();
  ///   MaskA = getSubRegIndexLaneMask(SubA);
  ///   MaskB = getSubRegIndexLaneMask(SubB);
  ///
  /// If (MaskA &amp; ~(MaskB &amp; Covering)) == 0, then SubA is completely covered by
  /// SubB.</doc>
