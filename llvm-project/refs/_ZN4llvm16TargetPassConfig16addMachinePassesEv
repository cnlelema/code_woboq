<dec f='llvm/llvm/include/llvm/CodeGen/TargetPassConfig.h' l='275' type='void llvm::TargetPassConfig::addMachinePasses()'/>
<doc f='llvm/llvm/include/llvm/CodeGen/TargetPassConfig.h' l='273'>/// Add the complete, standard set of LLVM CodeGen passes.
  /// Fully developed targets will not generally override this.</doc>
<use f='llvm/llvm/lib/CodeGen/LLVMTargetMachine.cpp' l='112' u='c' c='_ZL23addPassesToGenerateCodeRN4llvm17LLVMTargetMachineERNS_6legacy15PassManagerBaseEbRNS_17MachineModuleInfoE'/>
<def f='llvm/llvm/lib/CodeGen/TargetPassConfig.cpp' l='860' ll='984' type='void llvm::TargetPassConfig::addMachinePasses()'/>
<doc f='llvm/llvm/lib/CodeGen/TargetPassConfig.cpp' l='842'>/// Add the complete set of target-independent postISel code generator passes.
///
/// This can be read as the standard order of major LLVM CodeGen stages. Stages
/// with nontrivial configuration or multiple passes are broken out below in
/// add%Stage routines.
///
/// Any TargetPassConfig::addXX routine may be overriden by the Target. The
/// addPre/Post methods with empty header implementations allow injecting
/// target-specific fixups just before or after major stages. Additionally,
/// targets have the flexibility to change pass order within a stage by
/// overriding default implementation of add%Stage routines below. Each
/// technique has maintainability tradeoffs because alternate pass orders are
/// not well supported. addPre/Post works better if the target pass is easily
/// tied to a common pass. But if it has subtle dependencies on multiple passes,
/// the target should override the stage instead.
///
/// TODO: We could use a single addPre/Post(ID) hook to allow pass injection
/// before/after any target-independent pass. But it&apos;s currently overkill.</doc>
