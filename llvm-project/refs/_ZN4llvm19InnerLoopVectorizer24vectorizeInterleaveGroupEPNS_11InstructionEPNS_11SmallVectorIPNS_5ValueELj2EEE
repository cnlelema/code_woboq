<dec f='llvm/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp' l='450' type='void llvm::InnerLoopVectorizer::vectorizeInterleaveGroup(llvm::Instruction * Instr, VectorParts * BlockInMask = nullptr)'/>
<def f='llvm/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp' l='2027' ll='2212' type='void llvm::InnerLoopVectorizer::vectorizeInterleaveGroup(llvm::Instruction * Instr, VectorParts * BlockInMask = nullptr)'/>
<use f='llvm/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp' l='2227' u='c' c='_ZN4llvm19InnerLoopVectorizer26vectorizeMemoryInstructionEPNS_11InstructionEPNS_11SmallVectorIPNS_5ValueELj2EEE'/>
<use f='llvm/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp' l='7067' u='c' c='_ZN4llvm18VPInterleaveRecipe7executeERNS_16VPTransformStateE'/>
<use f='llvm/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp' l='7074' u='c' c='_ZN4llvm18VPInterleaveRecipe7executeERNS_16VPTransformStateE'/>
<doc f='llvm/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp' l='448'>/// Try to vectorize the interleaved access group that \p Instr belongs to,
  /// optionally masking the vector operations if \p BlockInMask is non-null.</doc>
<doc f='llvm/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp' l='1999'>// Try to vectorize the interleave group that \p Instr belongs to.
//
// E.g. Translate following interleaved load group (factor = 3):
//   for (i = 0; i &lt; N; i+=3) {
//     R = Pic[i];             // Member of index 0
//     G = Pic[i+1];           // Member of index 1
//     B = Pic[i+2];           // Member of index 2
//     ... // do something to R, G, B
//   }
// To:
//   %wide.vec = load &lt;12 x i32&gt;                       ; Read 4 tuples of R,G,B
//   %R.vec = shuffle %wide.vec, undef, &lt;0, 3, 6, 9&gt;   ; R elements
//   %G.vec = shuffle %wide.vec, undef, &lt;1, 4, 7, 10&gt;  ; G elements
//   %B.vec = shuffle %wide.vec, undef, &lt;2, 5, 8, 11&gt;  ; B elements
//
// Or translate following interleaved store group (factor = 3):
//   for (i = 0; i &lt; N; i+=3) {
//     ... do something to R, G, B
//     Pic[i]   = R;           // Member of index 0
//     Pic[i+1] = G;           // Member of index 1
//     Pic[i+2] = B;           // Member of index 2
//   }
// To:
//   %R_G.vec = shuffle %R.vec, %G.vec, &lt;0, 1, 2, ..., 7&gt;
//   %B_U.vec = shuffle %B.vec, undef, &lt;0, 1, 2, 3, u, u, u, u&gt;
//   %interleaved.vec = shuffle %R_G.vec, %B_U.vec,
//        &lt;0, 4, 8, 1, 5, 9, 2, 6, 10, 3, 7, 11&gt;    ; Interleave R,G,B elements
//   store &lt;12 x i32&gt; %interleaved.vec              ; Write 4 tuples of R,G,B</doc>
