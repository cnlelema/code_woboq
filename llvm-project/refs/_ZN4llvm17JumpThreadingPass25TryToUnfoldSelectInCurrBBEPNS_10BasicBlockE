<dec f='llvm/llvm/include/llvm/Transforms/Scalar/JumpThreading.h' l='146' type='bool llvm::JumpThreadingPass::TryToUnfoldSelectInCurrBB(llvm::BasicBlock * BB)'/>
<use f='llvm/llvm/lib/Transforms/Scalar/JumpThreading.cpp' l='1032' u='c' c='_ZN4llvm17JumpThreadingPass12ProcessBlockEPNS_10BasicBlockE'/>
<def f='llvm/llvm/lib/Transforms/Scalar/JumpThreading.cpp' l='2540' ll='2609' type='bool llvm::JumpThreadingPass::TryToUnfoldSelectInCurrBB(llvm::BasicBlock * BB)'/>
<doc f='llvm/llvm/lib/Transforms/Scalar/JumpThreading.cpp' l='2520'>/// TryToUnfoldSelectInCurrBB - Look for PHI/Select or PHI/CMP/Select in the
/// same BB in the form
/// bb:
///   %p = phi [false, %bb1], [true, %bb2], [false, %bb3], [true, %bb4], ...
///   %s = select %p, trueval, falseval
///
/// or
///
/// bb:
///   %p = phi [0, %bb1], [1, %bb2], [0, %bb3], [1, %bb4], ...
///   %c = cmp %p, 0
///   %s = select %c, trueval, falseval
///
/// And expand the select into a branch structure. This later enables
/// jump-threading over bb in this pass.
///
/// Using the similar approach of SimplifyCFG::FoldCondBranchOnPHI(), unfold
/// select if the associated PHI has at least one constant.  If the unfolded
/// select is not jump-threaded, it will be folded again in the later
/// optimizations.</doc>
