<dec f='llvm/llvm/include/llvm/Analysis/MemorySSAUpdater.h' l='202' type='llvm::MemoryAccess * llvm::MemorySSAUpdater::createMemoryAccessInBB(llvm::Instruction * I, llvm::MemoryAccess * Definition, const llvm::BasicBlock * BB, MemorySSA::InsertionPlace Point)'/>
<doc f='llvm/llvm/include/llvm/Analysis/MemorySSAUpdater.h' l='183'>// The below are utility functions. Other than creation of accesses to pass
  // to insertDef, and removeAccess to remove accesses, you should generally
  // not attempt to update memoryssa yourself. It is very non-trivial to get
  // the edge cases right, and the above calls already operate in near-optimal
  // time bounds.

  /// Create a MemoryAccess in MemorySSA at a specified point in a block,
  /// with a specified clobbering definition.
  ///
  /// Returns the new MemoryAccess.
  /// This should be called when a memory instruction is created that is being
  /// used to replace an existing memory instruction. It will *not* create PHI
  /// nodes, or verify the clobbering definition. The insertion place is used
  /// solely to determine where in the memoryssa access lists the instruction
  /// will be placed. The caller is expected to keep ordering the same as
  /// instructions.
  /// It will return the new MemoryAccess.
  /// Note: If a MemoryAccess already exists for I, this function will make it
  /// inaccessible and it *must* have removeMemoryAccess called on it.</doc>
<def f='llvm/llvm/lib/Analysis/MemorySSAUpdater.cpp' l='1306' ll='1312' type='llvm::MemoryAccess * llvm::MemorySSAUpdater::createMemoryAccessInBB(llvm::Instruction * I, llvm::MemoryAccess * Definition, const llvm::BasicBlock * BB, MemorySSA::InsertionPlace Point)'/>
<use f='llvm/llvm/lib/Transforms/Scalar/LICM.cpp' l='1373' u='c' c='_ZL27CloneInstructionInExitBlockRN4llvm11InstructionERNS_10BasicBlockERNS_7PHINodeEPKNS_8LoopInfoEPKNS_14LoopSafetyInfoEPNS_16MemorySSAUpdaterE'/>
<use f='llvm/llvm/lib/Transforms/Scalar/LICM.cpp' l='1787' u='c' c='_ZN12_GLOBAL__N_112LoopPromoter34doExtraRewritesBeforeFinalDeletionEv'/>
<use f='llvm/llvm/lib/Transforms/Scalar/LICM.cpp' l='2104' u='c' c='_ZN4llvm28promoteLoopAccessesToScalarsERKNS_14SmallSetVectorIPNS_5ValueELj8EEERNS_15SmallVectorImplIPNS_10BasicBlockEEERNS6_IPNS_11InstructionEEERNS6_2137798'/>
<use f='llvm/llvm/unittests/Analysis/MemorySSATest.cpp' l='102' u='c' c='_ZN30MemorySSATest_CreateALoad_Test8TestBodyEv'/>
<use f='llvm/llvm/unittests/Analysis/MemorySSATest.cpp' l='135' u='c' c='_ZN45MemorySSATest_CreateLoadsAndStoreUpdater_Test8TestBodyEv'/>
<use f='llvm/llvm/unittests/Analysis/MemorySSATest.cpp' l='148' u='c' c='_ZN45MemorySSATest_CreateLoadsAndStoreUpdater_Test8TestBodyEv'/>
<use f='llvm/llvm/unittests/Analysis/MemorySSATest.cpp' l='159' u='c' c='_ZN45MemorySSATest_CreateLoadsAndStoreUpdater_Test8TestBodyEv'/>
<use f='llvm/llvm/unittests/Analysis/MemorySSATest.cpp' l='172' u='c' c='_ZN45MemorySSATest_CreateLoadsAndStoreUpdater_Test8TestBodyEv'/>
<use f='llvm/llvm/unittests/Analysis/MemorySSATest.cpp' l='184' u='c' c='_ZN45MemorySSATest_CreateLoadsAndStoreUpdater_Test8TestBodyEv'/>
<use f='llvm/llvm/unittests/Analysis/MemorySSATest.cpp' l='226' u='c' c='_ZN37MemorySSATest_CreateALoadUpdater_Test8TestBodyEv'/>
<use f='llvm/llvm/unittests/Analysis/MemorySSATest.cpp' l='238' u='c' c='_ZN37MemorySSATest_CreateALoadUpdater_Test8TestBodyEv'/>
<use f='llvm/llvm/unittests/Analysis/MemorySSATest.cpp' l='283' u='c' c='_ZN27MemorySSATest_SinkLoad_Test8TestBodyEv'/>
<use f='llvm/llvm/unittests/Analysis/MemorySSATest.cpp' l='817' u='c' c='_ZN30MemorySSATest_WalkerReopt_Test8TestBodyEv'/>
<use f='llvm/llvm/unittests/Analysis/MemorySSATest.cpp' l='906' u='c' c='_ZN30MemorySSATest_Irreducible_Test8TestBodyEv'/>
