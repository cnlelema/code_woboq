<def f='llvm/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h' l='313' type='bool llvm::LoopVectorizationLegality::isMaskRequired(const llvm::Instruction * I)'/>
<doc f='llvm/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h' l='311'>/// Returns true if vector representation of the instruction \p I
  /// requires mask.</doc>
<use f='llvm/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp' l='1132' u='c' c='_ZN4llvm26LoopVectorizationCostModel16isPredicatedInstEPNS_11InstructionE'/>
<use f='llvm/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp' l='4382' u='c' c='_ZN4llvm26LoopVectorizationCostModel23isScalarWithPredicationEPNS_11InstructionEj'/>
<use f='llvm/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp' l='4419' u='c' c='_ZN4llvm26LoopVectorizationCostModel29interleavedAccessCanBeWidenedEPNS_11InstructionEj'/>
<use f='llvm/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp' l='5535' u='c' c='_ZN4llvm26LoopVectorizationCostModel23getConsecutiveMemOpCostEPNS_11InstructionEj'/>
<use f='llvm/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp' l='5576' u='c' c='_ZN4llvm26LoopVectorizationCostModel20getGatherScatterCostEPNS_11InstructionEj'/>
<use f='llvm/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp' l='5605' u='c' c='_ZN4llvm26LoopVectorizationCostModel22getInterleaveGroupCostEPNS_11InstructionEj'/>
<use f='llvm/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp' l='5609' u='c' c='_ZN4llvm26LoopVectorizationCostModel22getInterleaveGroupCostEPNS_11InstructionEj'/>
<use f='llvm/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp' l='6488' u='c' c='_ZN4llvm15VPRecipeBuilder21tryToInterleaveMemoryEPNS_11InstructionERNS_7VFRangeERSt10unique_ptrINS_5VPlanESt14default_deleteIS6_EE'/>
<use f='llvm/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp' l='6519' u='c' c='_ZN4llvm15VPRecipeBuilder16tryToWidenMemoryEPNS_11InstructionERNS_7VFRangeERSt10unique_ptrINS_5VPlanESt14default_deleteIS6_EE'/>
