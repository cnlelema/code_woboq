<dec f='llvm/llvm/include/llvm/Analysis/ScalarEvolution.h' l='716' type='unsigned int llvm::ScalarEvolution::getSmallConstantTripCount(const llvm::Loop * L)'/>
<doc f='llvm/llvm/include/llvm/Analysis/ScalarEvolution.h' l='711'>/// Returns the maximum trip count of the loop if it is a single-exit
  /// loop and we can compute a small maximum for that loop.
  ///
  /// Implemented in terms of the \c getSmallConstantTripCount overload with
  /// the single exiting block passed to it. See that routine for details.</doc>
<def f='llvm/llvm/lib/Analysis/ScalarEvolution.cpp' l='6498' ll='6504' type='unsigned int llvm::ScalarEvolution::getSmallConstantTripCount(const llvm::Loop * L)'/>
<use f='llvm/llvm/lib/Target/Hexagon/HexagonTargetTransformInfo.cpp' l='81' u='c' c='_ZN4llvm14HexagonTTIImpl23getUnrollingPreferencesEPNS_4LoopERNS_15ScalarEvolutionERNS_19TargetTransformInfo20UnrollingPreferencesE'/>
<use f='llvm/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp' l='501' u='c' c='_ZN4llvm10PPCTTIImpl24isHardwareLoopProfitableEPNS_4LoopERNS_15ScalarEvolutionERNS_15AssumptionCacheEPNS_17TargetLibraryInfoERNS_19TargetTransformInfo16HardwareLoopInfoE'/>
<use f='llvm/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp' l='4655' u='c' c='_ZN4llvm26LoopVectorizationCostModel12computeMaxVFEb'/>
<use f='llvm/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp' l='4950' u='c' c='_ZN4llvm26LoopVectorizationCostModel21selectInterleaveCountEbjj'/>
