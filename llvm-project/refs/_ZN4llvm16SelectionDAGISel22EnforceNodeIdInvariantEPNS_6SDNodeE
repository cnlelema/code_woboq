<dec f='llvm/llvm/include/llvm/CodeGen/SelectionDAGISel.h' l='117' type='static void llvm::SelectionDAGISel::EnforceNodeIdInvariant(llvm::SDNode * N)'/>
<use f='llvm/llvm/include/llvm/CodeGen/SelectionDAGISel.h' l='211' u='c' c='_ZN4llvm16SelectionDAGISel11ReplaceUsesENS_7SDValueES1_'/>
<use f='llvm/llvm/include/llvm/CodeGen/SelectionDAGISel.h' l='219' u='c' c='_ZN4llvm16SelectionDAGISel11ReplaceUsesEPKNS_7SDValueES3_j'/>
<use f='llvm/llvm/include/llvm/CodeGen/SelectionDAGISel.h' l='226' u='c' c='_ZN4llvm16SelectionDAGISel11ReplaceUsesEPNS_6SDNodeES2_'/>
<use f='llvm/llvm/include/llvm/CodeGen/SelectionDAGISel.h' l='232' u='c' c='_ZN4llvm16SelectionDAGISel11ReplaceNodeEPNS_6SDNodeES2_'/>
<def f='llvm/llvm/lib/CodeGen/SelectionDAG/SelectionDAGISel.cpp' l='1034' ll='1048' type='static void llvm::SelectionDAGISel::EnforceNodeIdInvariant(llvm::SDNode * Node)'/>
<use f='llvm/llvm/lib/CodeGen/SelectionDAG/SelectionDAGISel.cpp' l='2458' u='c' c='_ZN4llvm16SelectionDAGISel9MorphNodeEPNS_6SDNodeEjNS_8SDVTListENS_8ArrayRefINS_7SDValueEEEj'/>
<doc f='llvm/llvm/lib/CodeGen/SelectionDAG/SelectionDAGISel.cpp' l='1014'>// This function is used to enforce the topological node id property
// property leveraged during Instruction selection. Before selection all
// nodes are given a non-negative id such that all nodes have a larger id than
// their operands. As this holds transitively we can prune checks that a node N
// is a predecessor of M another by not recursively checking through M&apos;s
// operands if N&apos;s ID is larger than M&apos;s ID. This is significantly improves
// performance of for various legality checks (e.g. IsLegalToFold /
// UpdateChains).

// However, when we fuse multiple nodes into a single node
// during selection we may induce a predecessor relationship between inputs and
// outputs of distinct nodes being merged violating the topological property.
// Should a fused node have a successor which has yet to be selected, our
// legality checks would be incorrect. To avoid this we mark all unselected
// sucessor nodes, i.e. id != -1 as invalid for pruning by bit-negating (x =&gt;
// (-(x+1))) the ids and modify our pruning check to ignore negative Ids of M.
// We use bit-negation to more clearly enforce that node id -1 can only be
// achieved by selected nodes). As the conversion is reversable the original Id,
// topological pruning can still be leveraged when looking for unselected nodes.
// This method is call internally in all ISel replacement calls.</doc>
