<def f='llvm/llvm/include/llvm/ADT/IntervalMap.h' l='490' ll='540'/>
<size>8</size>
<doc f='llvm/llvm/include/llvm/ADT/IntervalMap.h' l='469'>//===----------------------------------------------------------------------===//
//---                     IntervalMapImpl::NodeRef                         ---//
//===----------------------------------------------------------------------===//
//
// B+-tree nodes can be leaves or branches, so we need a polymorphic node
// pointer that can point to both kinds.
//
// All nodes are cache line aligned and the low 6 bits of a node pointer are
// always 0. These bits are used to store the number of elements in the
// referenced node. Besides saving space, placing node sizes in the parents
// allow tree balancing algorithms to run without faulting cache lines for nodes
// that may not need to be modified.
//
// A NodeRef doesn&apos;t know whether it references a leaf node or a branch node.
// It is the responsibility of the caller to use the correct types.
//
// Nodes are never supposed to be empty, and it is invalid to store a node size
// of 0 in a NodeRef. The valid range of sizes is 1-64.
//
//===----------------------------------------------------------------------===//</doc>
<mbr r='llvm::IntervalMapImpl::NodeRef::pip' o='0' t='PointerIntPair&lt;void *, Log2CacheLine, unsigned int, llvm::IntervalMapImpl::NodeRef::CacheAlignedPointerTraits&gt;'/>
<fun r='_ZN4llvm15IntervalMapImpl7NodeRefC1Ev'/>
<fun r='_ZNK4llvm15IntervalMapImpl7NodeRefcvbEv'/>
<fun r='_ZN4llvm15IntervalMapImpl7NodeRefC1EPT_j'/>
<fun r='_ZNK4llvm15IntervalMapImpl7NodeRef4sizeEv'/>
<fun r='_ZN4llvm15IntervalMapImpl7NodeRef7setSizeEj'/>
<fun r='_ZNK4llvm15IntervalMapImpl7NodeRef7subtreeEj'/>
<fun r='_ZNK4llvm15IntervalMapImpl7NodeRef3getEv'/>
<fun r='_ZNK4llvm15IntervalMapImpl7NodeRefeqERKS1_'/>
<fun r='_ZNK4llvm15IntervalMapImpl7NodeRefneERKS1_'/>
