<dec f='llvm/llvm/include/llvm/ADT/IntervalMap.h' l='411' type='IdxPair llvm::IntervalMapImpl::distribute(unsigned int Nodes, unsigned int Elements, unsigned int Capacity, const unsigned int * CurSize, unsigned int * NewSize, unsigned int Position, bool Grow)'/>
<doc f='llvm/llvm/include/llvm/ADT/IntervalMap.h' l='378'>/// IntervalMapImpl::distribute - Compute a new distribution of node elements
/// after an overflow or underflow. Reserve space for a new element at Position,
/// and compute the node that will hold Position after redistributing node
/// elements.
///
/// It is required that
///
///   Elements == sum(CurSize), and
///   Elements + Grow &lt;= Nodes * Capacity.
///
/// NewSize[] will be filled in such that:
///
///   sum(NewSize) == Elements, and
///   NewSize[i] &lt;= Capacity.
///
/// The returned index is the node where Position will go, so:
///
///   sum(NewSize[0..idx-1]) &lt;= Position
///   sum(NewSize[0..idx])   &gt;= Position
///
/// The last equality, sum(NewSize[0..idx]) == Position, can only happen when
/// Grow is set and NewSize[idx] == Capacity-1. The index points to the node
/// before the one holding the Position&apos;th element where there is room for an
/// insertion.
///
/// @param Nodes    The number of nodes.
/// @param Elements Total elements in all nodes.
/// @param Capacity The capacity of each node.
/// @param CurSize  Array[Nodes] of current node sizes, or NULL.
/// @param NewSize  Array[Nodes] to receive the new node sizes.
/// @param Position Insert position.
/// @param Grow     Reserve space for a new element at Position.
/// @return         (node, offset) for Position.</doc>
<def f='llvm/llvm/lib/Support/IntervalMap.cpp' l='119' ll='156' type='IdxPair llvm::IntervalMapImpl::distribute(unsigned int Nodes, unsigned int Elements, unsigned int Capacity, const unsigned int * CurSize, unsigned int * NewSize, unsigned int Position, bool Grow)'/>
