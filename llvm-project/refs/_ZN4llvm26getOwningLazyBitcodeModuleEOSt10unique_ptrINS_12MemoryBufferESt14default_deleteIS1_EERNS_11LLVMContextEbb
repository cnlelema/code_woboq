<dec f='llvm/llvm/include/llvm/Bitcode/BitcodeReader.h' l='147' type='Expected&lt;std::unique_ptr&lt;Module&gt; &gt; llvm::getOwningLazyBitcodeModule(std::unique_ptr&lt;MemoryBuffer&gt; &amp;&amp; Buffer, llvm::LLVMContext &amp; Context, bool ShouldLazyLoadMetadata = false, bool IsImporting = false)'/>
<doc f='llvm/llvm/include/llvm/Bitcode/BitcodeReader.h' l='143'>/// Like getLazyBitcodeModule, except that the module takes ownership of
  /// the memory buffer if successful. If successful, this moves Buffer. On
  /// error, this *does not* move Buffer. If IsImporting is true, this module is
  /// being parsed for ThinLTO importing into another module.</doc>
<use f='llvm/llvm/lib/Bitcode/Reader/BitReader.cpp' l='84' u='c' c='LLVMGetBitcodeModuleInContext'/>
<use f='llvm/llvm/lib/Bitcode/Reader/BitReader.cpp' l='112' u='c' c='LLVMGetBitcodeModuleInContext2'/>
<def f='llvm/llvm/lib/Bitcode/Reader/BitcodeReader.cpp' l='6193' ll='6201' type='Expected&lt;std::unique_ptr&lt;Module&gt; &gt; llvm::getOwningLazyBitcodeModule(std::unique_ptr&lt;MemoryBuffer&gt; &amp;&amp; Buffer, llvm::LLVMContext &amp; Context, bool ShouldLazyLoadMetadata = false, bool IsImporting = false)'/>
<use f='llvm/llvm/lib/IRReader/IRReader.cpp' l='37' u='c' c='_ZN4llvm15getLazyIRModuleESt10unique_ptrINS_12MemoryBufferESt14default_deleteIS1_EERNS_12SMDiagnosticERNS_11LLVMContextEb'/>
