<dec f='llvm/clang/include/clang/Parse/Parser.h' l='786' type='bool clang::Parser::TryAnnotateTypeOrScopeToken()'/>
<doc f='llvm/clang/include/clang/Parse/Parser.h' l='784'>// If NeedType is true, then TryAnnotateTypeOrScopeToken will try harder to
  // find a type name by attempting typo correction.</doc>
<use f='llvm/clang/lib/Parse/ParseDecl.cpp' l='3849' u='c' c='_ZN5clang6Parser26ParseDeclarationSpecifiersERNS_8DeclSpecERKNS0_18ParsedTemplateInfoENS_15AccessSpecifierENS0_15DeclSpecContextEPNS0_18LateParsedAttrListE'/>
<use f='llvm/clang/lib/Parse/ParseDecl.cpp' l='4787' u='c' c='_ZN5clang6Parser24isTypeSpecifierQualifierEv'/>
<use f='llvm/clang/lib/Parse/ParseDecl.cpp' l='4798' u='c' c='_ZN5clang6Parser24isTypeSpecifierQualifierEv'/>
<use f='llvm/clang/lib/Parse/ParseDecl.cpp' l='4926' u='c' c='_ZN5clang6Parser22isDeclarationSpecifierEb'/>
<use f='llvm/clang/lib/Parse/ParseDecl.cpp' l='4949' u='c' c='_ZN5clang6Parser22isDeclarationSpecifierEb'/>
<use f='llvm/clang/lib/Parse/ParseDecl.cpp' l='6411' u='c' c='_ZN5clang6Parser34isFunctionDeclaratorIdentifierListEv'/>
<use f='llvm/clang/lib/Parse/ParseExpr.cpp' l='853' u='c' c='_ZN5clang6Parser19ParseCastExpressionEbbRbNS0_13TypeCastStateEb'/>
<use f='llvm/clang/lib/Parse/ParseExpr.cpp' l='953' u='c' c='_ZN5clang6Parser19ParseCastExpressionEbbRbNS0_13TypeCastStateEb'/>
<use f='llvm/clang/lib/Parse/ParseExpr.cpp' l='1297' u='c' c='_ZN5clang6Parser19ParseCastExpressionEbbRbNS0_13TypeCastStateEb'/>
<use f='llvm/clang/lib/Parse/ParseExpr.cpp' l='1327' u='c' c='_ZN5clang6Parser19ParseCastExpressionEbbRbNS0_13TypeCastStateEb'/>
<use f='llvm/clang/lib/Parse/ParseExpr.cpp' l='1376' u='c' c='_ZN5clang6Parser19ParseCastExpressionEbbRbNS0_13TypeCastStateEb'/>
<use f='llvm/clang/lib/Parse/ParseObjc.cpp' l='2902' u='c' c='_ZN5clang6Parser26ParseObjCXXMessageReceiverERbRPv'/>
<use f='llvm/clang/lib/Parse/ParseObjc.cpp' l='2996' u='c' c='_ZN5clang6Parser43isStartOfObjCClassMessageMissingOpenBracketEv'/>
<use f='llvm/clang/lib/Parse/ParseTentative.cpp' l='1343' u='c' c='_ZN5clang6Parser25isCXXDeclarationSpecifierENS0_8TPResultEPb'/>
<use f='llvm/clang/lib/Parse/ParseTentative.cpp' l='1364' u='c' c='_ZN5clang6Parser25isCXXDeclarationSpecifierENS0_8TPResultEPb'/>
<use f='llvm/clang/lib/Parse/ParseTentative.cpp' l='1380' u='c' c='_ZN5clang6Parser25isCXXDeclarationSpecifierENS0_8TPResultEPb'/>
<use f='llvm/clang/lib/Parse/ParseTentative.cpp' l='1395' u='c' c='_ZN5clang6Parser25isCXXDeclarationSpecifierENS0_8TPResultEPb'/>
<use f='llvm/clang/lib/Parse/ParseTentative.cpp' l='1525' u='c' c='_ZN5clang6Parser25isCXXDeclarationSpecifierENS0_8TPResultEPb'/>
<use f='llvm/clang/lib/Parse/ParseTentative.cpp' l='1578' u='c' c='_ZN5clang6Parser25isCXXDeclarationSpecifierENS0_8TPResultEPb'/>
<def f='llvm/clang/lib/Parse/Parser.cpp' l='1749' ll='1859' type='bool clang::Parser::TryAnnotateTypeOrScopeToken()'/>
<use f='llvm/clang/lib/Parse/Parser.cpp' l='1766' u='c' c='_ZN5clang6Parser27TryAnnotateTypeOrScopeTokenEv'/>
<use f='llvm/clang/lib/Parse/Parser.cpp' l='1791' u='c' c='_ZN5clang6Parser27TryAnnotateTypeOrScopeTokenEv'/>
<doc f='llvm/clang/lib/Parse/Parser.cpp' l='1727'>/// TryAnnotateTypeOrScopeToken - If the current token position is on a
/// typename (possibly qualified in C++) or a C++ scope specifier not followed
/// by a typename, TryAnnotateTypeOrScopeToken will replace one or more tokens
/// with a single annotation token representing the typename or C++ scope
/// respectively.
/// This simplifies handling of C++ scope specifiers and allows efficient
/// backtracking without the need to re-parse and resolve nested-names and
/// typenames.
/// It will mainly be called when we expect to treat identifiers as typenames
/// (if they are typenames). For example, in C we do not expect identifiers
/// inside expressions to be treated as typenames so it will not be called
/// for expressions in C.
/// The benefit for C/ObjC is that a typename will be annotated and
/// Actions.getTypeName will not be needed to be called again (e.g. getTypeName
/// will not be called twice, once to check whether we have a declaration
/// specifier, and another one to get the actual type inside
/// ParseDeclarationSpecifiers).
///
/// This returns true if an error occurred.
///
/// Note that this routine emits an error if you call it with ::new or ::delete
/// as the current tokens, so only call it in contexts where these are invalid.</doc>
