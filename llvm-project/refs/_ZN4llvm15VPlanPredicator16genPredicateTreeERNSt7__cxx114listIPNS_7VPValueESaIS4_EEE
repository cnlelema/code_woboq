<dec f='llvm/llvm/lib/Transforms/Vectorize/VPlanPredicator.h' l='54' type='llvm::VPValue * llvm::VPlanPredicator::genPredicateTree(std::list&lt;VPValue *&gt; &amp; Worklist)'/>
<doc f='llvm/llvm/lib/Transforms/Vectorize/VPlanPredicator.h' l='52'>/// Generate and return the result of ORing all the predicate VPValues in \p
  /// Worklist.</doc>
<def f='llvm/llvm/lib/Transforms/Vectorize/VPlanPredicator.cpp' l='85' ll='113' type='llvm::VPValue * llvm::VPlanPredicator::genPredicateTree(std::list&lt;VPValue *&gt; &amp; Worklist)'/>
<use f='llvm/llvm/lib/Transforms/Vectorize/VPlanPredicator.cpp' l='180' u='c' c='_ZN4llvm15VPlanPredicator27createOrPropagatePredicatesEPNS_11VPBlockBaseEPNS_13VPRegionBlockE'/>
<doc f='llvm/llvm/lib/Transforms/Vectorize/VPlanPredicator.cpp' l='65'>// Generate a tree of ORs for all IncomingPredicates in  WorkList.
// Note: This function destroys the original Worklist.
//
// P1 P2 P3 P4 P5
//  \ /   \ /  /
//  OR1   OR2 /
//    \    | /
//     \   +/-+
//      \  /  |
//       OR3  |
//         \  |
//          OR4 &lt;- Returns this
//           |
//
// The algorithm uses a worklist of predicates as its main data structure.
// We pop a pair of values from the front (e.g. P1 and P2), generate an OR
// (in this example OR1), and push it back. In this example the worklist
// contains {P3, P4, P5, OR1}.
// The process iterates until we have only one element in the Worklist (OR4).
// The last element is the root predicate which is returned.</doc>
