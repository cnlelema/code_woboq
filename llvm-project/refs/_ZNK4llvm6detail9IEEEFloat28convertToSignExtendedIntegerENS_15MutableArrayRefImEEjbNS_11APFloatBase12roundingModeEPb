<dec f='llvm/llvm/include/llvm/ADT/APFloat.h' l='507' type='llvm::APFloatBase::opStatus llvm::detail::IEEEFloat::convertToSignExtendedInteger(MutableArrayRef&lt;integerPart&gt; , unsigned int , bool , llvm::APFloatBase::roundingMode , bool * ) const'/>
<def f='llvm/llvm/lib/Support/APFloat.cpp' l='2036' ll='2138' type='IEEEFloat::opStatus llvm::detail::IEEEFloat::convertToSignExtendedInteger(MutableArrayRef&lt;integerPart&gt; parts, unsigned int width, bool isSigned, llvm::APFloatBase::roundingMode rounding_mode, bool * isExact) const'/>
<use f='llvm/llvm/lib/Support/APFloat.cpp' l='2155' u='c' c='_ZNK4llvm6detail9IEEEFloat16convertToIntegerENS_15MutableArrayRefImEEjbNS_11APFloatBase12roundingModeEPb'/>
<doc f='llvm/llvm/lib/Support/APFloat.cpp' l='2026'>/* Convert a floating point number to an integer according to the
   rounding mode.  If the rounded integer value is out of range this
   returns an invalid operation exception and the contents of the
   destination parts are unspecified.  If the rounded value is in
   range but the floating point number is not the exact integer, the C
   standard doesn&apos;t require an inexact exception to be raised.  IEEE
   854 does require it so we do that.

   Note that for conversions to integer type the C standard requires
   round-to-zero to always be used.  */</doc>
