<dec f='llvm/llvm/include/llvm/Analysis/DependenceAnalysis.h' l='508' type='void llvm::DependenceInfo::establishNestingLevels(const llvm::Instruction * Src, const llvm::Instruction * Dst)'/>
<def f='llvm/llvm/lib/Analysis/DependenceAnalysis.cpp' l='736' ll='761' type='void llvm::DependenceInfo::establishNestingLevels(const llvm::Instruction * Src, const llvm::Instruction * Dst)'/>
<use f='llvm/llvm/lib/Analysis/DependenceAnalysis.cpp' l='3443' u='c' c='_ZN4llvm14DependenceInfo7dependsEPNS_11InstructionES2_b'/>
<use f='llvm/llvm/lib/Analysis/DependenceAnalysis.cpp' l='3849' u='c' c='_ZN4llvm14DependenceInfo17getSplitIterationERKNS_10DependenceEj'/>
<doc f='llvm/llvm/lib/Analysis/DependenceAnalysis.cpp' l='686'>// Examines the loop nesting of the Src and Dst
// instructions and establishes their shared loops. Sets the variables
// CommonLevels, SrcLevels, and MaxLevels.
// The source and destination instructions needn&apos;t be contained in the same
// loop. The routine establishNestingLevels finds the level of most deeply
// nested loop that contains them both, CommonLevels. An instruction that&apos;s
// not contained in a loop is at level = 0. MaxLevels is equal to the level
// of the source plus the level of the destination, minus CommonLevels.
// This lets us allocate vectors MaxLevels in length, with room for every
// distinct loop referenced in both the source and destination subscripts.
// The variable SrcLevels is the nesting depth of the source instruction.
// It&apos;s used to help calculate distinct loops referenced by the destination.
// Here&apos;s the map from loops to levels:
//            0 - unused
//            1 - outermost common loop
//          ... - other common loops
// CommonLevels - innermost common loop
//          ... - loops containing Src but not Dst
//    SrcLevels - innermost loop containing Src but not Dst
//          ... - loops containing Dst but not Src
//    MaxLevels - innermost loops containing Dst but not Src
// Consider the follow code fragment:
//   for (a = ...) {
//     for (b = ...) {
//       for (c = ...) {
//         for (d = ...) {
//           A[] = ...;
//         }
//       }
//       for (e = ...) {
//         for (f = ...) {
//           for (g = ...) {
//             ... = A[];
//           }
//         }
//       }
//     }
//   }
// If we&apos;re looking at the possibility of a dependence between the store
// to A (the Src) and the load from A (the Dst), we&apos;ll note that they
// have 2 loops in common, so CommonLevels will equal 2 and the direction
// vector for Result will have 2 entries. SrcLevels = 4 and MaxLevels = 7.
// A map from loop names to loop numbers would look like
//     a - 1
//     b - 2 = CommonLevels
//     c - 3
//     d - 4 = SrcLevels
//     e - 5
//     f - 6
//     g - 7 = MaxLevels</doc>
<doc f='llvm/llvm/include/llvm/Analysis/DependenceAnalysis.h' l='458'>/// establishNestingLevels - Examines the loop nesting of the Src and Dst
    /// instructions and establishes their shared loops. Sets the variables
    /// CommonLevels, SrcLevels, and MaxLevels.
    /// The source and destination instructions needn&apos;t be contained in the same
    /// loop. The routine establishNestingLevels finds the level of most deeply
    /// nested loop that contains them both, CommonLevels. An instruction that&apos;s
    /// not contained in a loop is at level = 0. MaxLevels is equal to the level
    /// of the source plus the level of the destination, minus CommonLevels.
    /// This lets us allocate vectors MaxLevels in length, with room for every
    /// distinct loop referenced in both the source and destination subscripts.
    /// The variable SrcLevels is the nesting depth of the source instruction.
    /// It&apos;s used to help calculate distinct loops referenced by the destination.
    /// Here&apos;s the map from loops to levels:
    ///            0 - unused
    ///            1 - outermost common loop
    ///          ... - other common loops
    /// CommonLevels - innermost common loop
    ///          ... - loops containing Src but not Dst
    ///    SrcLevels - innermost loop containing Src but not Dst
    ///          ... - loops containing Dst but not Src
    ///    MaxLevels - innermost loop containing Dst but not Src
    /// Consider the follow code fragment:
    ///    for (a = ...) {
    ///      for (b = ...) {
    ///        for (c = ...) {
    ///          for (d = ...) {
    ///            A[] = ...;
    ///          }
    ///        }
    ///        for (e = ...) {
    ///          for (f = ...) {
    ///            for (g = ...) {
    ///              ... = A[];
    ///            }
    ///          }
    ///        }
    ///      }
    ///    }
    /// If we&apos;re looking at the possibility of a dependence between the store
    /// to A (the Src) and the load from A (the Dst), we&apos;ll note that they
    /// have 2 loops in common, so CommonLevels will equal 2 and the direction
    /// vector for Result will have 2 entries. SrcLevels = 4 and MaxLevels = 7.
    /// A map from loop names to level indices would look like
    ///     a - 1
    ///     b - 2 = CommonLevels
    ///     c - 3
    ///     d - 4 = SrcLevels
    ///     e - 5
    ///     f - 6
    ///     g - 7 = MaxLevels</doc>
