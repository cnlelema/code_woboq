<dec f='llvm/llvm/include/llvm/Analysis/MemorySSAUpdater.h' l='118' type='void llvm::MemorySSAUpdater::updateForClonedLoop(const llvm::LoopBlocksRPO &amp; LoopBlocks, ArrayRef&lt;llvm::BasicBlock *&gt; ExitBlocks, const ValueToValueMapTy &amp; VM, bool IgnoreIncomingWithNoClones = false)'/>
<doc f='llvm/llvm/include/llvm/Analysis/MemorySSAUpdater.h' l='114'>/// Update MemorySSA after a loop was cloned, given the blocks in RPO order,
  /// the exit blocks and a 1:1 mapping of all blocks and instructions
  /// cloned. This involves duplicating all defs and uses in the cloned blocks
  /// Updating phi nodes in exit block successors is done separately.</doc>
<def f='llvm/llvm/lib/Analysis/MemorySSAUpdater.cpp' l='565' ll='639' type='void llvm::MemorySSAUpdater::updateForClonedLoop(const llvm::LoopBlocksRPO &amp; LoopBlocks, ArrayRef&lt;llvm::BasicBlock *&gt; ExitBlocks, const ValueToValueMapTy &amp; VMap, bool IgnoreIncomingWithNoClones = false)'/>
<use f='llvm/llvm/lib/Transforms/Scalar/LoopUnswitch.cpp' l='1353' u='c' c='_ZN12_GLOBAL__N_112LoopUnswitch27UnswitchNontrivialConditionEPN4llvm5ValueEPNS1_8ConstantEPNS1_4LoopEPNS1_11InstructionE'/>
<use f='llvm/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp' l='2069' u='c' c='_ZL28unswitchNontrivialInvariantsRN4llvm4LoopERNS_11InstructionENS_8ArrayRefIPNS_5ValueEEERNS_15SmallVectorImplIPNS_10BasicBlockEEERNS_13DominatorTree1049984'/>
