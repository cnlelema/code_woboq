<dec f='llvm/llvm/lib/Target/ARM/ARMISelLowering.h' l='670' type='llvm::SDValue llvm::ARMTargetLowering::LowerGlobalTLSAddressDarwin(llvm::SDValue Op, llvm::SelectionDAG &amp; DAG) const'/>
<def f='llvm/llvm/lib/Target/ARM/ARMISelLowering.cpp' l='2836' ll='2879' type='llvm::SDValue llvm::ARMTargetLowering::LowerGlobalTLSAddressDarwin(llvm::SDValue Op, llvm::SelectionDAG &amp; DAG) const'/>
<use f='llvm/llvm/lib/Target/ARM/ARMISelLowering.cpp' l='3037' u='c' c='_ZNK4llvm17ARMTargetLowering21LowerGlobalTLSAddressENS_7SDValueERNS_12SelectionDAGE'/>
<doc f='llvm/llvm/lib/Target/ARM/ARMISelLowering.cpp' l='2812'>/// Convert a TLS address reference into the correct sequence of loads
/// and calls to compute the variable&apos;s address for Darwin, and return an
/// SDValue containing the final node.

/// Darwin only has one TLS scheme which must be capable of dealing with the
/// fully general situation, in the worst case. This means:
///     + &quot;extern __thread&quot; declaration.
///     + Defined in a possibly unknown dynamic library.
///
/// The general system is that each __thread variable has a [3 x i32] descriptor
/// which contains information used by the runtime to calculate the address. The
/// only part of this the compiler needs to know about is the first word, which
/// contains a function pointer that must be called with the address of the
/// entire descriptor in &quot;r0&quot;.
///
/// Since this descriptor may be in a different unit, in general access must
/// proceed along the usual ARM rules. A common sequence to produce is:
///
///     movw rT1, :lower16:_var$non_lazy_ptr
///     movt rT1, :upper16:_var$non_lazy_ptr
///     ldr r0, [rT1]
///     ldr rT2, [r0]
///     blx rT2
///     [...address now in r0...]</doc>
