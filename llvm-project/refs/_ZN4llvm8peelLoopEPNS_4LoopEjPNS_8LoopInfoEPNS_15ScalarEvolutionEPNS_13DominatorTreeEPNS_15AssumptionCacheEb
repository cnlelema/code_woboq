<dec f='llvm/llvm/include/llvm/Transforms/Utils/UnrollLoop.h' l='100' type='bool llvm::peelLoop(llvm::Loop * L, unsigned int PeelCount, llvm::LoopInfo * LI, llvm::ScalarEvolution * SE, llvm::DominatorTree * DT, llvm::AssumptionCache * AC, bool PreserveLCSSA)'/>
<use f='llvm/llvm/lib/Transforms/Utils/LoopUnroll.cpp' l='379' u='c' c='_ZN4llvm10UnrollLoopEPNS_4LoopENS_17UnrollLoopOptionsEPNS_8LoopInfoEPNS_15ScalarEvolutionEPNS_13DominatorTreeEPNS_15AssumptionCacheEPNS_25OptimizationRemarkEmitterEbPS1_'/>
<def f='llvm/llvm/lib/Transforms/Utils/LoopUnrollPeel.cpp' l='502' ll='679' type='bool llvm::peelLoop(llvm::Loop * L, unsigned int PeelCount, llvm::LoopInfo * LI, llvm::ScalarEvolution * SE, llvm::DominatorTree * DT, llvm::AssumptionCache * AC, bool PreserveLCSSA)'/>
<doc f='llvm/llvm/lib/Transforms/Utils/LoopUnrollPeel.cpp' l='493'>/// Peel off the first \p PeelCount iterations of loop \p L.
///
/// Note that this does not peel them off as a single straight-line block.
/// Rather, each iteration is peeled off separately, and needs to check the
/// exit condition.
/// For loops that dynamically execute \p PeelCount iterations or less
/// this provides a benefit, since the peeled off iterations, which account
/// for the bulk of dynamic execution, can be further simplified by scalar
/// optimizations.</doc>
