<def f='llvm/llvm/lib/Target/AMDGPU/AMDKernelCodeT.h' l='526' ll='649'/>
<size>256</size>
<doc f='llvm/llvm/lib/Target/AMDGPU/AMDKernelCodeT.h' l='316'>/// AMD Kernel Code Object (amd_kernel_code_t). GPU CP uses the AMD Kernel
/// Code Object to set up the hardware to execute the kernel dispatch.
///
/// Initial Kernel Register State.
///
/// Initial kernel register state will be set up by CP/SPI prior to the start
/// of execution of every wavefront. This is limited by the constraints of the
/// current hardware.
///
/// The order of the SGPR registers is defined, but the Finalizer can specify
/// which ones are actually setup in the amd_kernel_code_t object using the
/// enable_sgpr_* bit fields. The register numbers used for enabled registers
/// are dense starting at SGPR0: the first enabled register is SGPR0, the next
/// enabled register is SGPR1 etc.; disabled registers do not have an SGPR
/// number.
///
/// The initial SGPRs comprise up to 16 User SRGPs that are set up by CP and
/// apply to all waves of the grid. It is possible to specify more than 16 User
/// SGPRs using the enable_sgpr_* bit fields, in which case only the first 16
/// are actually initialized. These are then immediately followed by the System
/// SGPRs that are set up by ADC/SPI and can have different values for each wave
/// of the grid dispatch.
///
/// SGPR register initial state is defined as follows:
///
/// Private Segment Buffer (enable_sgpr_private_segment_buffer):
///   Number of User SGPR registers: 4. V# that can be used, together with
///   Scratch Wave Offset as an offset, to access the Private/Spill/Arg
///   segments using a segment address. It must be set as follows:
///     - Base address: of the scratch memory area used by the dispatch. It
///       does not include the scratch wave offset. It will be the per process
///       SH_HIDDEN_PRIVATE_BASE_VMID plus any offset from this dispatch (for
///       example there may be a per pipe offset, or per AQL Queue offset).
///     - Stride + data_format: Element Size * Index Stride (???)
///     - Cache swizzle: ???
///     - Swizzle enable: SH_STATIC_MEM_CONFIG.SWIZZLE_ENABLE (must be 1 for
///       scratch)
///     - Num records: Flat Scratch Work Item Size / Element Size (???)
///     - Dst_sel_*: ???
///     - Num_format: ???
///     - Element_size: SH_STATIC_MEM_CONFIG.ELEMENT_SIZE (will be DWORD, must
///       agree with amd_kernel_code_t.privateElementSize)
///     - Index_stride: SH_STATIC_MEM_CONFIG.INDEX_STRIDE (will be 64 as must
///       be number of wavefront lanes for scratch, must agree with
///       amd_kernel_code_t.wavefrontSize)
///     - Add tid enable: 1
///     - ATC: from SH_MEM_CONFIG.PRIVATE_ATC,
///     - Hash_enable: ???
///     - Heap: ???
///     - Mtype: from SH_STATIC_MEM_CONFIG.PRIVATE_MTYPE
///     - Type: 0 (a buffer) (???)
///
/// Dispatch Ptr (enable_sgpr_dispatch_ptr):
///   Number of User SGPR registers: 2. 64 bit address of AQL dispatch packet
///   for kernel actually executing.
///
/// Queue Ptr (enable_sgpr_queue_ptr):
///   Number of User SGPR registers: 2. 64 bit address of AmdQueue object for
///   AQL queue on which the dispatch packet was queued.
///
/// Kernarg Segment Ptr (enable_sgpr_kernarg_segment_ptr):
///   Number of User SGPR registers: 2. 64 bit address of Kernarg segment. This
///   is directly copied from the kernargPtr in the dispatch packet. Having CP
///   load it once avoids loading it at the beginning of every wavefront.
///
/// Dispatch Id (enable_sgpr_dispatch_id):
///   Number of User SGPR registers: 2. 64 bit Dispatch ID of the dispatch
///   packet being executed.
///
/// Flat Scratch Init (enable_sgpr_flat_scratch_init):
///   Number of User SGPR registers: 2. This is 2 SGPRs.
///
///   For CI/VI:
///     The first SGPR is a 32 bit byte offset from SH_MEM_HIDDEN_PRIVATE_BASE
///     to base of memory for scratch for this dispatch. This is the same offset
///     used in computing the Scratch Segment Buffer base address. The value of
///     Scratch Wave Offset must be added by the kernel code and moved to
///     SGPRn-4 for use as the FLAT SCRATCH BASE in flat memory instructions.
///
///     The second SGPR is 32 bit byte size of a single work-item&apos;s scratch
///     memory usage. This is directly loaded from the dispatch packet Private
///     Segment Byte Size and rounded up to a multiple of DWORD.
///
///     \todo [Does CP need to round this to &gt;4 byte alignment?]
///
///     The kernel code must move to SGPRn-3 for use as the FLAT SCRATCH SIZE in
///     flat memory instructions. Having CP load it once avoids loading it at
///     the beginning of every wavefront.
///
///   For PI:
///     This is the 64 bit base address of the scratch backing memory for
///     allocated by CP for this dispatch.
///
/// Private Segment Size (enable_sgpr_private_segment_size):
///   Number of User SGPR registers: 1. The 32 bit byte size of a single
///   work-item&apos;s scratch memory allocation. This is the value from the dispatch
///   packet. Private Segment Byte Size rounded up by CP to a multiple of DWORD.
///
///   \todo [Does CP need to round this to &gt;4 byte alignment?]
///
///   Having CP load it once avoids loading it at the beginning of every
///   wavefront.
///
///   \todo [This will not be used for CI/VI since it is the same value as
///   the second SGPR of Flat Scratch Init. However, it is need for PI which
///   changes meaning of Flat Scratchg Init..]
///
/// Grid Work-Group Count X (enable_sgpr_grid_workgroup_count_x):
///   Number of User SGPR registers: 1. 32 bit count of the number of
///   work-groups in the X dimension for the grid being executed. Computed from
///   the fields in the HsaDispatchPacket as
///   ((gridSize.x+workgroupSize.x-1)/workgroupSize.x).
///
/// Grid Work-Group Count Y (enable_sgpr_grid_workgroup_count_y):
///   Number of User SGPR registers: 1. 32 bit count of the number of
///   work-groups in the Y dimension for the grid being executed. Computed from
///   the fields in the HsaDispatchPacket as
///   ((gridSize.y+workgroupSize.y-1)/workgroupSize.y).
///
///   Only initialized if &lt;16 previous SGPRs initialized.
///
/// Grid Work-Group Count Z (enable_sgpr_grid_workgroup_count_z):
///   Number of User SGPR registers: 1. 32 bit count of the number of
///   work-groups in the Z dimension for the grid being executed. Computed
///   from the fields in the HsaDispatchPacket as
///   ((gridSize.z+workgroupSize.z-1)/workgroupSize.z).
///
///   Only initialized if &lt;16 previous SGPRs initialized.
///
/// Work-Group Id X (enable_sgpr_workgroup_id_x):
///   Number of System SGPR registers: 1. 32 bit work group id in X dimension
///   of grid for wavefront. Always present.
///
/// Work-Group Id Y (enable_sgpr_workgroup_id_y):
///   Number of System SGPR registers: 1. 32 bit work group id in Y dimension
///   of grid for wavefront.
///
/// Work-Group Id Z (enable_sgpr_workgroup_id_z):
///   Number of System SGPR registers: 1. 32 bit work group id in Z dimension
///   of grid for wavefront. If present then Work-group Id Y will also be
///   present
///
/// Work-Group Info (enable_sgpr_workgroup_info):
///   Number of System SGPR registers: 1. {first_wave, 14&apos;b0000,
///   ordered_append_term[10:0], threadgroup_size_in_waves[5:0]}
///
/// Private Segment Wave Byte Offset
/// (enable_sgpr_private_segment_wave_byte_offset):
///   Number of System SGPR registers: 1. 32 bit byte offset from base of
///   dispatch scratch base. Must be used as an offset with Private/Spill/Arg
///   segment address when using Scratch Segment Buffer. It must be added to
///   Flat Scratch Offset if setting up FLAT SCRATCH for flat addressing.
///
///
/// The order of the VGPR registers is defined, but the Finalizer can specify
/// which ones are actually setup in the amd_kernel_code_t object using the
/// enableVgpr*  bit fields. The register numbers used for enabled registers
/// are dense starting at VGPR0: the first enabled register is VGPR0, the next
/// enabled register is VGPR1 etc.; disabled registers do not have an VGPR
/// number.
///
/// VGPR register initial state is defined as follows:
///
/// Work-Item Id X (always initialized):
///   Number of registers: 1. 32 bit work item id in X dimension of work-group
///   for wavefront lane.
///
/// Work-Item Id X (enable_vgpr_workitem_id &gt; 0):
///   Number of registers: 1. 32 bit work item id in Y dimension of work-group
///   for wavefront lane.
///
/// Work-Item Id X (enable_vgpr_workitem_id &gt; 0):
///   Number of registers: 1. 32 bit work item id in Z dimension of work-group
///   for wavefront lane.
///
///
/// The setting of registers is being done by existing GPU hardware as follows:
///   1) SGPRs before the Work-Group Ids are set by CP using the 16 User Data
///      registers.
///   2) Work-group Id registers X, Y, Z are set by SPI which supports any
///      combination including none.
///   3) Scratch Wave Offset is also set by SPI which is why its value cannot
///      be added into the value Flat Scratch Offset which would avoid the
///      Finalizer generated prolog having to do the add.
///   4) The VGPRs are set by SPI which only supports specifying either (X),
///      (X, Y) or (X, Y, Z).
///
/// Flat Scratch Dispatch Offset and Flat Scratch Size are adjacent SGRRs so
/// they can be moved as a 64 bit value to the hardware required SGPRn-3 and
/// SGPRn-4 respectively using the Finalizer ?FLAT_SCRATCH? Register.
///
/// The global segment can be accessed either using flat operations or buffer
/// operations. If buffer operations are used then the Global Buffer used to
/// access HSAIL Global/Readonly/Kernarg (which are combine) segments using a
/// segment address is not passed into the kernel code by CP since its base
/// address is always 0. Instead the Finalizer generates prolog code to
/// initialize 4 SGPRs with a V# that has the following properties, and then
/// uses that in the buffer instructions:
///   - base address of 0
///   - no swizzle
///   - ATC=1
///   - MTYPE set to support memory coherence specified in
///     amd_kernel_code_t.globalMemoryCoherence
///
/// When the Global Buffer is used to access the Kernarg segment, must add the
/// dispatch packet kernArgPtr to a kernarg segment address before using this V#.
/// Alternatively scalar loads can be used if the kernarg offset is uniform, as
/// the kernarg segment is constant for the duration of the kernel execution.
///</doc>
<mbr r='amd_kernel_code_s::amd_kernel_code_version_major' o='0' t='uint32_t'/>
<mbr r='amd_kernel_code_s::amd_kernel_code_version_minor' o='32' t='uint32_t'/>
<mbr r='amd_kernel_code_s::amd_machine_kind' o='64' t='uint16_t'/>
<mbr r='amd_kernel_code_s::amd_machine_version_major' o='80' t='uint16_t'/>
<mbr r='amd_kernel_code_s::amd_machine_version_minor' o='96' t='uint16_t'/>
<mbr r='amd_kernel_code_s::amd_machine_version_stepping' o='112' t='uint16_t'/>
<mbr r='amd_kernel_code_s::kernel_code_entry_byte_offset' o='128' t='int64_t'/>
<mbr r='amd_kernel_code_s::kernel_code_prefetch_byte_offset' o='192' t='int64_t'/>
<mbr r='amd_kernel_code_s::kernel_code_prefetch_byte_size' o='256' t='uint64_t'/>
<mbr r='amd_kernel_code_s::reserved0' o='320' t='uint64_t'/>
<mbr r='amd_kernel_code_s::compute_pgm_resource_registers' o='384' t='uint64_t'/>
<mbr r='amd_kernel_code_s::code_properties' o='448' t='uint32_t'/>
<mbr r='amd_kernel_code_s::workitem_private_segment_byte_size' o='480' t='uint32_t'/>
<mbr r='amd_kernel_code_s::workgroup_group_segment_byte_size' o='512' t='uint32_t'/>
<mbr r='amd_kernel_code_s::gds_segment_byte_size' o='544' t='uint32_t'/>
<mbr r='amd_kernel_code_s::kernarg_segment_byte_size' o='576' t='uint64_t'/>
<mbr r='amd_kernel_code_s::workgroup_fbarrier_count' o='640' t='uint32_t'/>
<mbr r='amd_kernel_code_s::wavefront_sgpr_count' o='672' t='uint16_t'/>
<mbr r='amd_kernel_code_s::workitem_vgpr_count' o='688' t='uint16_t'/>
<mbr r='amd_kernel_code_s::reserved_vgpr_first' o='704' t='uint16_t'/>
<mbr r='amd_kernel_code_s::reserved_vgpr_count' o='720' t='uint16_t'/>
<mbr r='amd_kernel_code_s::reserved_sgpr_first' o='736' t='uint16_t'/>
<mbr r='amd_kernel_code_s::reserved_sgpr_count' o='752' t='uint16_t'/>
<mbr r='amd_kernel_code_s::debug_wavefront_private_segment_offset_sgpr' o='768' t='uint16_t'/>
<mbr r='amd_kernel_code_s::debug_private_segment_buffer_sgpr' o='784' t='uint16_t'/>
<mbr r='amd_kernel_code_s::kernarg_segment_alignment' o='800' t='uint8_t'/>
<mbr r='amd_kernel_code_s::group_segment_alignment' o='808' t='uint8_t'/>
<mbr r='amd_kernel_code_s::private_segment_alignment' o='816' t='uint8_t'/>
<mbr r='amd_kernel_code_s::wavefront_size' o='824' t='uint8_t'/>
<mbr r='amd_kernel_code_s::call_convention' o='832' t='int32_t'/>
<mbr r='amd_kernel_code_s::reserved3' o='864' t='uint8_t [12]'/>
<mbr r='amd_kernel_code_s::runtime_loader_kernel_symbol' o='960' t='uint64_t'/>
<mbr r='amd_kernel_code_s::control_directives' o='1024' t='uint64_t [16]'/>
