<dec f='llvm/clang/include/clang/Sema/Sema.h' l='2674' type='clang::Sema::OverloadKind clang::Sema::CheckOverload(clang::Scope * S, clang::FunctionDecl * New, const clang::LookupResult &amp; OldDecls, clang::NamedDecl *&amp; OldDecl, bool IsForUsingDecl)'/>
<use f='llvm/clang/lib/Sema/SemaDecl.cpp' l='10157' u='c' c='_ZN5clang4Sema24CheckFunctionDeclarationEPNS_5ScopeEPNS_12FunctionDeclERNS_12LookupResultEb'/>
<use f='llvm/clang/lib/Sema/SemaDeclCXX.cpp' l='9714' u='c' c='_ZN5clang4Sema20CheckUsingShadowDeclEPNS_9UsingDeclEPNS_9NamedDeclERKNS_12LookupResultERPNS_15UsingShadowDeclE'/>
<def f='llvm/clang/lib/Sema/SemaOverload.cpp' l='969' ll='1080' type='Sema::OverloadKind clang::Sema::CheckOverload(clang::Scope * S, clang::FunctionDecl * New, const clang::LookupResult &amp; Old, clang::NamedDecl *&amp; Match, bool NewIsUsingDecl)'/>
<doc f='llvm/clang/lib/Sema/SemaOverload.cpp' l='936'>/// Determine whether the given New declaration is an overload of the
/// declarations in Old. This routine returns Ovl_Match or Ovl_NonFunction if
/// New and Old cannot be overloaded, e.g., if New has the same signature as
/// some function in Old (C++ 1.3.10) or if the Old declarations aren&apos;t
/// functions (or function templates) at all. When it does return Ovl_Match or
/// Ovl_NonFunction, MatchedDecl will point to the decl that New cannot be
/// overloaded with. This decl may be a UsingShadowDecl on top of the underlying
/// declaration.
///
/// Example: Given the following input:
///
///   void f(int, float); // #1
///   void f(int, int); // #2
///   int f(int, int); // #3
///
/// When we process #1, there is no previous declaration of &quot;f&quot;, so IsOverload
/// will not be used.
///
/// When we process #2, Old contains only the FunctionDecl for #1. By comparing
/// the parameter types, we see that #1 and #2 are overloaded (since they have
/// different signatures), so this routine returns Ovl_Overload; MatchedDecl is
/// unchanged.
///
/// When we process #3, Old is an overload set containing #1 and #2. We compare
/// the signatures of #3 to #1 (they&apos;re overloaded, so we do nothing) and then
/// #3 to #2. Since the signatures of #3 and #2 are identical (return types of
/// functions are not part of the signature), IsOverload returns Ovl_Match and
/// MatchedDecl will be set to point to the FunctionDecl for #2.
///
/// &apos;NewIsUsingShadowDecl&apos; indicates that &apos;New&apos; is being introduced into a class
/// by a using declaration. The rules for whether to hide shadow declarations
/// ignore some properties which otherwise figure into a function template&apos;s
/// signature.</doc>
