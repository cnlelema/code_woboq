<dec f='llvm/clang/lib/CodeGen/TargetInfo.h' l='215' type='bool clang::CodeGen::TargetCodeGenInfo::isNoProtoCallVariadic(const CodeGen::CallArgList &amp; args, const clang::FunctionNoProtoType * fnType) const'/>
<doc f='llvm/clang/lib/CodeGen/TargetInfo.h' l='173'>/// Determine whether a call to an unprototyped functions under
  /// the given calling convention should use the variadic
  /// convention or the non-variadic convention.
  ///
  /// There&apos;s a good reason to make a platform&apos;s variadic calling
  /// convention be different from its non-variadic calling
  /// convention: the non-variadic arguments can be passed in
  /// registers (better for performance), and the variadic arguments
  /// can be passed on the stack (also better for performance).  If
  /// this is done, however, unprototyped functions *must* use the
  /// non-variadic convention, because C99 states that a call
  /// through an unprototyped function type must succeed if the
  /// function was defined with a non-variadic prototype with
  /// compatible parameters.  Therefore, splitting the conventions
  /// makes it impossible to call a variadic function through an
  /// unprototyped type.  Since function prototypes came out in the
  /// late 1970s, this is probably an acceptable trade-off.
  /// Nonetheless, not all platforms are willing to make it, and in
  /// particularly x86-64 bends over backwards to make the
  /// conventions compatible.
  ///
  /// The default is false.  This is correct whenever:
  ///   - the conventions are exactly the same, because it does not
  ///     matter and the resulting IR will be somewhat prettier in
  ///     certain cases; or
  ///   - the conventions are substantively different in how they pass
  ///     arguments, because in this case using the variadic convention
  ///     will lead to C99 violations.
  ///
  /// However, some platforms make the conventions identical except
  /// for passing additional out-of-band information to a variadic
  /// function: for example, x86-64 passes the number of SSE
  /// arguments in %al.  On these platforms, it is desirable to
  /// call unprototyped functions using the variadic convention so
  /// that unprototyped calls to varargs functions still succeed.
  ///
  /// Relatedly, platforms which pass the fixed arguments to this:
  ///   A foo(B, C, D);
  /// differently than they would pass them to this:
  ///   A foo(B, C, D, ...);
  /// may need to adjust the debugger-support code in Sema to do the
  /// right thing when calling a function with no know signature.</doc>
<use f='llvm/clang/lib/CodeGen/CGCall.cpp' l='600' u='c' c='_ZL27arrangeFreeFunctionLikeCallRN5clang7CodeGen12CodeGenTypesERNS0_13CodeGenModuleERKNS0_11CallArgListEPKNS_12FunctionTypeEjb'/>
<def f='llvm/clang/lib/CodeGen/TargetInfo.cpp' l='410' ll='417' type='bool clang::CodeGen::TargetCodeGenInfo::isNoProtoCallVariadic(const clang::CodeGen::CallArgList &amp; args, const clang::FunctionNoProtoType * fnType) const'/>
<ovr f='llvm/clang/lib/CodeGen/TargetInfo.cpp' l='2349' c='_ZNK12_GLOBAL__N_123X86_64TargetCodeGenInfo21isNoProtoCallVariadicERKN5clang7CodeGen11CallArgListEPKNS1_19FunctionNoProtoTypeE'/>
<use f='llvm/clang/lib/CodeGen/TargetInfo.cpp' l='2371' u='c' c='_ZNK12_GLOBAL__N_123X86_64TargetCodeGenInfo21isNoProtoCallVariadicERKN5clang7CodeGen11CallArgListEPKNS1_19FunctionNoProtoTypeE'/>
