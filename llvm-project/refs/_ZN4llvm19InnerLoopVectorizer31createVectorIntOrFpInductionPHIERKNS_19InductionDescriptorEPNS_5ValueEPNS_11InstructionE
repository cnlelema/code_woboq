<dec f='llvm/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp' l='542' type='void llvm::InnerLoopVectorizer::createVectorIntOrFpInductionPHI(const llvm::InductionDescriptor &amp; II, llvm::Value * Step, llvm::Instruction * EntryVal)'/>
<def f='llvm/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp' l='1543' ll='1618' type='void llvm::InnerLoopVectorizer::createVectorIntOrFpInductionPHI(const llvm::InductionDescriptor &amp; II, llvm::Value * Step, llvm::Instruction * EntryVal)'/>
<use f='llvm/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp' l='1707' u='c' c='_ZN4llvm19InnerLoopVectorizer21widenIntOrFpInductionEPNS_7PHINodeEPNS_9TruncInstE'/>
<doc f='llvm/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp' l='537'>/// Create a vector induction phi node based on an existing scalar one. \p
  /// EntryVal is the value from the original loop that maps to the vector phi
  /// node, and \p Step is the loop-invariant step. If \p EntryVal is a
  /// truncate instruction, instead of widening the original IV, we widen a
  /// version of the IV truncated to \p EntryVal&apos;s type.</doc>
