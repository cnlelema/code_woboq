<dec f='llvm/llvm/include/llvm/CodeGen/TargetInstrInfo.h' l='971' type='bool llvm::TargetInstrInfo::isReassociationCandidate(const llvm::MachineInstr &amp; Inst, bool &amp; Commuted) const'/>
<doc f='llvm/llvm/include/llvm/CodeGen/TargetInstrInfo.h' l='966'>/// Return true if the input \P Inst is part of a chain of dependent ops
  /// that are suitable for reassociation, otherwise return false.
  /// If the instruction&apos;s operands must be commuted to have a previous
  /// instruction of the same type define the first source operand, \P Commuted
  /// will be set to true.</doc>
<def f='llvm/llvm/lib/CodeGen/TargetInstrInfo.cpp' l='707' ll='712' type='bool llvm::TargetInstrInfo::isReassociationCandidate(const llvm::MachineInstr &amp; Inst, bool &amp; Commuted) const'/>
<use f='llvm/llvm/lib/CodeGen/TargetInstrInfo.cpp' l='739' u='c' c='_ZNK4llvm15TargetInstrInfo26getMachineCombinerPatternsERNS_12MachineInstrERNS_15SmallVectorImplINS_22MachineCombinerPatternEEE'/>
<doc f='llvm/llvm/lib/CodeGen/TargetInstrInfo.cpp' l='703'>// 1. The operation must be associative and commutative.
// 2. The instruction must have virtual register definitions for its
//    operands in the same basic block.
// 3. The instruction must have a reassociable sibling.</doc>
