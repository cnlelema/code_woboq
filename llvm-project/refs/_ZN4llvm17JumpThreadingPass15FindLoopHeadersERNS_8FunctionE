<dec f='llvm/llvm/include/llvm/Transforms/Scalar/JumpThreading.h' l='110' type='void llvm::JumpThreadingPass::FindLoopHeaders(llvm::Function &amp; F)'/>
<use f='llvm/llvm/lib/Transforms/Scalar/JumpThreading.cpp' l='371' u='c' c='_ZN4llvm17JumpThreadingPass7runImplERNS_8FunctionEPNS_17TargetLibraryInfoEPNS_13LazyValueInfoEPNS_9AAResultsEPNS_14DomTreeUpdaterEbSt10unique_ptrINS_16218292'/>
<def f='llvm/llvm/lib/Transforms/Scalar/JumpThreading.cpp' l='543' ll='549' type='void llvm::JumpThreadingPass::FindLoopHeaders(llvm::Function &amp; F)'/>
<doc f='llvm/llvm/lib/Transforms/Scalar/JumpThreading.cpp' l='529'>/// FindLoopHeaders - We do not want jump threading to turn proper loop
/// structures into irreducible loops.  Doing this breaks up the loop nesting
/// hierarchy and pessimizes later transformations.  To prevent this from
/// happening, we first have to find the loop headers.  Here we approximate this
/// by finding targets of backedges in the CFG.
///
/// Note that there definitely are cases when we want to allow threading of
/// edges across a loop header.  For example, threading a jump from outside the
/// loop (the preheader) to an exit block of the loop is definitely profitable.
/// It is also almost always profitable to thread backedges from within the loop
/// to exit blocks, and is often profitable to thread backedges to other blocks
/// within the loop (forming a nested loop).  This simple analysis is not rich
/// enough to track all of these properties and keep it up-to-date as the CFG
/// mutates, so we don&apos;t allow any of these transformations.</doc>
