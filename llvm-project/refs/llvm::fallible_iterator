<def f='llvm/llvm/include/llvm/ADT/fallible_iterator.h' l='68' ll='218'/>
<doc f='llvm/llvm/include/llvm/ADT/fallible_iterator.h' l='20'>/// A wrapper class for fallible iterators.
///
///   The fallible_iterator template wraps an underlying iterator-like class
/// whose increment and decrement operations are replaced with fallible versions
/// like:
///
///   @code{.cpp}
///   Error inc();
///   Error dec();
///   @endcode
///
///   It produces an interface that is (mostly) compatible with a traditional
/// c++ iterator, including ++ and -- operators that do not fail.
///
///   Instances of the wrapper are constructed with an instance of the
/// underlying iterator and (for non-end iterators) a reference to an Error
/// instance. If the underlying increment/decrement operations fail, the Error
/// is returned via this reference, and the resulting iterator value set to an
/// end-of-range sentinel value. This enables the following loop idiom:
///
///   @code{.cpp}
///   class Archive { // E.g. Potentially malformed on-disk archive
///   public:
///     fallible_iterator&lt;ArchiveChildItr&gt; children_begin(Error &amp;Err);
///     fallible_iterator&lt;ArchiveChildItr&gt; children_end();
///     iterator_range&lt;fallible_iterator&lt;ArchiveChildItr&gt;&gt;
///     children(Error &amp;Err) {
///       return make_range(children_begin(Err), children_end());
///     //...
///   };
///
///   void walk(Archive &amp;A) {
///     Error Err = Error::success();
///     for (auto &amp;C : A.children(Err)) {
///       // Loop body only entered when increment succeeds.
///     }
///     if (Err) {
///       // handle error.
///     }
///   }
///   @endcode
///
///   The wrapper marks the referenced Error as unchecked after each increment
/// and/or decrement operation, and clears the unchecked flag when a non-end
/// value is compared against end (since, by the increment invariant, not being
/// an end value proves that there was no error, and is equivalent to checking
/// that the Error is success). This allows early exits from the loop body
/// without requiring redundant error checks.</doc>
<fun r='_ZN4llvm17fallible_iterator3itrET_RNS_5ErrorE'/>
<fun r='_ZN4llvm17fallible_iterator3endET_'/>
<fun r='_ZN4llvm17fallible_iteratordeEv'/>
<fun r='_ZNK4llvm17fallible_iteratordeEv'/>
<fun r='_ZN4llvm17fallible_iteratorptEv'/>
<fun r='_ZNK4llvm17fallible_iteratorptEv'/>
<fun r='_ZN4llvm17fallible_iteratorppEv'/>
<fun r='_ZN4llvm17fallible_iteratormmEv'/>
<fun r='_ZN4llvm17fallible_iteratorC1ET_PNS_5ErrorE'/>
<fun r='_ZNK4llvm17fallible_iterator9getErrPtrEv'/>
<fun r='_ZNK4llvm17fallible_iterator5isEndEv'/>
<fun r='_ZNK4llvm17fallible_iterator7isValidEv'/>
<fun r='_ZN4llvm17fallible_iterator11handleErrorENS_5ErrorE'/>
<fun r='_ZN4llvm17fallible_iterator16resetCheckedFlagEv'/>
<mbr r='llvm::fallible_iterator::I' t='Underlying'/>
<mbr r='llvm::fallible_iterator::ErrState' t='PointerIntPair&lt;llvm::Error *, 1&gt;'/>
