<dec f='llvm/llvm/lib/Target/X86/X86InstrInfo.h' l='273' type='unsigned int llvm::X86InstrInfo::getFMA3OpcodeToCommuteOperands(const llvm::MachineInstr &amp; MI, unsigned int SrcOpIdx1, unsigned int SrcOpIdx2, const llvm::X86InstrFMA3Group &amp; FMA3Group) const'/>
<doc f='llvm/llvm/lib/Target/X86/X86InstrInfo.h' l='257'>/// Returns an adjusted FMA opcode that must be used in FMA instruction that
  /// performs the same computations as the given \p MI but which has the
  /// operands \p SrcOpIdx1 and \p SrcOpIdx2 commuted.
  /// It may return 0 if it is unsafe to commute the operands.
  /// Note that a machine instruction (instead of its opcode) is passed as the
  /// first parameter to make it possible to analyze the instruction&apos;s uses and
  /// commute the first operand of FMA even when it seems unsafe when you look
  /// at the opcode. For example, it is Ok to commute the first operand of
  /// VFMADD*SD_Int, if ONLY the lowest 64-bit element of the result is used.
  ///
  /// The returned FMA opcode may differ from the opcode in the given \p MI.
  /// For example, commuting the operands #1 and #3 in the following FMA
  ///     FMA213 #1, #2, #3
  /// results into instruction with adjusted opcode:
  ///     FMA231 #3, #2, #1</doc>
<def f='llvm/llvm/lib/Target/X86/X86InstrInfo.cpp' l='1236' ll='1292' type='unsigned int llvm::X86InstrInfo::getFMA3OpcodeToCommuteOperands(const llvm::MachineInstr &amp; MI, unsigned int SrcOpIdx1, unsigned int SrcOpIdx2, const llvm::X86InstrFMA3Group &amp; FMA3Group) const'/>
<use f='llvm/llvm/lib/Target/X86/X86InstrInfo.cpp' l='1700' u='c' c='_ZNK4llvm12X86InstrInfo22commuteInstructionImplERNS_12MachineInstrEbjj'/>
