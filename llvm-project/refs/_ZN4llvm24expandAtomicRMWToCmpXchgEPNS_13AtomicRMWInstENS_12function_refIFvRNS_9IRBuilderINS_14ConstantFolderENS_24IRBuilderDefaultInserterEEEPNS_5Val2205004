<dec f='llvm/llvm/include/llvm/CodeGen/AtomicExpandUtils.h' l='60' type='bool llvm::expandAtomicRMWToCmpXchg(llvm::AtomicRMWInst * AI, CreateCmpXchgInstFun CreateCmpXchg)'/>
<dec f='llvm/llvm/lib/CodeGen/AtomicExpandPass.cpp' l='118' type='bool llvm::expandAtomicRMWToCmpXchg(llvm::AtomicRMWInst * AI, CreateCmpXchgInstFun CreateCmpXchg)'/>
<use f='llvm/llvm/lib/CodeGen/AtomicExpandPass.cpp' l='595' u='c' c='_ZN12_GLOBAL__N_112AtomicExpand18tryExpandAtomicRMWEPN4llvm13AtomicRMWInstE'/>
<def f='llvm/llvm/lib/CodeGen/AtomicExpandPass.cpp' l='1430' ll='1444' type='bool llvm::expandAtomicRMWToCmpXchg(llvm::AtomicRMWInst * AI, CreateCmpXchgInstFun CreateCmpXchg)'/>
<use f='llvm/llvm/lib/CodeGen/AtomicExpandPass.cpp' l='1586' u='c' c='_ZN12_GLOBAL__N_112AtomicExpand24expandAtomicRMWToLibcallEPN4llvm13AtomicRMWInstE'/>
<doc f='llvm/llvm/lib/CodeGen/AtomicExpandPass.cpp' l='1429'>// Note: This function is exposed externally by AtomicExpandUtils.h</doc>
<doc f='llvm/llvm/include/llvm/CodeGen/AtomicExpandUtils.h' l='28'>/// Expand an atomic RMW instruction into a loop utilizing
/// cmpxchg. You&apos;ll want to make sure your target machine likes cmpxchg
/// instructions in the first place and that there isn&apos;t another, better,
/// transformation available (for example AArch32/AArch64 have linked loads).
///
/// This is useful in passes which can&apos;t rewrite the more exotic RMW
/// instructions directly into a platform specific intrinsics (because, say,
/// those intrinsics don&apos;t exist). If such a pass is able to expand cmpxchg
/// instructions directly however, then, with this function, it could avoid two
/// extra module passes (avoiding passes by `-atomic-expand` and itself). A
/// specific example would be PNaCl&apos;s `RewriteAtomics` pass.
///
/// Given: atomicrmw some_op iN* %addr, iN %incr ordering
///
/// The standard expansion we produce is:
///     [...]
///     %init_loaded = load atomic iN* %addr
///     br label %loop
/// loop:
///     %loaded = phi iN [ %init_loaded, %entry ], [ %new_loaded, %loop ]
///     %new = some_op iN %loaded, %incr
/// ; This is what -atomic-expand will produce using this function on i686
/// targets:
///     %pair = cmpxchg iN* %addr, iN %loaded, iN %new_val
///     %new_loaded = extractvalue { iN, i1 } %pair, 0
///     %success = extractvalue { iN, i1 } %pair, 1
/// ; End callback produced IR
///     br i1 %success, label %atomicrmw.end, label %loop
/// atomicrmw.end:
///     [...]
///
/// Returns true if the containing function was modified.</doc>
