<dec f='llvm/llvm/lib/Target/ARM/ARMISelLowering.h' l='543' type='TargetLoweringBase::AtomicExpansionKind llvm::ARMTargetLowering::shouldExpandAtomicLoadInIR(llvm::LoadInst * LI) const'/>
<inh f='llvm/llvm/include/llvm/CodeGen/TargetLowering.h' l='1801' c='_ZNK4llvm18TargetLoweringBase26shouldExpandAtomicLoadInIREPNS_8LoadInstE'/>
<def f='llvm/llvm/lib/Target/ARM/ARMISelLowering.cpp' l='14752' ll='14757' type='TargetLowering::AtomicExpansionKind llvm::ARMTargetLowering::shouldExpandAtomicLoadInIR(llvm::LoadInst * LI) const'/>
<doc f='llvm/llvm/lib/Target/ARM/ARMISelLowering.cpp' l='14745'>// Loads and stores less than 64-bits are already atomic; ones above that
// are doomed anyway, so defer to the default libcall and blame the OS when
// things go wrong. Cortex M doesn&apos;t have ldrexd/strexd though, so don&apos;t emit
// anything for those.
// FIXME: ldrd and strd are atomic if the CPU has LPAE (e.g. A15 has that
// guarantee, see DDI0406C ARM architecture reference manual,
// sections A8.8.72-74 LDRD)</doc>
