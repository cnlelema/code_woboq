<dec f='llvm/clang/include/clang/Sema/Sema.h' l='4818' type='void clang::Sema::HideUsingShadowDecl(clang::Scope * S, clang::UsingShadowDecl * Shadow)'/>
<def f='llvm/clang/lib/Sema/SemaDeclCXX.cpp' l='9846' ll='9865' type='void clang::Sema::HideUsingShadowDecl(clang::Scope * S, clang::UsingShadowDecl * Shadow)'/>
<doc f='llvm/clang/lib/Sema/SemaDeclCXX.cpp' l='9819'>/// Hides a using shadow declaration.  This is required by the current
/// using-decl implementation when a resolvable using declaration in a
/// class is followed by a declaration which would hide or override
/// one or more of the using decl&apos;s targets; for example:
///
///   struct Base { void foo(int); };
///   struct Derived : Base {
///     using Base::foo;
///     void foo(int);
///   };
///
/// The governing language is C++03 [namespace.udecl]p12:
///
///   When a using-declaration brings names from a base class into a
///   derived class scope, member functions in the derived class
///   override and/or hide member functions with the same name and
///   parameter types in a base class (rather than conflicting).
///
/// There are two ways to implement this:
///   (1) optimistically create shadow decls when they&apos;re not hidden
///       by existing declarations, or
///   (2) don&apos;t create any shadow decls (or at least don&apos;t make them
///       visible) until we&apos;ve fully parsed/instantiated the class.
/// The problem with (1) is that we might have to retroactively remove
/// a shadow decl, which requires several O(n) operations because the
/// decl structures are (very reasonably) not designed for removal.
/// (2) avoids this but is very fiddly and phase-dependent.</doc>
<use f='llvm/clang/lib/Sema/SemaOverload.cpp' l='1004' u='c' c='_ZN5clang4Sema13CheckOverloadEPNS_5ScopeEPNS_12FunctionDeclERKNS_12LookupResultERPNS_9NamedDeclEb'/>
