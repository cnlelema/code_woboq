<dec f='llvm/llvm/include/llvm/Transforms/Utils/UnrollLoop.h' l='86' type='bool llvm::UnrollRuntimeLoopRemainder(llvm::Loop * L, unsigned int Count, bool AllowExpensiveTripCount, bool UseEpilogRemainder, bool UnrollRemainder, bool ForgetAllSCEV, llvm::LoopInfo * LI, llvm::ScalarEvolution * SE, llvm::DominatorTree * DT, llvm::AssumptionCache * AC, bool PreserveLCSSA, llvm::Loop ** ResultLoop = nullptr)'/>
<use f='llvm/llvm/lib/Transforms/Utils/LoopUnroll.cpp' l='411' u='c' c='_ZN4llvm10UnrollLoopEPNS_4LoopENS_17UnrollLoopOptionsEPNS_8LoopInfoEPNS_15ScalarEvolutionEPNS_13DominatorTreeEPNS_15AssumptionCacheEPNS_25OptimizationRemarkEmitterEbPS1_'/>
<use f='llvm/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp' l='198' u='c' c='_ZN4llvm16UnrollAndJamLoopEPNS_4LoopEjjjbPNS_8LoopInfoEPNS_15ScalarEvolutionEPNS_13DominatorTreeEPNS_15AssumptionCacheEPNS_25OptimizationRemarkEmitterEPS1_'/>
<def f='llvm/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp' l='553' ll='965' type='bool llvm::UnrollRuntimeLoopRemainder(llvm::Loop * L, unsigned int Count, bool AllowExpensiveTripCount, bool UseEpilogRemainder, bool UnrollRemainder, bool ForgetAllSCEV, llvm::LoopInfo * LI, llvm::ScalarEvolution * SE, llvm::DominatorTree * DT, llvm::AssumptionCache * AC, bool PreserveLCSSA, llvm::Loop ** ResultLoop = nullptr)'/>
<doc f='llvm/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp' l='515'>/// Insert code in the prolog/epilog code when unrolling a loop with a
/// run-time trip-count.
///
/// This method assumes that the loop unroll factor is total number
/// of loop bodies in the loop after unrolling. (Some folks refer
/// to the unroll factor as the number of *extra* copies added).
/// We assume also that the loop unroll factor is a power-of-two. So, after
/// unrolling the loop, the number of loop bodies executed is 2,
/// 4, 8, etc.  Note - LLVM converts the if-then-sequence to a switch
/// instruction in SimplifyCFG.cpp.  Then, the backend decides how code for
/// the switch instruction is generated.
///
/// ***Prolog case***
///        extraiters = tripcount % loopfactor
///        if (extraiters == 0) jump Loop:
///        else jump Prol:
/// Prol:  LoopBody;
///        extraiters -= 1                 // Omitted if unroll factor is 2.
///        if (extraiters != 0) jump Prol: // Omitted if unroll factor is 2.
///        if (tripcount &lt; loopfactor) jump End:
/// Loop:
/// ...
/// End:
///
/// ***Epilog case***
///        extraiters = tripcount % loopfactor
///        if (tripcount &lt; loopfactor) jump LoopExit:
///        unroll_iters = tripcount - extraiters
/// Loop:  LoopBody; (executes unroll_iter times);
///        unroll_iter -= 1
///        if (unroll_iter != 0) jump Loop:
/// LoopExit:
///        if (extraiters == 0) jump EpilExit:
/// Epil:  LoopBody; (executes extraiters times)
///        extraiters -= 1                 // Omitted if unroll factor is 2.
///        if (extraiters != 0) jump Epil: // Omitted if unroll factor is 2.
/// EpilExit:</doc>
<use f='llvm/llvm/unittests/Transforms/Utils/UnrollLoopTest.cpp' l='73' u='c' c='_ZN28LoopUnrollRuntime_Latch_Test8TestBodyEv'/>
