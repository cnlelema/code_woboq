<dec f='llvm/lld/ELF/Target.h' l='173' type='bool lld::elf::tryRelaxPPC64TocIndirection(RelType Type, const lld::elf::Relocation &amp; Rel, uint8_t * BufLoc)'/>
<def f='llvm/lld/ELF/Arch/PPC64.cpp' l='156' ll='186' type='bool lld::elf::tryRelaxPPC64TocIndirection(RelType Type, const lld::elf::Relocation &amp; Rel, uint8_t * BufLoc)'/>
<doc f='llvm/lld/ELF/Arch/PPC64.cpp' l='136'>// When accessing a symbol defined in another translation unit, compilers
// reserve a .toc entry, allocate a local label and generate toc-indirect
// instuctions:
//
//   addis 3, 2, .LC0@toc@ha  # R_PPC64_TOC16_HA
//   ld    3, .LC0@toc@l(3)   # R_PPC64_TOC16_LO_DS, load the address from a .toc entry
//   ld/lwa 3, 0(3)           # load the value from the address
//
//   .section .toc,&quot;aw&quot;,@progbits
//   .LC0: .tc var[TC],var
//
// If var is defined, non-preemptable and addressable with a 32-bit signed
// offset from the toc base, the address of var can be computed by adding an
// offset to the toc base, saving a load.
//
//   addis 3,2,var@toc@ha     # this may be relaxed to a nop,
//   addi  3,3,var@toc@l      # then this becomes addi 3,2,var@toc
//   ld/lwa 3, 0(3)           # load the value from the address
//
// Returns true if the relaxation is performed.</doc>
<use f='llvm/lld/ELF/InputSection.cpp' l='976' u='c' c='_ZN3lld3elf16InputSectionBase13relocateAllocEPhS2_'/>
