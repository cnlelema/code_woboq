<dec f='llvm/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp' l='570' type='void llvm::InnerLoopVectorizer::recordVectorLoopValueForInductionCast(const llvm::InductionDescriptor &amp; ID, const llvm::Instruction * EntryVal, llvm::Value * VectorLoopValue, unsigned int Part, unsigned int Lane = (2147483647 * 2U + 1U))'/>
<use f='llvm/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp' l='1601' u='c' c='_ZN4llvm19InnerLoopVectorizer31createVectorIntOrFpInductionPHIERKNS_19InductionDescriptorEPNS_5ValueEPNS_11InstructionE'/>
<def f='llvm/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp' l='1635' ll='1661' type='void llvm::InnerLoopVectorizer::recordVectorLoopValueForInductionCast(const llvm::InductionDescriptor &amp; ID, const llvm::Instruction * EntryVal, llvm::Value * VectorLoopVal, unsigned int Part, unsigned int Lane = (2147483647 * 2U + 1U))'/>
<use f='llvm/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp' l='1746' u='c' c='_ZN4llvm19InnerLoopVectorizer21widenIntOrFpInductionEPNS_7PHINodeEPNS_9TruncInstE'/>
<use f='llvm/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp' l='1852' u='c' c='_ZN4llvm19InnerLoopVectorizer16buildScalarStepsEPNS_5ValueES2_PNS_11InstructionERKNS_19InductionDescriptorE'/>
<doc f='llvm/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp' l='552'>/// If there is a cast involved in the induction variable \p ID, which should
  /// be ignored in the vectorized loop body, this function records the
  /// VectorLoopValue of the respective Phi also as the VectorLoopValue of the
  /// cast. We had already proved that the casted Phi is equal to the uncasted
  /// Phi in the vectorized loop (under a runtime guard), and therefore
  /// there is no need to vectorize the cast - the same value can be used in the
  /// vector loop for both the Phi and the cast.
  /// If \p VectorLoopValue is a scalarized value, \p Lane is also specified,
  /// Otherwise, \p VectorLoopValue is a widened/vectorized value.
  ///
  /// \p EntryVal is the value from the original loop that maps to the vector
  /// phi node and is used to distinguish what is the IV currently being
  /// processed - original one (if \p EntryVal is a phi corresponding to the
  /// original IV) or the &quot;newly-created&quot; one based on the proof mentioned above
  /// (see also buildScalarSteps() and createVectorIntOrFPInductionPHI()). In the
  /// latter case \p EntryVal is a TruncInst and we must not record anything for
  /// that IV, but it&apos;s error-prone to expect callers of this routine to care
  /// about that, hence this explicit parameter.</doc>
