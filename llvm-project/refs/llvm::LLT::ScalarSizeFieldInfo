<use f='llvm/llvm/include/llvm/Support/LowLevelTypeImpl.h' l='144' u='r' c='_ZNK4llvm3LLT19getScalarSizeInBitsEv'/>
<dec f='llvm/llvm/include/llvm/Support/LowLevelTypeImpl.h' l='203' type='const BitFieldInfo'/>
<use f='llvm/llvm/include/llvm/Support/LowLevelTypeImpl.h' l='252' u='r' c='_ZN4llvm3LLT4initEbbtjj'/>
<doc f='llvm/llvm/include/llvm/Support/LowLevelTypeImpl.h' l='196'>///
  /// This is how the bitfields are packed per Kind:
  /// * Invalid:
  ///   gets encoded as RawData == 0, as that is an invalid encoding, since for
  ///   valid encodings, SizeInBits/SizeOfElement must be larger than 0.
  /// * Non-pointer scalar (isPointer == 0 &amp;&amp; isVector == 0):
  ///   SizeInBits: 32;</doc>
<def f='llvm/llvm/lib/Support/LowLevelType.cpp' l='48' type='const LLT::BitFieldInfo'/>
