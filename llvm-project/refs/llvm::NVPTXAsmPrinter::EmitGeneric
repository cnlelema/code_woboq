<use f='llvm/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.h' l='106' u='r' c='_ZN4llvm15NVPTXAsmPrinter9AggBufferC1EjRNS_11raw_ostreamERS0_'/>
<dec f='llvm/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.h' l='288' type='bool'/>
<use f='llvm/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.h' l='293' u='w' c='_ZN4llvm15NVPTXAsmPrinterC1ERNS_13TargetMachineESt10unique_ptrINS_10MCStreamerESt14default_deleteIS4_EE'/>
<use f='llvm/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp' l='1731' u='r' c='_ZN4llvm15NVPTXAsmPrinter19printScalarConstantEPKNS_8ConstantERNS_11raw_ostreamE'/>
<use f='llvm/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp' l='1748' u='r' c='_ZN4llvm15NVPTXAsmPrinter19printScalarConstantEPKNS_8ConstantERNS_11raw_ostreamE'/>
<offset>5760</offset>
<doc f='llvm/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.h' l='277'>// Used to control the need to emit .generic() in the initializer of
  // module scope variables.
  // Although ptx supports the hybrid mode like the following,
  //    .global .u32 a;
  //    .global .u32 b;
  //    .global .u32 addr[] = {a, generic(b)}
  // we have difficulty representing the difference in the NVVM IR.
  //
  // Since the address value should always be generic in CUDA C and always
  // be specific in OpenCL, we use this simple control here.
  //</doc>
