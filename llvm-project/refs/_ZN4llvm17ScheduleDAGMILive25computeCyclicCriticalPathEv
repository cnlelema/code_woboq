<dec f='llvm/llvm/include/llvm/CodeGen/MachineScheduler.h' l='481' type='unsigned int llvm::ScheduleDAGMILive::computeCyclicCriticalPath()'/>
<def f='llvm/llvm/lib/CodeGen/MachineScheduler.cpp' l='1313' ll='1370' type='unsigned int llvm::ScheduleDAGMILive::computeCyclicCriticalPath()'/>
<use f='llvm/llvm/lib/CodeGen/MachineScheduler.cpp' l='2853' u='c' c='_ZN4llvm16GenericScheduler13registerRootsEv'/>
<doc f='llvm/llvm/lib/CodeGen/MachineScheduler.cpp' l='1287'>/// Compute the max cyclic critical path through the DAG. The scheduling DAG
/// only provides the critical path for single block loops. To handle loops that
/// span blocks, we could use the vreg path latencies provided by
/// MachineTraceMetrics instead. However, MachineTraceMetrics is not currently
/// available for use in the scheduler.
///
/// The cyclic path estimation identifies a def-use pair that crosses the back
/// edge and considers the depth and height of the nodes. For example, consider
/// the following instruction sequence where each instruction has unit latency
/// and defines an epomymous virtual register:
///
/// a-&gt;b(a,c)-&gt;c(b)-&gt;d(c)-&gt;exit
///
/// The cyclic critical path is a two cycles: b-&gt;c-&gt;b
/// The acyclic critical path is four cycles: a-&gt;b-&gt;c-&gt;d-&gt;exit
/// LiveOutHeight = height(c) = len(c-&gt;d-&gt;exit) = 2
/// LiveOutDepth = depth(c) + 1 = len(a-&gt;b-&gt;c) + 1 = 3
/// LiveInHeight = height(b) + 1 = len(b-&gt;c-&gt;d-&gt;exit) + 1 = 4
/// LiveInDepth = depth(b) = len(a-&gt;b) = 1
///
/// LiveOutDepth - LiveInDepth = 3 - 1 = 2
/// LiveInHeight - LiveOutHeight = 4 - 2 = 2
/// CyclicCriticalPath = min(2, 2) = 2
///
/// This could be relevant to PostRA scheduling, but is currently implemented
/// assuming LiveIntervals.</doc>
<doc f='llvm/llvm/include/llvm/CodeGen/MachineScheduler.h' l='480'>/// Compute the cyclic critical path through the DAG.</doc>
