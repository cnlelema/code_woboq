<dec f='llvm/llvm/lib/Target/X86/X86InstrInfo.h' l='499' type='llvm::MachineInstr * llvm::X86InstrInfo::optimizeLoadInstr(llvm::MachineInstr &amp; MI, const llvm::MachineRegisterInfo * MRI, unsigned int &amp; FoldAsLoadDefReg, llvm::MachineInstr *&amp; DefMI) const'/>
<doc f='llvm/llvm/lib/Target/X86/X86InstrInfo.h' l='492'>/// optimizeLoadInstr - Try to remove the load by folding it to a register
  /// operand at the use. We fold the load instructions if and only if the
  /// def and use are in the same BB. We only look at one load and see
  /// whether it can be folded into MI. FoldAsLoadDefReg is the virtual register
  /// defined by the load we are trying to fold. DefMI returns the machine
  /// instruction that defines FoldAsLoadDefReg, and the function returns
  /// the machine instruction generated due to folding.</doc>
<def f='llvm/llvm/lib/Target/X86/X86InstrInfo.cpp' l='3644' ll='3679' type='llvm::MachineInstr * llvm::X86InstrInfo::optimizeLoadInstr(llvm::MachineInstr &amp; MI, const llvm::MachineRegisterInfo * MRI, unsigned int &amp; FoldAsLoadDefReg, llvm::MachineInstr *&amp; DefMI) const'/>
<doc f='llvm/llvm/lib/Target/X86/X86InstrInfo.cpp' l='3640'>/// Try to remove the load by folding it to a register
/// operand at the use. We fold the load instructions if load defines a virtual
/// register, the virtual register is used once in the same BB, and the
/// instructions in-between do not load or store, and have no side effects.</doc>
