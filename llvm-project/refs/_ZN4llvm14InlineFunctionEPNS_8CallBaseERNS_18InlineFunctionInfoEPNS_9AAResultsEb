<dec f='llvm/llvm/include/llvm/Transforms/Utils/Cloning.h' l='232' type='llvm::InlineResult llvm::InlineFunction(llvm::CallBase * CB, llvm::InlineFunctionInfo &amp; IFI, llvm::AAResults * CalleeAAR = nullptr, bool InsertLifetime = true)'/>
<doc f='llvm/llvm/include/llvm/Transforms/Utils/Cloning.h' l='213'>/// This function inlines the called function into the basic
/// block of the caller.  This returns false if it is not possible to inline
/// this call.  The program is still in a well defined state if this occurs
/// though.
///
/// Note that this only does one level of inlining.  For example, if the
/// instruction &apos;call B&apos; is inlined, and &apos;B&apos; calls &apos;C&apos;, then the call to &apos;C&apos; now
/// exists in the instruction stream.  Similarly this will inline a recursive
/// function by one level.
///
/// Note that while this routine is allowed to cleanup and optimize the
/// *inlined* code to minimize the actual inserted code, it must not delete
/// code in the caller as users of this routine may have pointers to
/// instructions in the caller that need to remain stable.
///
/// If ForwardVarArgsTo is passed, inlining a function with varargs is allowed
/// and all varargs at the callsite will be passed to any calls to
/// ForwardVarArgsTo. The caller of InlineFunction has to make sure any varargs
/// are only used by ForwardVarArgsTo.</doc>
<use f='llvm/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp' l='652' u='c' c='_ZL19InsertSafepointPollPN4llvm11InstructionERSt6vectorIPNS_8CallBaseESaIS4_EERKNS_17TargetLibraryInfoE'/>
<def f='llvm/llvm/lib/Transforms/Utils/InlineFunction.cpp' l='87' ll='91' type='llvm::InlineResult llvm::InlineFunction(llvm::CallBase * CB, llvm::InlineFunctionInfo &amp; IFI, llvm::AAResults * CalleeAAR = nullptr, bool InsertLifetime = true)'/>
