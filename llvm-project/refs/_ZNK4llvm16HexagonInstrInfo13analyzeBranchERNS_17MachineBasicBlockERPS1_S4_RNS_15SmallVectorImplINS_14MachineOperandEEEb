<dec f='llvm/llvm/lib/Target/Hexagon/HexagonInstrInfo.h' l='106' type='bool llvm::HexagonInstrInfo::analyzeBranch(llvm::MachineBasicBlock &amp; MBB, llvm::MachineBasicBlock *&amp; TBB, llvm::MachineBasicBlock *&amp; FBB, SmallVectorImpl&lt;llvm::MachineOperand&gt; &amp; Cond, bool AllowModify) const'/>
<doc f='llvm/llvm/lib/Target/Hexagon/HexagonInstrInfo.h' l='82'>/// Analyze the branching code at the end of MBB, returning
  /// true if it cannot be understood (e.g. it&apos;s a switch dispatch or isn&apos;t
  /// implemented for a target).  Upon success, this returns false and returns
  /// with the following information in various cases:
  ///
  /// 1. If this block ends with no branches (it just falls through to its succ)
  ///    just return false, leaving TBB/FBB null.
  /// 2. If this block ends with only an unconditional branch, it sets TBB to be
  ///    the destination block.
  /// 3. If this block ends with a conditional branch and it falls through to a
  ///    successor block, it sets TBB to be the branch destination block and a
  ///    list of operands that evaluate the condition. These operands can be
  ///    passed to other TargetInstrInfo methods to create new branches.
  /// 4. If this block ends with a conditional branch followed by an
  ///    unconditional branch, it returns the &apos;true&apos; destination in TBB, the
  ///    &apos;false&apos; destination in FBB, and a list of operands that evaluate the
  ///    condition.  These operands can be passed to other TargetInstrInfo
  ///    methods to create new branches.
  ///
  /// Note that removeBranch and insertBranch must be implemented to support
  /// cases where this method returns success.
  ///
  /// If AllowModify is true, then this routine is allowed to modify the basic
  /// block (e.g. delete instructions after the unconditional branch).</doc>
<use f='llvm/llvm/lib/Target/Hexagon/HexagonBranchRelaxation.cpp' l='166' u='c' c='_ZN12_GLOBAL__N_123HexagonBranchRelaxation16isJumpOutOfRangeERN4llvm12MachineInstrERNS1_8DenseMapIPNS1_17MachineBasicBlockEjNS1_12DenseMapInfoIS6_EENS15141014'/>
<use f='llvm/llvm/lib/Target/Hexagon/HexagonHardwareLoops.cpp' l='457' u='c' c='_ZNK12_GLOBAL__N_120HexagonHardwareLoops21findInductionRegisterEPN4llvm11MachineLoopERjRlRPNS1_12MachineInstrE'/>
<use f='llvm/llvm/lib/Target/Hexagon/HexagonHardwareLoops.cpp' l='618' u='c' c='_ZN12_GLOBAL__N_120HexagonHardwareLoops16getLoopTripCountEPN4llvm11MachineLoopERNS1_15SmallVectorImplIPNS1_12MachineInstrEEE'/>
<use f='llvm/llvm/lib/Target/Hexagon/HexagonHardwareLoops.cpp' l='630' u='c' c='_ZN12_GLOBAL__N_120HexagonHardwareLoops16getLoopTripCountEPN4llvm11MachineLoopERNS1_15SmallVectorImplIPNS1_12MachineInstrEEE'/>
<use f='llvm/llvm/lib/Target/Hexagon/HexagonHardwareLoops.cpp' l='1226' u='c' c='_ZN12_GLOBAL__N_120HexagonHardwareLoops21convertToHardwareLoopEPN4llvm11MachineLoopERbS4_'/>
<use f='llvm/llvm/lib/Target/Hexagon/HexagonHardwareLoops.cpp' l='1465' u='c' c='_ZNK12_GLOBAL__N_120HexagonHardwareLoops27loopCountMayWrapOrUnderFlowEPKN4llvm14MachineOperandES4_PNS1_17MachineBasicBlockEPNS1_11MachineLoopERSt3mapI6700881'/>
<use f='llvm/llvm/lib/Target/Hexagon/HexagonHardwareLoops.cpp' l='1660' u='c' c='_ZN12_GLOBAL__N_120HexagonHardwareLoops22fixupInductionVariableEPN4llvm11MachineLoopE'/>
<use f='llvm/llvm/lib/Target/Hexagon/HexagonHardwareLoops.cpp' l='1667' u='c' c='_ZN12_GLOBAL__N_120HexagonHardwareLoops22fixupInductionVariableEPN4llvm11MachineLoopE'/>
<use f='llvm/llvm/lib/Target/Hexagon/HexagonHardwareLoops.cpp' l='1879' u='c' c='_ZN12_GLOBAL__N_120HexagonHardwareLoops22createPreheaderForLoopEPN4llvm11MachineLoopE'/>
<use f='llvm/llvm/lib/Target/Hexagon/HexagonHardwareLoops.cpp' l='1884' u='c' c='_ZN12_GLOBAL__N_120HexagonHardwareLoops22createPreheaderForLoopEPN4llvm11MachineLoopE'/>
<use f='llvm/llvm/lib/Target/Hexagon/HexagonHardwareLoops.cpp' l='1969' u='c' c='_ZN12_GLOBAL__N_120HexagonHardwareLoops22createPreheaderForLoopEPN4llvm11MachineLoopE'/>
<use f='llvm/llvm/lib/Target/Hexagon/HexagonHardwareLoops.cpp' l='1981' u='c' c='_ZN12_GLOBAL__N_120HexagonHardwareLoops22createPreheaderForLoopEPN4llvm11MachineLoopE'/>
<def f='llvm/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp' l='385' ll='553' type='bool llvm::HexagonInstrInfo::analyzeBranch(llvm::MachineBasicBlock &amp; MBB, llvm::MachineBasicBlock *&amp; TBB, llvm::MachineBasicBlock *&amp; FBB, SmallVectorImpl&lt;llvm::MachineOperand&gt; &amp; Cond, bool AllowModify) const'/>
<use f='llvm/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp' l='606' u='c' c='_ZNK4llvm16HexagonInstrInfo12insertBranchERNS_17MachineBasicBlockEPS1_S3_NS_8ArrayRefINS_14MachineOperandEEERKNS_8DebugLocEPi'/>
<doc f='llvm/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp' l='370'>/// This function can analyze one/two way branching only and should (mostly) be
/// called by target independent side.
/// First entry is always the opcode of the branching instruction, except when
/// the Cond vector is supposed to be empty, e.g., when AnalyzeBranch fails, a
/// BB with only unconditional jump. Subsequent entries depend upon the opcode,
/// e.g. Jump_c p will have
/// Cond[0] = Jump_c
/// Cond[1] = p
/// HW-loop ENDLOOP:
/// Cond[0] = ENDLOOP
/// Cond[1] = MBB
/// New value jump:
/// Cond[0] = Hexagon::CMPEQri_f_Jumpnv_t_V4 -- specific opcode
/// Cond[1] = R
/// Cond[2] = Imm</doc>
<use f='llvm/llvm/lib/Target/Hexagon/HexagonSplitDouble.cpp' l='488' u='c' c='_ZN12_GLOBAL__N_122HexagonSplitDoubleRegs21collectIndRegsForLoopEPKN4llvm11MachineLoopERSt3setIjSt4lessIjESaIjEE'/>
