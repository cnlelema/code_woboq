<def f='llvm/llvm/include/llvm/ADT/Hashing.h' l='345' ll='348'/>
<def f='llvm/llvm/include/llvm/ADT/Hashing.h' l='354' ll='358'/>
<doc f='llvm/llvm/include/llvm/ADT/Hashing.h' l='333'>/// Trait to indicate whether a type&apos;s bits can be hashed directly.
///
/// A type trait which is true if we want to combine values for hashing by
/// reading the underlying data. It is false if values of this type must
/// first be passed to hash_value, and the resulting hash_codes combined.
//
// FIXME: We want to replace is_integral_or_enum and is_pointer here with
// a predicate which asserts that comparing the underlying storage of two
// values of the type for equality is equivalent to comparing the two values
// for equality. For all the platforms we care about, this holds for integers
// and pointers, but there are platforms where it doesn&apos;t and we would like to
// support user-defined types which happen to satisfy this property.</doc>
<doc f='llvm/llvm/include/llvm/ADT/Hashing.h' l='350'>// Special case std::pair to detect when both types are viable and when there
// is no alignment-derived padding in the pair. This is a bit of a lie because
// std::pair isn&apos;t truly POD, but it&apos;s close enough in all reasonable
// implementations for our use case of hashing the underlying data.</doc>
<inh f='include/c++/7/type_traits' l='69' c='std::integral_constant'/>
<def f='llvm/llvm/unittests/ADT/HashingTest.cpp' l='42'/>
<size>1</size>
