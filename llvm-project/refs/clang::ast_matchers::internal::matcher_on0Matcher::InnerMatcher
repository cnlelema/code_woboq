<use f='llvm/clang/include/clang/ASTMatchers/ASTMatchers.h' l='2917' u='w' c='_ZN5clang12ast_matchers8internal18matcher_on0MatcherC1ERKNS1_7MatcherINS_4ExprEEE'/>
<dec f='llvm/clang/include/clang/ASTMatchers/ASTMatchers.h' l='2917' type='const internal::Matcher&lt;Expr&gt;'/>
<use f='llvm/clang/include/clang/ASTMatchers/ASTMatchers.h' l='2921' u='m' c='_ZNK5clang12ast_matchers8internal18matcher_on0Matcher7matchesERKNS_17CXXMemberCallExprEPNS1_14ASTMatchFinderEPNS1_21BoundNodesTreeBuilderE'/>
<offset>128</offset>
<doc f='llvm/clang/include/clang/ASTMatchers/ASTMatchers.h' l='2898'>/// Matches on the implicit object argument of a member call expression, after
/// stripping off any parentheses or implicit casts.
///
/// Given
/// \code
///   class Y { public: void m(); };
///   Y g();
///   class X : public Y {};
///   void z(Y y, X x) { y.m(); (g()).m(); x.m(); }
/// \endcode
/// cxxMemberCallExpr(on(hasType(cxxRecordDecl(hasName(&quot;Y&quot;)))))
///   matches `y.m()` and `(g()).m()`.
/// cxxMemberCallExpr(on(hasType(cxxRecordDecl(hasName(&quot;X&quot;)))))
///   matches `x.m()`.
/// cxxMemberCallExpr(on(callExpr()))
///   matches `(g()).m()`.
///
/// FIXME: Overload to allow directly matching types?</doc>
