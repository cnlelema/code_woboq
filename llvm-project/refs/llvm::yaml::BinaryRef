<def f='llvm/llvm/include/llvm/ObjectYAML/YAML.h' l='63' ll='95'/>
<size>24</size>
<doc f='llvm/llvm/include/llvm/ObjectYAML/YAML.h' l='23'>/// Specialized YAMLIO scalar type for representing a binary blob.
///
/// A typical use case would be to represent the content of a section in a
/// binary file.
/// This class has custom YAMLIO traits for convenient reading and writing.
/// It renders as a string of hex digits in a YAML file.
/// For example, it might render as `DEADBEEFCAFEBABE` (YAML does not
/// require the quotation marks, so for simplicity when outputting they are
/// omitted).
/// When reading, any string whose content is an even number of hex digits
/// will be accepted.
/// For example, all of the following are acceptable:
/// `DEADBEEF`, `&quot;DeADbEeF&quot;`, `&quot;\x44EADBEEF&quot;` (Note: &apos;\x44&apos; == &apos;D&apos;)
///
/// A significant advantage of using this class is that it never allocates
/// temporary strings or buffers for any of its functionality.
///
/// Example:
///
/// The YAML mapping:
/// \code
/// Foo: DEADBEEFCAFEBABE
/// \endcode
///
/// Could be modeled in YAMLIO by the struct:
/// \code
/// struct FooHolder {
///   BinaryRef Foo;
/// };
/// namespace llvm {
/// namespace yaml {
/// template &lt;&gt;
/// struct MappingTraits&lt;FooHolder&gt; {
///   static void mapping(IO &amp;IO, FooHolder &amp;FH) {
///     IO.mapRequired(&quot;Foo&quot;, FH.Foo);
///   }
/// };
/// } // end namespace yaml
/// } // end namespace llvm
/// \endcode</doc>
<mbr r='llvm::yaml::BinaryRef::Data' o='0' t='ArrayRef&lt;uint8_t&gt;'/>
<mbr r='llvm::yaml::BinaryRef::DataIsHexString' o='128' t='bool'/>
<fun r='_ZN4llvm4yaml9BinaryRefC1Ev'/>
<fun r='_ZN4llvm4yaml9BinaryRefC1ENS_8ArrayRefIhEE'/>
<fun r='_ZN4llvm4yaml9BinaryRefC1ENS_9StringRefE'/>
<fun r='_ZNK4llvm4yaml9BinaryRef11binary_sizeEv'/>
<fun r='_ZNK4llvm4yaml9BinaryRef13writeAsBinaryERNS_11raw_ostreamE'/>
<fun r='_ZNK4llvm4yaml9BinaryRef10writeAsHexERNS_11raw_ostreamE'/>
