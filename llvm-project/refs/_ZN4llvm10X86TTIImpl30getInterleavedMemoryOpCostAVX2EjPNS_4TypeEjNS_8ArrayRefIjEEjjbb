<dec f='llvm/llvm/lib/Target/X86/X86TargetTransformInfo.h' l='169' type='int llvm::X86TTIImpl::getInterleavedMemoryOpCostAVX2(unsigned int Opcode, llvm::Type * VecTy, unsigned int Factor, ArrayRef&lt;unsigned int&gt; Indices, unsigned int Alignment, unsigned int AddressSpace, bool UseMaskForCond = false, bool UseMaskForGaps = false)'/>
<def f='llvm/llvm/lib/Target/X86/X86TargetTransformInfo.cpp' l='3312' ll='3422' type='int llvm::X86TTIImpl::getInterleavedMemoryOpCostAVX2(unsigned int Opcode, llvm::Type * VecTy, unsigned int Factor, ArrayRef&lt;unsigned int&gt; Indices, unsigned int Alignment, unsigned int AddressSpace, bool UseMaskForCond = false, bool UseMaskForGaps = false)'/>
<use f='llvm/llvm/lib/Target/X86/X86TargetTransformInfo.cpp' l='3574' u='c' c='_ZN4llvm10X86TTIImpl26getInterleavedMemoryOpCostEjPNS_4TypeEjNS_8ArrayRefIjEEjjbb'/>
<doc f='llvm/llvm/lib/Target/X86/X86TargetTransformInfo.cpp' l='3300'>// Get estimation for interleaved load/store operations for AVX2.
// \p Factor is the interleaved-access factor (stride) - number of
// (interleaved) elements in the group.
// \p Indices contains the indices for a strided load: when the
// interleaved load has gaps they indicate which elements are used.
// If Indices is empty (or if the number of indices is equal to the size
// of the interleaved-access as given in \p Factor) the access has no gaps.
//
// As opposed to AVX-512, AVX2 does not have generic shuffles that allow
// computing the cost using a generic formula as a function of generic
// shuffles. We therefore use a lookup table instead, filled according to
// the instruction sequences that codegen currently generates.</doc>
