<dec f='llvm/llvm/lib/Target/Mips/Mips16ISelLowering.h' l='41' type='unsigned int llvm::Mips16TargetLowering::getMips16HelperFunctionStubNumber(ArgListTy &amp; Args) const'/>
<def f='llvm/llvm/lib/Target/Mips/Mips16ISelLowering.cpp' l='291' ll='315' type='unsigned int llvm::Mips16TargetLowering::getMips16HelperFunctionStubNumber(ArgListTy &amp; Args) const'/>
<use f='llvm/llvm/lib/Target/Mips/Mips16ISelLowering.cpp' l='371' u='c' c='_ZNK4llvm20Mips16TargetLowering23getMips16HelperFunctionEPNS_4TypeERSt6vectorINS_18TargetLoweringBase12ArgListEntryESaIS5_EERb'/>
<doc f='llvm/llvm/lib/Target/Mips/Mips16ISelLowering.cpp' l='260'>//
// The Mips16 hard float is a crazy quilt inherited from gcc. I have a much
// cleaner way to do all of this but it will have to wait until the traditional
// gcc mechanism is completed.
//
// For Pic, in order for Mips16 code to call Mips32 code which according the abi
// have either arguments or returned values placed in floating point registers,
// we use a set of helper functions. (This includes functions which return type
//  complex which on Mips are returned in a pair of floating point registers).
//
// This is an encoding that we inherited from gcc.
// In Mips traditional O32, N32 ABI, floating point numbers are passed in
// floating point argument registers 1,2 only when the first and optionally
// the second arguments are float (sf) or double (df).
// For Mips16 we are only concerned with the situations where floating point
// arguments are being passed in floating point registers by the ABI, because
// Mips16 mode code cannot execute floating point instructions to load those
// values and hence helper functions are needed.
// The possibilities are (), (sf), (sf, sf), (sf, df), (df), (df, sf), (df, df)
// the helper function suffixs for these are:
//                        0,  1,    5,        9,         2,   6,        10
// this suffix can then be calculated as follows:
// for a given argument Arg:
//     Arg1x, Arg2x = 1 :  Arg is sf
//                    2 :  Arg is df
//                    0:   Arg is neither sf or df
// So this stub is the string for number Arg1x + Arg2x*4.
// However not all numbers between 0 and 10 are possible, we check anyway and
// assert if the impossible exists.
//</doc>
