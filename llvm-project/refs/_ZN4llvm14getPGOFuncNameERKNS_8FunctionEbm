<dec f='llvm/llvm/include/llvm/ProfileData/InstrProf.h' l='166' type='std::string llvm::getPGOFuncName(const llvm::Function &amp; F, bool InLTO = false, uint64_t Version = 5)'/>
<doc f='llvm/llvm/include/llvm/ProfileData/InstrProf.h' l='163'>/// Return the modified name for function \c F suitable to be
/// used the key for profile lookup. Variable \c InLTO indicates if this
/// is called in LTO optimization passes.</doc>
<def f='llvm/llvm/lib/ProfileData/InstrProf.cpp' l='253' ll='274' type='std::string llvm::getPGOFuncName(const llvm::Function &amp; F, bool InLTO = false, uint64_t Version = 5)'/>
<use f='llvm/llvm/lib/ProfileData/InstrProf.cpp' l='342' u='c' c='_ZN4llvm15InstrProfSymtab6createERNS_6ModuleEb'/>
<doc f='llvm/llvm/lib/ProfileData/InstrProf.cpp' l='240'>// Return the PGOFuncName. This function has some special handling when called
// in LTO optimization. The following only applies when calling in LTO passes
// (when \c InLTO is true): LTO&apos;s internalization privatizes many global linkage
// symbols. This happens after value profile annotation, but those internal
// linkage functions should not have a source prefix.
// Additionally, for ThinLTO mode, exported internal functions are promoted
// and renamed. We need to ensure that the original internal PGO name is
// used when computing the GUID that is compared against the profiled GUIDs.
// To differentiate compiler generated internal symbols from original ones,
// PGOFuncName meta data are created and attached to the original internal
// symbols in the value profile annotation step
// (PGOUseFunc::annotateIndirectCallSites). If a symbol does not have the meta
// data, its original linkage must be non-internal.</doc>
<use f='llvm/llvm/unittests/ProfileData/InstrProfTest.cpp' l='917' u='c' c='_ZN12_GLOBAL__N_159MaybeSparseInstrProfTest_instr_prof_symtab_module_test_Test8TestBodyEv'/>
