<dec f='llvm/llvm/include/llvm/Analysis/LoopAccessAnalysis.h' l='377' type='void llvm::RuntimePointerChecking::insert(llvm::Loop * Lp, llvm::Value * Ptr, bool WritePtr, unsigned int DepSetId, unsigned int ASId, const ValueToValueMap &amp; Strides, llvm::PredicatedScalarEvolution &amp; PSE)'/>
<doc f='llvm/llvm/include/llvm/Analysis/LoopAccessAnalysis.h' l='372'>/// Insert a pointer and calculate the start and end SCEVs.
  /// We need \p PSE in order to compute the SCEV expression of the pointer
  /// according to the assumptions that we&apos;ve made during the analysis.
  /// The method might also version the pointer stride according to \p Strides,
  /// and add new predicates to \p PSE.</doc>
<def f='llvm/llvm/lib/Analysis/LoopAccessAnalysis.cpp' l='189' ll='231' type='void llvm::RuntimePointerChecking::insert(llvm::Loop * Lp, llvm::Value * Ptr, bool WritePtr, unsigned int DepSetId, unsigned int ASId, const ValueToValueMap &amp; Strides, llvm::PredicatedScalarEvolution &amp; PSE)'/>
<use f='llvm/llvm/lib/Analysis/LoopAccessAnalysis.cpp' l='688' u='c' c='_ZN12_GLOBAL__N_114AccessAnalysis20createCheckForAccessERN4llvm22RuntimePointerCheckingENS1_14PointerIntPairIPNS1_5ValueELj1EbNS1_21PointerLikeTypeTra7365849'/>
<doc f='llvm/llvm/lib/Analysis/LoopAccessAnalysis.cpp' l='176'>/// Calculate Start and End points of memory access.
/// Let&apos;s assume A is the first access and B is a memory access on N-th loop
/// iteration. Then B is calculated as:
///   B = A + Step*N .
/// Step value may be positive or negative.
/// N is a calculated back-edge taken count:
///     N = (TripCount &gt; 0) ? RoundDown(TripCount -1 , VF) : 0
/// Start and End points are calculated in the following way:
/// Start = UMIN(A, B) ; End = UMAX(A, B) + SizeOfElt,
/// where SizeOfElt is the size of single memory access in bytes.
///
/// There is no conflict when the intervals are disjoint:
/// NoConflict = (P2.Start &gt;= P1.End) || (P1.Start &gt;= P2.End)</doc>
