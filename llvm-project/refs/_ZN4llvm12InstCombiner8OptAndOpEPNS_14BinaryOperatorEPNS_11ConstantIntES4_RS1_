<dec f='llvm/llvm/lib/Transforms/InstCombine/InstCombineInternal.h' l='911' type='llvm::Instruction * llvm::InstCombiner::OptAndOp(llvm::BinaryOperator * Op, llvm::ConstantInt * OpRHS, llvm::ConstantInt * AndRHS, llvm::BinaryOperator &amp; TheAnd)'/>
<def f='llvm/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp' l='117' ll='160' type='llvm::Instruction * llvm::InstCombiner::OptAndOp(llvm::BinaryOperator * Op, llvm::ConstantInt * OpRHS, llvm::ConstantInt * AndRHS, llvm::BinaryOperator &amp; TheAnd)'/>
<use f='llvm/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp' l='1698' u='c' c='_ZN4llvm12InstCombiner8visitAndERNS_14BinaryOperatorE'/>
<doc f='llvm/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp' l='115'>/// This handles expressions of the form ((val OP C1) &amp; C2).  Where
/// the Op parameter is &apos;OP&apos;, OpRHS is &apos;C1&apos;, and AndRHS is &apos;C2&apos;.</doc>
