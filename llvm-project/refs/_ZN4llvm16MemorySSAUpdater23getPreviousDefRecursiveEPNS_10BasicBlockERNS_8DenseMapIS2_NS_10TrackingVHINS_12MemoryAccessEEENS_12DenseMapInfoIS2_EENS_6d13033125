<dec f='llvm/llvm/include/llvm/Analysis/MemorySSAUpdater.h' l='274' type='llvm::MemoryAccess * llvm::MemorySSAUpdater::getPreviousDefRecursive(llvm::BasicBlock * , DenseMap&lt;llvm::BasicBlock *, TrackingVH&lt;llvm::MemoryAccess&gt; &gt; &amp; )'/>
<def f='llvm/llvm/lib/Analysis/MemorySSAUpdater.cpp' l='41' ll='116' type='llvm::MemoryAccess * llvm::MemorySSAUpdater::getPreviousDefRecursive(llvm::BasicBlock * BB, DenseMap&lt;llvm::BasicBlock *, TrackingVH&lt;llvm::MemoryAccess&gt; &gt; &amp; CachedPreviousDef)'/>
<use f='llvm/llvm/lib/Analysis/MemorySSAUpdater.cpp' l='126' u='c' c='_ZN4llvm16MemorySSAUpdater14getPreviousDefEPNS_12MemoryAccessE'/>
<use f='llvm/llvm/lib/Analysis/MemorySSAUpdater.cpp' l='167' u='c' c='_ZN4llvm16MemorySSAUpdater21getPreviousDefFromEndEPNS_10BasicBlockERNS_8DenseMapIS2_NS_10TrackingVHINS_12MemoryAccessEEENS_12DenseMapInfoIS2_EENS_6det7059843'/>
<doc f='llvm/llvm/lib/Analysis/MemorySSAUpdater.cpp' l='32'>// This is the marker algorithm from &quot;Simple and Efficient Construction of
// Static Single Assignment Form&quot;
// The simple, non-marker algorithm places phi nodes at any join
// Here, we place markers, and only place phi nodes if they end up necessary.
// They are only necessary if they break a cycle (IE we recursively visit
// ourselves again), or we discover, while getting the value of the operands,
// that there are two or more definitions needing to be merged.
// This still will leave non-minimal form in the case of irreducible control
// flow, where phi nodes may be in cycles with themselves, but unnecessary.</doc>
