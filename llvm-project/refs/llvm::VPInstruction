<inh f='llvm/llvm/lib/Transforms/Vectorize/VPlanValue.h' l='131' c='llvm::VPUser'/>
<inh f='llvm/llvm/lib/Transforms/Vectorize/VPlan.h' l='568' c='llvm::VPRecipeBase'/>
<def f='llvm/llvm/lib/Transforms/Vectorize/VPlan.h' l='628' ll='699'/>
<size>120</size>
<doc f='llvm/llvm/lib/Transforms/Vectorize/VPlan.h' l='624'>/// This is a concrete Recipe that models a single VPlan-level instruction.
/// While as any Recipe it may generate a sequence of IR instructions when
/// executed, these instructions would always form a single-def expression as
/// the VPInstruction is also a single def-use vertex.</doc>
<mbr r='llvm::VPInstruction::Opcode' o='896' t='OpcodeTy'/>
<fun r='_ZN4llvm13VPInstruction19generateInstructionERNS_16VPTransformStateEj'/>
<fun r='_ZN4llvm13VPInstruction18getUnderlyingInstrEv'/>
<fun r='_ZN4llvm13VPInstruction18setUnderlyingInstrEPNS_11InstructionE'/>
<fun r='_ZN4llvm13VPInstructionC1EjNS_8ArrayRefIPNS_7VPValueEEE'/>
<fun r='_ZN4llvm13VPInstructionC1EjSt16initializer_listIPNS_7VPValueEE'/>
<fun r='_ZN4llvm13VPInstruction7classofEPKNS_7VPValueE'/>
<fun r='_ZNK4llvm13VPInstruction5cloneEv'/>
<fun r='_ZN4llvm13VPInstruction7classofEPKNS_12VPRecipeBaseE'/>
<fun r='_ZNK4llvm13VPInstruction9getOpcodeEv'/>
<fun r='_ZN4llvm13VPInstruction7executeERNS_16VPTransformStateE'/>
<fun r='_ZNK4llvm13VPInstruction5printERNS_11raw_ostreamERKNS_5TwineE'/>
<fun r='_ZNK4llvm13VPInstruction5printERNS_11raw_ostreamE'/>
<fun r='_ZNK4llvm13VPInstruction16mayWriteToMemoryEv'/>
