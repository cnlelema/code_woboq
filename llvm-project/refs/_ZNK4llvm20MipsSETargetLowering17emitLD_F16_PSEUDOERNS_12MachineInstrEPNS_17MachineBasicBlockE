<dec f='llvm/llvm/lib/Target/Mips/MipsSEISelLowering.h' l='152' type='llvm::MachineBasicBlock * llvm::MipsSETargetLowering::emitLD_F16_PSEUDO(llvm::MachineInstr &amp; MI, llvm::MachineBasicBlock * BB) const'/>
<def f='llvm/llvm/lib/Target/Mips/MipsSEISelLowering.cpp' l='3622' ll='3657' type='llvm::MachineBasicBlock * llvm::MipsSETargetLowering::emitLD_F16_PSEUDO(llvm::MachineInstr &amp; MI, llvm::MachineBasicBlock * BB) const'/>
<doc f='llvm/llvm/lib/Target/Mips/MipsSEISelLowering.cpp' l='3609'>// Emit the LD_F16_PSEDUO instruction to load a f16 value into an MSA register.
//
// LD_F16 MSA128F16:$wd, mem_simm10:$addr
// =&gt;
//  lh $rtemp, $addr
//  fill.h $wd, $rtemp
//
// Safety: We can&apos;t use ld.h &amp; co as they over-read from the source.
// Additionally, if the address is not modulo 16, 2 cases can occur:
//  a) Segmentation fault as the load instruction reads from a memory page
//     memory it&apos;s not supposed to.
//  b) The load crosses an implementation specific boundary, requiring OS
//     intervention.</doc>
<doc f='llvm/llvm/lib/Target/Mips/MipsSEISelLowering.h' l='151'>/// Emit the FILL_FW pseudo instruction</doc>
