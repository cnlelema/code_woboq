<def f='llvm/llvm/include/llvm/CodeGen/DIE.h' l='627' ll='695'/>
<ovr f='llvm/llvm/include/llvm/CodeGen/DIE.h' l='700' c='llvm::DIE'/>
<ovr f='llvm/llvm/include/llvm/CodeGen/DIE.h' l='891' c='llvm::DIELoc'/>
<ovr f='llvm/llvm/include/llvm/CodeGen/DIE.h' l='925' c='llvm::DIEBlock'/>
<size>8</size>
<doc f='llvm/llvm/include/llvm/CodeGen/DIE.h' l='612'>/// A list of DIE values.
///
/// This is a singly-linked list, but instead of reversing the order of
/// insertion, we keep a pointer to the back of the list so we can push in
/// order.
///
/// There are two main reasons to choose a linked list over a customized
/// vector-like data structure.
///
///  1. For teardown efficiency, we want DIEs to be BumpPtrAllocated.  Using a
///     linked list here makes this way easier to accomplish.
///  2. Carrying an extra pointer per \a DIEValue isn&apos;t expensive.  45% of DIEs
///     have 2 or fewer values, and 90% have 5 or fewer.  A vector would be
///     over-allocated by 50% on average anyway, the same cost as the
///     linked-list node.</doc>
<mbr r='llvm::DIEValueList::List' o='0' t='ListTy'/>
<fun r='_ZN4llvm12DIEValueList8addValueERNS_20BumpPtrAllocatorImplINS_15MallocAllocatorELm4096ELm4096EEERKNS_8DIEValueE'/>
<fun r='_ZN4llvm12DIEValueList8addValueERNS_20BumpPtrAllocatorImplINS_15MallocAllocatorELm4096ELm4096EEENS_5dwarf9AttributeENS5_4FormEOT_'/>
<fun r='_ZN4llvm12DIEValueList6valuesEv'/>
<fun r='_ZNK4llvm12DIEValueList6valuesEv'/>
