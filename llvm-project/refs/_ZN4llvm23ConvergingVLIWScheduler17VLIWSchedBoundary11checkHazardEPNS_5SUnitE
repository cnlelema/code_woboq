<dec f='llvm/llvm/lib/Target/Hexagon/HexagonMachineScheduler.h' l='195' type='bool llvm::ConvergingVLIWScheduler::VLIWSchedBoundary::checkHazard(llvm::SUnit * SU)'/>
<def f='llvm/llvm/lib/Target/Hexagon/HexagonMachineScheduler.cpp' l='336' ll='345' type='bool llvm::ConvergingVLIWScheduler::VLIWSchedBoundary::checkHazard(llvm::SUnit * SU)'/>
<use f='llvm/llvm/lib/Target/Hexagon/HexagonMachineScheduler.cpp' l='354' u='c' c='_ZN4llvm23ConvergingVLIWScheduler17VLIWSchedBoundary11releaseNodeEPNS_5SUnitEj'/>
<use f='llvm/llvm/lib/Target/Hexagon/HexagonMachineScheduler.cpp' l='436' u='c' c='_ZN4llvm23ConvergingVLIWScheduler17VLIWSchedBoundary14releasePendingEv'/>
<doc f='llvm/llvm/lib/Target/Hexagon/HexagonMachineScheduler.cpp' l='323'>/// Does this SU have a hazard within the current instruction group.
///
/// The scheduler supports two modes of hazard recognition. The first is the
/// ScheduleHazardRecognizer API. It is a fully general hazard recognizer that
/// supports highly complicated in-order reservation tables
/// (ScoreboardHazardRecognizer) and arbitrary target-specific logic.
///
/// The second is a streamlined mechanism that checks for hazards based on
/// simple counters that the scheduler itself maintains. It explicitly checks
/// for instruction dispatch limitations, including the number of micro-ops that
/// can dispatch per cycle.
///
/// TODO: Also check whether the SU must start a new group.</doc>
