<dec f='llvm/clang/include/clang/Tooling/Refactoring/Transformer.h' l='181' type='clang::tooling::RewriteRule clang::tooling::applyFirst(ArrayRef&lt;clang::tooling::RewriteRule&gt; Rules)'/>
<def f='llvm/clang/lib/Tooling/Refactoring/Transformer.cpp' l='160' ll='165' type='clang::tooling::RewriteRule clang::tooling::applyFirst(ArrayRef&lt;clang::tooling::RewriteRule&gt; Rules)'/>
<doc f='llvm/clang/lib/Tooling/Refactoring/Transformer.cpp' l='157'>// Simply gathers the contents of the various rules into a single rule. The
// actual work to combine these into an ordered choice is deferred to matcher
// registration.</doc>
<doc f='llvm/clang/include/clang/Tooling/Refactoring/Transformer.h' l='140'>/// Applies the first rule whose pattern matches; other rules are ignored.
///
/// N.B. All of the rules must use the same kind of matcher (that is, share a
/// base class in the AST hierarchy).  However, this constraint is caused by an
/// implementation detail and should be lifted in the future.
//
// `applyFirst` is like an `anyOf` matcher with an edit action attached to each
// of its cases. Anywhere you&apos;d use `anyOf(m1.bind(&quot;id1&quot;), m2.bind(&quot;id2&quot;))` and
// then dispatch on those ids in your code for control flow, `applyFirst` lifts
// that behavior to the rule level.  So, you can write `applyFirst({makeRule(m1,
// action1), makeRule(m2, action2), ...});`
//
// For example, consider a type `T` with a deterministic serialization function,
// `serialize()`.  For performance reasons, we would like to make it
// non-deterministic.  Therefore, we want to drop the expectation that
// `a.serialize() = b.serialize() iff a = b` (although we&apos;ll maintain
// `deserialize(a.serialize()) = a`).
//
// We have three cases to consider (for some equality function, `eq`):
// ```
// eq(a.serialize(), b.serialize()) --&gt; eq(a,b)
// eq(a, b.serialize())             --&gt; eq(deserialize(a), b)
// eq(a.serialize(), b)             --&gt; eq(a, deserialize(b))
// ```
//
// `applyFirst` allows us to specify each independently:
// ```
// auto eq_fun = functionDecl(...);
// auto method_call = cxxMemberCallExpr(...);
//
// auto two_calls = callExpr(callee(eq_fun), hasArgument(0, method_call),
//                           hasArgument(1, method_call));
// auto left_call =
//     callExpr(callee(eq_fun), callExpr(hasArgument(0, method_call)));
// auto right_call =
//     callExpr(callee(eq_fun), callExpr(hasArgument(1, method_call)));
//
// RewriteRule R = applyFirst({makeRule(two_calls, two_calls_action),
//                             makeRule(left_call, left_call_action),
//                             makeRule(right_call, right_call_action)});
// ```</doc>
<use f='llvm/clang/unittests/Tooling/TransformerTest.cpp' l='457' u='c' c='_ZN12_GLOBAL__N_141TransformerTest_OrderedRuleUnrelated_Test8TestBodyEv'/>
<use f='llvm/clang/unittests/Tooling/TransformerTest.cpp' l='492' u='c' c='_ZN12_GLOBAL__N_139TransformerTest_OrderedRuleRelated_Test8TestBodyEv'/>
<use f='llvm/clang/unittests/Tooling/TransformerTest.cpp' l='517' u='c' c='_ZN12_GLOBAL__N_146TransformerTest_OrderedRuleRelatedSwapped_Test8TestBodyEv'/>
