<dec f='llvm/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp' l='1307' type='int llvm::LoopVectorizationCostModel::computePredInstDiscount(llvm::Instruction * PredInst, ScalarCostsTy &amp; ScalarCosts, unsigned int VF)'/>
<use f='llvm/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp' l='5278' u='c' c='_ZN4llvm26LoopVectorizationCostModel23collectInstsToScalarizeEj'/>
<def f='llvm/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp' l='5286' ll='5399' type='int llvm::LoopVectorizationCostModel::computePredInstDiscount(llvm::Instruction * PredInst, DenseMap&lt;llvm::Instruction *, unsigned int&gt; &amp; ScalarCosts, unsigned int VF)'/>
<doc f='llvm/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp' l='1302'>/// Returns the expected difference in cost from scalarizing the expression
  /// feeding a predicated instruction \p PredInst. The instructions to
  /// scalarize and their scalar costs are collected in \p ScalarCosts. A
  /// non-negative return value implies the expression will be scalarized.
  /// Currently, only single-use chains are considered for scalarization.</doc>
