<dec f='llvm/clang/lib/Format/FormatInternal.h' l='73' type='std::pair&lt;tooling::Replacements, unsigned int&gt; clang::format::internal::reformat(const clang::format::FormatStyle &amp; Style, llvm::StringRef Code, ArrayRef&lt;tooling::Range&gt; Ranges, unsigned int FirstStartColumn, unsigned int NextStartColumn, unsigned int LastStartColumn, llvm::StringRef FileName, clang::format::FormattingAttemptStatus * Status)'/>
<use f='llvm/clang/lib/Format/ContinuationIndenter.cpp' l='1573' u='c' c='_ZN5clang6format20ContinuationIndenter24reformatRawStringLiteralERKNS0_11FormatTokenERNS0_9LineStateERKNS0_11FormatStyleEbb'/>
<doc f='llvm/clang/lib/Format/FormatInternal.h' l='26'>/// Reformats the given \p Ranges in the code fragment \p Code.
///
/// A fragment of code could conceptually be surrounded by other code that might
/// constrain how that fragment is laid out.
/// For example, consider the fragment of code between &apos;R&quot;(&apos; and &apos;)&quot;&apos;,
/// exclusive, in the following code:
///
/// void outer(int x) {
///   string inner = R&quot;(name: data
///                     ^ FirstStartColumn
///     value: {
///       x: 1
///     ^ NextStartColumn
///     }
///   )&quot;;
///   ^ LastStartColumn
/// }
///
/// The outer code can influence the inner fragment as follows:
///   * \p FirstStartColumn specifies the column at which \p Code starts.
///   * \p NextStartColumn specifies the additional indent dictated by the
///     surrounding code. It is applied to the rest of the lines of \p Code.
///   * \p LastStartColumn specifies the column at which the last line of
///     \p Code should end, in case the last line is an empty line.
///
///     In the case where the last line of the fragment contains content,
///     the fragment ends at the end of that content and \p LastStartColumn is
///     not taken into account, for example in:
///
///     void block() {
///       string inner = R&quot;(name: value)&quot;;
///     }
///
/// Each range is extended on either end to its next bigger logic unit, i.e.
/// everything that might influence its formatting or might be influenced by its
/// formatting.
///
/// Returns a pair P, where:
///   * P.first are the ``Replacements`` necessary to make all \p Ranges comply
///     with \p Style.
///   * P.second is the penalty induced by formatting the fragment \p Code.
///     If the formatting of the fragment doesn&apos;t have a notion of penalty,
///     returns 0.
///
/// If ``Status`` is non-null, its value will be populated with the status of
/// this formatting attempt. See \c FormattingAttemptStatus.</doc>
<def f='llvm/clang/lib/Format/Format.cpp' l='2248' ll='2312' type='std::pair&lt;tooling::Replacements, unsigned int&gt; clang::format::internal::reformat(const clang::format::FormatStyle &amp; Style, llvm::StringRef Code, ArrayRef&lt;tooling::Range&gt; Ranges, unsigned int FirstStartColumn, unsigned int NextStartColumn, unsigned int LastStartColumn, llvm::StringRef FileName, clang::format::FormattingAttemptStatus * Status)'/>
<use f='llvm/clang/lib/Format/Format.cpp' l='2319' u='c' c='_ZN5clang6format8reformatERKNS0_11FormatStyleEN4llvm9StringRefENS4_8ArrayRefINS_7tooling5RangeEEES5_PNS0_23FormattingAttemptStatusE'/>
