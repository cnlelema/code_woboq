<dec f='llvm/llvm/lib/Transforms/InstCombine/InstCombineInternal.h' l='409' type='bool llvm::InstCombiner::shouldChangeType(unsigned int FromBitWidth, unsigned int ToBitWidth) const'/>
<def f='llvm/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp' l='159' ll='180' type='bool llvm::InstCombiner::shouldChangeType(unsigned int FromWidth, unsigned int ToWidth) const'/>
<use f='llvm/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp' l='195' u='c' c='_ZNK4llvm12InstCombiner16shouldChangeTypeEPNS_4TypeES2_'/>
<use f='llvm/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp' l='2601' u='c' c='_ZN4llvm12InstCombiner15visitSwitchInstERNS_10SwitchInstE'/>
<doc f='llvm/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp' l='150'>/// Return true if it is desirable to convert an integer computation from a
/// given bit width to a new bit width.
/// We don&apos;t want to convert from a legal to an illegal type or from a smaller
/// to a larger illegal type. A width of &apos;1&apos; is always treated as a legal type
/// because i1 is a fundamental type in IR, and there are many specialized
/// optimizations for i1 types. Widths of 8, 16 or 32 are equally treated as
/// legal to convert to, in order to open up more combining opportunities.
/// NOTE: this treats i8, i16 and i32 specially, due to them being so common
/// from frontend languages.</doc>
