<dec f='llvm/llvm/include/llvm/Object/MachO.h' l='85' type='void llvm::object::ExportEntry::moveNext()'/>
<def f='llvm/llvm/lib/Object/MachOObjectFile.cpp' l='3057' ll='3084' type='void llvm::object::ExportEntry::moveNext()'/>
<doc f='llvm/llvm/lib/Object/MachOObjectFile.cpp' l='3042'>// We have a trie data structure and need a way to walk it that is compatible
// with the C++ iterator model. The solution is a non-recursive depth first
// traversal where the iterator contains a stack of parent nodes along with a
// string that is the accumulation of all edge strings along the parent chain
// to this point.
//
// There is one &quot;export&quot; node for each exported symbol.  But because some
// symbols may be a prefix of another symbol (e.g. _dup and _dup2), an export
// node may have child nodes too.
//
// The algorithm for moveNext() is to keep moving down the leftmost unvisited
// child until hitting a node with no children (which is an export node or
// else the trie is malformed). On the way down, each node is pushed on the
// stack ivar.  If there is no more ways down, it pops up one and tries to go
// down a sibling path until a childless node is reached.</doc>
