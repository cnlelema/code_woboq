<def f='llvm/llvm/include/llvm/MC/MCInstrAnalysis.h' l='137' ll='140' type='bool llvm::MCInstrAnalysis::isDependencyBreaking(const llvm::MCInst &amp; MI, llvm::APInt &amp; Mask, unsigned int CPUID) const'/>
<doc f='llvm/llvm/include/llvm/MC/MCInstrAnalysis.h' l='117'>/// Returns true if MI is a dependency breaking instruction for the
  /// subtarget associated with CPUID .
  ///
  /// The value computed by a dependency breaking instruction is not dependent
  /// on the inputs. An example of dependency breaking instruction on X86 is
  /// `XOR %eax, %eax`.
  ///
  /// If MI is a dependency breaking instruction for subtarget CPUID, then Mask
  /// can be inspected to identify independent operands.
  ///
  /// Essentially, each bit of the mask corresponds to an input operand.
  /// Explicit operands are laid out first in the mask; implicit operands follow
  /// explicit operands. Bits are set for operands that are independent.
  ///
  /// Note that the number of bits in Mask may not be equivalent to the sum of
  /// explicit and implicit operands in MI. Operands that don&apos;t have a
  /// corresponding bit in Mask are assumed &quot;not independente&quot;.
  ///
  /// The only exception is for when Mask is all zeroes. That means: explicit
  /// input operands of MI are independent.</doc>
