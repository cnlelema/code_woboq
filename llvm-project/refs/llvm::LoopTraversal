<def f='llvm/llvm/include/llvm/CodeGen/LoopTraversal.h' l='65' ll='111'/>
<size>80</size>
<doc f='llvm/llvm/include/llvm/CodeGen/LoopTraversal.h' l='28'>/// This class provides the basic blocks traversal order used by passes like
/// ReachingDefAnalysis and ExecutionDomainFix.
/// It identifies basic blocks that are part of loops and should to be visited
/// twice and returns efficient traversal order for all the blocks.
///
/// We want to visit every instruction in every basic block in order to update
/// it&apos;s execution domain or collect clearance information. However, for the
/// clearance calculation, we need to know clearances from all predecessors
/// (including any backedges), therfore we need to visit some blocks twice.
/// As an example, consider the following loop.
///
///
///    PH -&gt; A -&gt; B (xmm&lt;Undef&gt; -&gt; xmm&lt;Def&gt;) -&gt; C -&gt; D -&gt; EXIT
///          ^                                  |
///          +----------------------------------+
///
/// The iteration order this pass will return is as follows:
/// Optimized: PH A B C A&apos; B&apos; C&apos; D
///
/// The basic block order is constructed as follows:
/// Once we finish processing some block, we update the counters in MBBInfos
/// and re-process any successors that are now &apos;done&apos;.
/// We call a block that is ready for its final round of processing `done`
/// (isBlockDone), e.g. when all predecessor information is known.
///
/// Note that a naive traversal order would be to do two complete passes over
/// all basic blocks/instructions, the first for recording clearances, the
/// second for updating clearance based on backedges.
/// However, for functions without backedges, or functions with a lot of
/// straight-line code, and a small loop, that would be a lot of unnecessary
/// work (since only the BBs that are part of the loop require two passes).
///
/// E.g., the naive iteration order for the above exmple is as follows:
/// Naive: PH A B C D A&apos; B&apos; C&apos; D&apos;
///
/// In the optimized approach we avoid processing D twice, because we
/// can entirely process the predecessors before getting to D.</doc>
<mbr r='llvm::LoopTraversal::MBBInfos' o='0' t='MBBInfoMap'/>
<fun r='_ZN4llvm13LoopTraversalC1Ev'/>
<fun r='_ZN4llvm13LoopTraversal8traverseERNS_15MachineFunctionE'/>
<fun r='_ZN4llvm13LoopTraversal11isBlockDoneEPNS_17MachineBasicBlockE'/>
