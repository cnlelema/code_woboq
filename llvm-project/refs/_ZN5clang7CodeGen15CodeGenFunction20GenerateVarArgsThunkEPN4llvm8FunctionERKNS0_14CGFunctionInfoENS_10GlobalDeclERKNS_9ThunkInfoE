<dec f='llvm/clang/lib/CodeGen/CodeGenFunction.h' l='1886' type='llvm::Function * clang::CodeGen::CodeGenFunction::GenerateVarArgsThunk(llvm::Function * Fn, const clang::CodeGen::CGFunctionInfo &amp; FnInfo, clang::GlobalDecl GD, const clang::ThunkInfo &amp; Thunk)'/>
<def f='llvm/clang/lib/CodeGen/CGVTables.cpp' l='155' ll='222' type='llvm::Function * clang::CodeGen::CodeGenFunction::GenerateVarArgsThunk(llvm::Function * Fn, const clang::CodeGen::CGFunctionInfo &amp; FnInfo, clang::GlobalDecl GD, const clang::ThunkInfo &amp; Thunk)'/>
<use f='llvm/clang/lib/CodeGen/CGVTables.cpp' l='560' u='c' c='_ZN5clang7CodeGen14CodeGenVTables14maybeEmitThunkENS_10GlobalDeclERKNS_9ThunkInfoEb'/>
<doc f='llvm/clang/lib/CodeGen/CGVTables.cpp' l='139'>// This function does roughly the same thing as GenerateThunk, but in a
// very different way, so that va_start and va_end work correctly.
// FIXME: This function assumes &quot;this&quot; is the first non-sret LLVM argument of
//        a function, and that there is an alloca built in the entry block
//        for all accesses to &quot;this&quot;.
// FIXME: This function assumes there is only one &quot;ret&quot; statement per function.
// FIXME: Cloning isn&apos;t correct in the presence of indirect goto!
// FIXME: This implementation of thunks bloats codesize by duplicating the
//        function definition.  There are alternatives:
//        1. Add some sort of stub support to LLVM for cases where we can
//           do a this adjustment, then a sibcall.
//        2. We could transform the definition to take a va_list instead of an
//           actual variable argument list, then have the thunks (including a
//           no-op thunk for the regular definition) call va_start/va_end.
//           There&apos;s a bit of per-call overhead for this solution, but it&apos;s
//           better for codesize if the definition is long.</doc>
