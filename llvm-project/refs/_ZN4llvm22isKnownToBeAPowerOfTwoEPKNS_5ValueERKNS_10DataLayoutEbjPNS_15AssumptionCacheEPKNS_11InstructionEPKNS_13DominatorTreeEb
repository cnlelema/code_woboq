<dec f='llvm/llvm/include/llvm/Analysis/ValueTracking.h' l='89' type='bool llvm::isKnownToBeAPowerOfTwo(const llvm::Value * V, const llvm::DataLayout &amp; DL, bool OrZero = false, unsigned int Depth = 0, llvm::AssumptionCache * AC = nullptr, const llvm::Instruction * CxtI = nullptr, const llvm::DominatorTree * DT = nullptr, bool UseInstrInfo = true)'/>
<doc f='llvm/llvm/include/llvm/Analysis/ValueTracking.h' l='84'>/// Return true if the given value is known to have exactly one bit set when
  /// defined. For vectors return true if every element is known to be a power
  /// of two when defined. Supports values with integer or pointer type and
  /// vectors of integers. If &apos;OrZero&apos; is set, then return true if the given
  /// value is either a power of two or zero.</doc>
<use f='llvm/llvm/lib/Analysis/InstructionSimplify.cpp' l='1841' u='c' c='_ZL15SimplifyAndInstPN4llvm5ValueES1_RKNS_13SimplifyQueryEj'/>
<use f='llvm/llvm/lib/Analysis/InstructionSimplify.cpp' l='1844' u='c' c='_ZL15SimplifyAndInstPN4llvm5ValueES1_RKNS_13SimplifyQueryEj'/>
<def f='llvm/llvm/lib/Analysis/ValueTracking.cpp' l='230' ll='236' type='bool llvm::isKnownToBeAPowerOfTwo(const llvm::Value * V, const llvm::DataLayout &amp; DL, bool OrZero = false, unsigned int Depth = 0, llvm::AssumptionCache * AC = nullptr, const llvm::Instruction * CxtI = nullptr, const llvm::DominatorTree * DT = nullptr, bool UseInstrInfo = true)'/>
<use f='llvm/llvm/lib/Transforms/InstCombine/InstCombineInternal.h' l='675' u='c' c='_ZN4llvm12InstCombiner22isKnownToBeAPowerOfTwoEPKNS_5ValueEbjPKNS_11InstructionE'/>
