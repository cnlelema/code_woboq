<def f='llvm/llvm/include/llvm/ADT/PointerSumType.h' l='82' ll='91'/>
<doc f='llvm/llvm/include/llvm/ADT/PointerSumType.h' l='73'>// We keep both the raw value and the min tag value&apos;s pointer in a union. When
  // the minimum tag value is zero, this allows code below to cleanly expose the
  // address of the zero-tag pointer instead of just the zero-tag pointer
  // itself. This is especially useful when building `ArrayRef`s out of a single
  // pointer. However, we have to carefully access the union due to the active
  // member potentially changing. When we *store* a new value, we directly
  // access the union to allow us to store using the obvious types. However,
  // when we *read* a value, we copy the underlying storage out to avoid relying
  // on one member or the other being active.</doc>
<fun r='_ZN4llvm14PointerSumType8StorageTC1Ev'/>
<mbr r='llvm::PointerSumType::StorageT::Value' t='uintptr_t'/>
<mbr r='llvm::PointerSumType::StorageT::MinTagPointer' t='typename HelperT::template HelperT::Lookup&lt;HelperT::MinTag&gt;::PointerT'/>
