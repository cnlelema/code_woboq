<dec f='llvm/llvm/include/llvm/MC/MCDisassembler/MCExternalSymbolizer.h' l='50' type='void llvm::MCExternalSymbolizer::tryAddingPcLoadReferenceComment(llvm::raw_ostream &amp; CommentStream, int64_t Value, uint64_t Address)'/>
<inh f='llvm/llvm/include/llvm/MC/MCDisassembler/MCSymbolizer.h' l='75' c='_ZN4llvm12MCSymbolizer31tryAddingPcLoadReferenceCommentERNS_11raw_ostreamElm'/>
<def f='llvm/llvm/lib/MC/MCDisassembler/MCExternalSymbolizer.cpp' l='156' ll='187' type='void llvm::MCExternalSymbolizer::tryAddingPcLoadReferenceComment(llvm::raw_ostream &amp; cStream, int64_t Value, uint64_t Address)'/>
<doc f='llvm/llvm/lib/MC/MCDisassembler/MCExternalSymbolizer.cpp' l='146'>// This function tries to add a comment as to what is being referenced by a load
// instruction with the base register that is the Pc.  These can often be values
// in a literal pool near the Address of the instruction. The Address of the
// instruction and its immediate Value are used as a possible literal pool entry.
// The SymbolLookUp call back will return the name of a symbol referenced by the
// literal pool&apos;s entry if the referenced address is that of a symbol. Or it
// will return a pointer to a literal &apos;C&apos; string if the referenced address of
// the literal pool&apos;s entry is an address into a section with C string literals.
// Or if the reference is to an Objective-C data structure it will return a
// specific reference type for it and a string.</doc>
