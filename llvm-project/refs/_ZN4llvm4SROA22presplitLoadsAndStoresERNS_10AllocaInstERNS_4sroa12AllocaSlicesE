<dec f='llvm/llvm/include/llvm/Transforms/Scalar/SROA.h' l='125' type='bool llvm::SROA::presplitLoadsAndStores(llvm::AllocaInst &amp; AI, sroa::AllocaSlices &amp; AS)'/>
<def f='llvm/llvm/lib/Transforms/Scalar/SROA.cpp' l='3609' ll='4082' type='bool llvm::SROA::presplitLoadsAndStores(llvm::AllocaInst &amp; AI, llvm::sroa::AllocaSlices &amp; AS)'/>
<use f='llvm/llvm/lib/Transforms/Scalar/SROA.cpp' l='4246' u='c' c='_ZN4llvm4SROA11splitAllocaERNS_10AllocaInstERNS_4sroa12AllocaSlicesE'/>
<doc f='llvm/llvm/lib/Transforms/Scalar/SROA.cpp' l='3579'>/// Pre-split loads and stores to simplify rewriting.
///
/// We want to break up the splittable load+store pairs as much as
/// possible. This is important to do as a preprocessing step, as once we
/// start rewriting the accesses to partitions of the alloca we lose the
/// necessary information to correctly split apart paired loads and stores
/// which both point into this alloca. The case to consider is something like
/// the following:
///
///   %a = alloca [12 x i8]
///   %gep1 = getelementptr [12 x i8]* %a, i32 0, i32 0
///   %gep2 = getelementptr [12 x i8]* %a, i32 0, i32 4
///   %gep3 = getelementptr [12 x i8]* %a, i32 0, i32 8
///   %iptr1 = bitcast i8* %gep1 to i64*
///   %iptr2 = bitcast i8* %gep2 to i64*
///   %fptr1 = bitcast i8* %gep1 to float*
///   %fptr2 = bitcast i8* %gep2 to float*
///   %fptr3 = bitcast i8* %gep3 to float*
///   store float 0.0, float* %fptr1
///   store float 1.0, float* %fptr2
///   %v = load i64* %iptr1
///   store i64 %v, i64* %iptr2
///   %f1 = load float* %fptr2
///   %f2 = load float* %fptr3
///
/// Here we want to form 3 partitions of the alloca, each 4 bytes large, and
/// promote everything so we recover the 2 SSA values that should have been
/// there all along.
///
/// \returns true if any changes are made.</doc>
