<dec f='llvm/llvm/lib/Target/AMDGPU/AMDGPURegisterBankInfo.h' l='40' type='void llvm::AMDGPURegisterBankInfo::executeInWaterfallLoop(llvm::MachineInstr &amp; MI, llvm::MachineRegisterInfo &amp; MRI, ArrayRef&lt;unsigned int&gt; OpIndices) const'/>
<def f='llvm/llvm/lib/Target/AMDGPU/AMDGPURegisterBankInfo.cpp' l='435' ll='719' type='void llvm::AMDGPURegisterBankInfo::executeInWaterfallLoop(llvm::MachineInstr &amp; MI, llvm::MachineRegisterInfo &amp; MRI, ArrayRef&lt;unsigned int&gt; OpIndices) const'/>
<use f='llvm/llvm/lib/Target/AMDGPU/AMDGPURegisterBankInfo.cpp' l='831' u='c' c='_ZNK4llvm22AMDGPURegisterBankInfo16applyMappingImplERKNS_16RegisterBankInfo14OperandsMapperE'/>
<doc f='llvm/llvm/lib/Target/AMDGPU/AMDGPURegisterBankInfo.cpp' l='417'>/// Legalize instruction \p MI where operands in \p OpIndices must be SGPRs. If
/// any of the required SGPR operands are VGPRs, perform a waterfall loop to
/// execute the instruction for each unique combination of values in all lanes
/// in the wave. The block will be split such that rest of the instructions are
/// moved to a new block.
///
/// Essentially performs this loop:
//
/// Save Execution Mask
/// For (Lane : Wavefront) {
///   Enable Lane, Disable all other lanes
///   SGPR = read SGPR value for current lane from VGPR
///   VGPRResult[Lane] = use_op SGPR
/// }
/// Restore Execution Mask
///
/// There is additional complexity to try for compare values to identify the
/// unique values used.</doc>
