<dec f='llvm/llvm/include/llvm/CodeGen/TargetInstrInfo.h' l='317' type='bool llvm::TargetInstrInfo::getStackSlotRange(const llvm::TargetRegisterClass * RC, unsigned int SubIdx, unsigned int &amp; Size, unsigned int &amp; Offset, const llvm::MachineFunction &amp; MF) const'/>
<doc f='llvm/llvm/include/llvm/CodeGen/TargetInstrInfo.h' l='304'>/// Compute the size in bytes and offset within a stack slot of a spilled
  /// register or subregister.
  ///
  /// \param [out] Size in bytes of the spilled value.
  /// \param [out] Offset in bytes within the stack slot.
  /// \returns true if both Size and Offset are successfully computed.
  ///
  /// Not all subregisters have computable spill slots. For example,
  /// subregisters registers may not be byte-sized, and a pair of discontiguous
  /// subregisters has no single offset.
  ///
  /// Targets with nontrivial bigendian implementations may need to override
  /// this, particularly to support spilled vector registers.</doc>
<use f='llvm/llvm/lib/CodeGen/LiveDebugVariables.cpp' l='1179' u='c' c='_ZN12_GLOBAL__N_19UserValue16rewriteLocationsERN4llvm10VirtRegMapERKNS1_15MachineFunctionERKNS1_15TargetInstrInfoERKNS1_18TargetRegisterInfoERNS1_8Den6267754'/>
<def f='llvm/llvm/lib/CodeGen/TargetInstrInfo.cpp' l='371' ll='399' type='bool llvm::TargetInstrInfo::getStackSlotRange(const llvm::TargetRegisterClass * RC, unsigned int SubIdx, unsigned int &amp; Size, unsigned int &amp; Offset, const llvm::MachineFunction &amp; MF) const'/>
<use f='llvm/llvm/lib/CodeGen/TargetInstrInfo.cpp' l='511' u='c' c='_ZL14foldPatchpointRN4llvm15MachineFunctionERNS_12MachineInstrENS_8ArrayRefIjEEiRKNS_15TargetInstrInfoE'/>
