<dec f='llvm/llvm/lib/Target/Hexagon/HexagonSubtarget.h' l='78' type='bool llvm::HexagonSubtarget::CallMutation::shouldTFRICallBind(const llvm::HexagonInstrInfo &amp; HII, const llvm::SUnit &amp; Inst1, const llvm::SUnit &amp; Inst2) const'/>
<def f='llvm/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp' l='180' ll='190' type='bool llvm::HexagonSubtarget::CallMutation::shouldTFRICallBind(const llvm::HexagonInstrInfo &amp; HII, const llvm::SUnit &amp; Inst1, const llvm::SUnit &amp; Inst2) const'/>
<use f='llvm/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp' l='214' u='c' c='_ZN4llvm16HexagonSubtarget12CallMutation5applyEPNS_17ScheduleDAGInstrsE'/>
<doc f='llvm/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp' l='173'>// Check if a call and subsequent A2_tfrpi instructions should maintain
// scheduling affinity. We are looking for the TFRI to be consumed in
// the next instruction. This should help reduce the instances of
// double register pairs being allocated and scheduled before a call
// when not used until after the call. This situation is exacerbated
// by the fact that we allocate the pair from the callee saves list,
// leading to excess spills and restores.</doc>
