<dec f='llvm/llvm/include/llvm/Analysis/DependenceAnalysis.h' l='579' type='const llvm::SCEV * llvm::DependenceInfo::collectUpperBound(const llvm::Loop * l, llvm::Type * T) const'/>
<def f='llvm/llvm/lib/Analysis/DependenceAnalysis.cpp' l='1070' ll='1076' type='const llvm::SCEV * llvm::DependenceInfo::collectUpperBound(const llvm::Loop * L, llvm::Type * T) const'/>
<use f='llvm/llvm/lib/Analysis/DependenceAnalysis.cpp' l='1083' u='c' c='_ZNK4llvm14DependenceInfo25collectConstantUpperBoundEPKNS_4LoopEPNS_4TypeE'/>
<use f='llvm/llvm/lib/Analysis/DependenceAnalysis.cpp' l='1166' u='c' c='_ZNK4llvm14DependenceInfo13strongSIVtestEPKNS_4SCEVES3_S3_PKNS_4LoopEjRNS_14FullDependenceERNS0_10ConstraintE'/>
<use f='llvm/llvm/lib/Analysis/DependenceAnalysis.cpp' l='1344' u='c' c='_ZNK4llvm14DependenceInfo19weakCrossingSIVtestEPKNS_4SCEVES3_S3_PKNS_4LoopEjRNS_14FullDependenceERNS0_10ConstraintERS3_'/>
<use f='llvm/llvm/lib/Analysis/DependenceAnalysis.cpp' l='1742' u='c' c='_ZNK4llvm14DependenceInfo18weakZeroSrcSIVtestEPKNS_4SCEVES3_S3_PKNS_4LoopEjRNS_14FullDependenceERNS0_10ConstraintE'/>
<use f='llvm/llvm/lib/Analysis/DependenceAnalysis.cpp' l='1851' u='c' c='_ZNK4llvm14DependenceInfo18weakZeroDstSIVtestEPKNS_4SCEVES3_S3_PKNS_4LoopEjRNS_14FullDependenceERNS0_10ConstraintE'/>
<use f='llvm/llvm/lib/Analysis/DependenceAnalysis.cpp' l='2049' u='c' c='_ZNK4llvm14DependenceInfo16symbolicRDIVtestEPKNS_4SCEVES3_S3_S3_PKNS_4LoopES6_'/>
<use f='llvm/llvm/lib/Analysis/DependenceAnalysis.cpp' l='2050' u='c' c='_ZNK4llvm14DependenceInfo16symbolicRDIVtestEPKNS_4SCEVES3_S3_S3_PKNS_4LoopES6_'/>
<use f='llvm/llvm/lib/Analysis/DependenceAnalysis.cpp' l='2929' u='c' c='_ZNK4llvm14DependenceInfo16collectCoeffInfoEPKNS_4SCEVEbRS3_'/>
<doc f='llvm/llvm/lib/Analysis/DependenceAnalysis.cpp' l='1063'>// All subscripts are all the same type.
// Loop bound may be smaller (e.g., a char).
// Should zero extend loop bound, since it&apos;s always &gt;= 0.
// This routine collects upper bound and extends or truncates if needed.
// Truncating is safe when subscripts are known not to wrap. Cases without
// nowrap flags should have been rejected earlier.
// Return null if no bound available.</doc>
<doc f='llvm/llvm/include/llvm/Analysis/DependenceAnalysis.h' l='574'>/// collectUpperBound - All subscripts are the same type (on my machine,
    /// an i64). The loop bound may be a smaller type. collectUpperBound
    /// find the bound, if available, and zero extends it to the Type T.
    /// (I zero extend since the bound should always be &gt;= 0.)
    /// If no upper bound is available, return NULL.</doc>
