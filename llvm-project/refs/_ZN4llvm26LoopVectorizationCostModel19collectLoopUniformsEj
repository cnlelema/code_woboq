<use f='llvm/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp' l='1077' u='c' c='_ZN4llvm26LoopVectorizationCostModel25collectUniformsAndScalarsEj'/>
<dec f='llvm/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp' l='1319' type='void llvm::LoopVectorizationCostModel::collectLoopUniforms(unsigned int VF)'/>
<def f='llvm/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp' l='4464' ll='4639' type='void llvm::LoopVectorizationCostModel::collectLoopUniforms(unsigned int VF)'/>
<doc f='llvm/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp' l='1310'>/// Collect the instructions that are uniform after vectorization. An
  /// instruction is uniform if we represent it with a single scalar value in
  /// the vectorized loop corresponding to each vector iteration. Examples of
  /// uniform instructions include pointer operands of consecutive or
  /// interleaved memory accesses. Note that although uniformity implies an
  /// instruction will be scalar, the reverse is not true. In general, a
  /// scalarized instruction will be represented by VF scalar values in the
  /// vectorized loop, each corresponding to an iteration of the original
  /// scalar loop.</doc>
