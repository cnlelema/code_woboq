<def f='llvm/llvm/include/llvm/MC/MCParser/MCTargetAsmParser.h' l='169' ll='182'/>
<size>4</size>
<doc f='llvm/llvm/include/llvm/MC/MCParser/MCTargetAsmParser.h' l='143'>// When an operand is parsed, the assembler will try to iterate through a set of
// possible operand classes that the operand might match and call the
// corresponding PredicateMethod to determine that.
//
// If there are two AsmOperands that would give a specific diagnostic if there
// is no match, there is currently no mechanism to distinguish which operand is
// a closer match. The DiagnosticPredicate distinguishes between &apos;completely
// no match&apos; and &apos;near match&apos;, so the assembler can decide whether to give a
// specific diagnostic, or use &apos;InvalidOperand&apos; and continue to find a
// &apos;better matching&apos; diagnostic.
//
// For example:
//    opcode opnd0, onpd1, opnd2
//
// where:
//    opnd2 could be an &apos;immediate of range [-8, 7]&apos;
//    opnd2 could be a  &apos;register + shift/extend&apos;.
//
// If opnd2 is a valid register, but with a wrong shift/extend suffix, it makes
// little sense to give a diagnostic that the operand should be an immediate
// in range [-8, 7].
//
// This is a light-weight alternative to the &apos;NearMissInfo&apos; approach
// below which collects *all* possible diagnostics. This alternative
// is optional and fully backward compatible with existing
// PredicateMethods that return a &apos;bool&apos; (match or no match).</doc>
<mbr r='llvm::DiagnosticPredicate::Type' o='0' t='llvm::DiagnosticPredicateTy'/>
<fun r='_ZN4llvm19DiagnosticPredicateC1Eb'/>
<fun r='_ZN4llvm19DiagnosticPredicateC1ENS_21DiagnosticPredicateTyE'/>
<fun r='_ZN4llvm19DiagnosticPredicateC1ERKS0_'/>
<fun r='_ZNK4llvm19DiagnosticPredicatecvbEv'/>
<fun r='_ZNK4llvm19DiagnosticPredicate7isMatchEv'/>
<fun r='_ZNK4llvm19DiagnosticPredicate11isNearMatchEv'/>
<fun r='_ZNK4llvm19DiagnosticPredicate9isNoMatchEv'/>
