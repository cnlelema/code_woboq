<inh f='llvm/llvm/include/llvm/Support/ScaledNumber.h' l='419' c='llvm::ScaledNumberBase'/>
<def f='llvm/llvm/include/llvm/Support/ScaledNumber.h' l='492' ll='715'/>
<doc f='llvm/llvm/include/llvm/Support/ScaledNumber.h' l='445'>/// Simple representation of a scaled number.
///
/// ScaledNumber is a number represented by digits and a scale.  It uses simple
/// saturation arithmetic and every operation is well-defined for every value.
/// It&apos;s somewhat similar in behaviour to a soft-float, but is *not* a
/// replacement for one.  If you&apos;re doing numerics, look at \a APFloat instead.
/// Nevertheless, we&apos;ve found these semantics useful for modelling certain cost
/// metrics.
///
/// The number is split into a signed scale and unsigned digits.  The number
/// represented is \c getDigits()*2^getScale().  In this way, the digits are
/// much like the mantissa in the x87 long double, but there is no canonical
/// form so the same number can be represented by many bit representations.
///
/// ScaledNumber is templated on the underlying integer type for digits, which
/// is expected to be unsigned.
///
/// Unlike APFloat, ScaledNumber does not model architecture floating point
/// behaviour -- while this might make it a little faster and easier to reason
/// about, it certainly makes it more dangerous for general numerics.
///
/// ScaledNumber is totally ordered.  However, there is no canonical form, so
/// there are multiple representations of most scalars.  E.g.:
///
///     ScaledNumber(8u, 0) == ScaledNumber(4u, 1)
///     ScaledNumber(4u, 1) == ScaledNumber(2u, 2)
///     ScaledNumber(2u, 2) == ScaledNumber(1u, 3)
///
/// ScaledNumber implements most arithmetic operations.  Precision is kept
/// where possible.  Uses simple saturation arithmetic, so that operations
/// saturate to 0.0 or getLargest() rather than under or overflowing.  It has
/// some extra arithmetic for unit inversion.  0.0/0.0 is defined to be 0.0.
/// Any other division by 0.0 is defined to be getLargest().
///
/// As a convenience for modifying the exponent, left and right shifting are
/// both implemented, and both interpret negative shifts as positive shifts in
/// the opposite direction.
///
/// Scales are limited to the range accepted by x87 long double.  This makes
/// it trivial to add functionality to convert to APFloat (this is already
/// relied on for the implementation of printing).
///
/// Possible (and conflicting) future directions:
///
///  1. Turn this into a wrapper around \a APFloat.
///  2. Share the algorithm implementations with \a APFloat.
///  3. Allow \a ScaledNumber to represent a signed number.</doc>
<smbr r='llvm::ScaledNumber::Width' t='const int'/>
<mbr r='llvm::ScaledNumber::Digits' t='DigitsType'/>
<mbr r='llvm::ScaledNumber::Scale' t='int16_t'/>
<fun r='_ZN4llvm12ScaledNumberC1Ev'/>
<fun r='_ZN4llvm12ScaledNumberC1ET_s'/>
<fun r='_ZN4llvm12ScaledNumberC1ERKSt4pairIT_sE'/>
<fun r='_ZN4llvm12ScaledNumber7getZeroEv'/>
<fun r='_ZN4llvm12ScaledNumber6getOneEv'/>
<fun r='_ZN4llvm12ScaledNumber10getLargestEv'/>
<fun r='_ZN4llvm12ScaledNumber3getEm'/>
<fun r='_ZN4llvm12ScaledNumber10getInverseEm'/>
<fun r='_ZN4llvm12ScaledNumber11getFractionET_S1_'/>
<fun r='_ZNK4llvm12ScaledNumber8getScaleEv'/>
<fun r='_ZNK4llvm12ScaledNumber9getDigitsEv'/>
<fun r='_ZNK4llvm12ScaledNumber5toIntEv'/>
<fun r='_ZNK4llvm12ScaledNumber6isZeroEv'/>
<fun r='_ZNK4llvm12ScaledNumber9isLargestEv'/>
<fun r='_ZNK4llvm12ScaledNumber5isOneEv'/>
<fun r='_ZNK4llvm12ScaledNumber2lgEv'/>
<fun r='_ZNK4llvm12ScaledNumber7lgFloorEv'/>
<fun r='_ZNK4llvm12ScaledNumber9lgCeilingEv'/>
<fun r='_ZNK4llvm12ScaledNumbereqERKNS_12ScaledNumberIT_EE'/>
<fun r='_ZNK4llvm12ScaledNumberltERKNS_12ScaledNumberIT_EE'/>
<fun r='_ZNK4llvm12ScaledNumberneERKNS_12ScaledNumberIT_EE'/>
<fun r='_ZNK4llvm12ScaledNumbergtERKNS_12ScaledNumberIT_EE'/>
<fun r='_ZNK4llvm12ScaledNumberleERKNS_12ScaledNumberIT_EE'/>
<fun r='_ZNK4llvm12ScaledNumbergeERKNS_12ScaledNumberIT_EE'/>
<fun r='_ZNK4llvm12ScaledNumberntEv'/>
<fun r='_ZN4llvm12ScaledNumber8toStringEj'/>
<fun r='_ZNK4llvm12ScaledNumber5printERNS_11raw_ostreamEj'/>
<fun r='_ZNK4llvm12ScaledNumber4dumpEv'/>
<fun r='_ZN4llvm12ScaledNumberpLERKNS_12ScaledNumberIT_EE'/>
<fun r='_ZN4llvm12ScaledNumbermIERKNS_12ScaledNumberIT_EE'/>
<fun r='_ZN4llvm12ScaledNumbermLERKNS_12ScaledNumberIT_EE'/>
<fun r='_ZN4llvm12ScaledNumberdVERKNS_12ScaledNumberIT_EE'/>
<fun r='_ZN4llvm12ScaledNumberlSEs'/>
<fun r='_ZN4llvm12ScaledNumberrSEs'/>
<fun r='_ZN4llvm12ScaledNumber9shiftLeftEi'/>
<fun r='_ZN4llvm12ScaledNumber10shiftRightEi'/>
<fun r='_ZN4llvm12ScaledNumber11matchScalesENS_12ScaledNumberIT_EE'/>
<fun r='_ZNK4llvm12ScaledNumber5scaleEm'/>
<fun r='_ZNK4llvm12ScaledNumber14scaleByInverseEm'/>
<fun r='_ZNK4llvm12ScaledNumber5scaleEl'/>
<fun r='_ZNK4llvm12ScaledNumber14scaleByInverseEl'/>
<fun r='_ZNK4llvm12ScaledNumber7compareERKNS_12ScaledNumberIT_EE'/>
<fun r='_ZNK4llvm12ScaledNumber9compareToEm'/>
<fun r='_ZNK4llvm12ScaledNumber9compareToEl'/>
<fun r='_ZN4llvm12ScaledNumber6invertEv'/>
<fun r='_ZNK4llvm12ScaledNumber7inverseEv'/>
<fun r='_ZN4llvm12ScaledNumber10getProductET_S1_'/>
<fun r='_ZN4llvm12ScaledNumber11getQuotientET_S1_'/>
<fun r='_ZN4llvm12ScaledNumber22countLeadingZerosWidthET_'/>
<fun r='_ZN4llvm12ScaledNumber13adjustToWidthEmi'/>
<fun r='_ZN4llvm12ScaledNumber10getRoundedENS_12ScaledNumberIT_EEb'/>
<fun r='_ZNK4llvm12ScaledNumber5scaleEm'/>
<fun r='_ZNK4llvm12ScaledNumber5toIntEv'/>
<fun r='_ZN4llvm12ScaledNumbermLERKNS_12ScaledNumberIT_EE'/>
<fun r='_ZN4llvm12ScaledNumberdVERKNS_12ScaledNumberIT_EE'/>
<fun r='_ZN4llvm12ScaledNumber9shiftLeftEi'/>
<fun r='_ZN4llvm12ScaledNumber10shiftRightEi'/>
