<dec f='llvm/llvm/include/llvm/Analysis/ValueTracking.h' l='355' type='void llvm::GetUnderlyingObjects(const llvm::Value * V, SmallVectorImpl&lt;const llvm::Value *&gt; &amp; Objects, const llvm::DataLayout &amp; DL, llvm::LoopInfo * LI = nullptr, unsigned int MaxLookup = 6)'/>
<doc f='llvm/llvm/include/llvm/Analysis/ValueTracking.h' l='327'>/// This method is similar to GetUnderlyingObject except that it can
  /// look through phi and select instructions and return multiple objects.
  ///
  /// If LoopInfo is passed, loop phis are further analyzed.  If a pointer
  /// accesses different objects in each iteration, we don&apos;t look through the
  /// phi node. E.g. consider this loop nest:
  ///
  ///   int **A;
  ///   for (i)
  ///     for (j) {
  ///        A[i][j] = A[i-1][j] * B[j]
  ///     }
  ///
  /// This is transformed by Load-PRE to stash away A[i] for the next iteration
  /// of the outer loop:
  ///
  ///   Curr = A[0];          // Prev_0
  ///   for (i: 1..N) {
  ///     Prev = Curr;        // Prev = PHI (Prev_0, Curr)
  ///     Curr = A[i];
  ///     for (j: 0..N) {
  ///        Curr[j] = Prev[j] * B[j]
  ///     }
  ///   }
  ///
  /// Since A[i] and A[i-1] are independent pointers, getUnderlyingObjects
  /// should not assume that Curr and Prev share the same underlying object thus
  /// it shouldn&apos;t look through the phi above.</doc>
<use f='llvm/llvm/lib/Analysis/GlobalsModRef.cpp' l='900' u='c' c='_ZN4llvm15GlobalsAAResult24getModRefInfoForArgumentEPKNS_8CallBaseEPKNS_11GlobalValueERNS_11AAQueryInfoE'/>
<use f='llvm/llvm/lib/Analysis/InstructionSimplify.cpp' l='2289' u='c' c='_ZL18computePointerICmpRKN4llvm10DataLayoutEPKNS_17TargetLibraryInfoEPKNS_13DominatorTreeENS_7CmpInst9PredicateEPNS_15AssumptionCacheEPKNS_11Instructi10406885'/>
<use f='llvm/llvm/lib/Analysis/InstructionSimplify.cpp' l='2290' u='c' c='_ZL18computePointerICmpRKN4llvm10DataLayoutEPKNS_17TargetLibraryInfoEPKNS_13DominatorTreeENS_7CmpInst9PredicateEPNS_15AssumptionCacheEPKNS_11Instructi10406885'/>
<use f='llvm/llvm/lib/Analysis/LoopAccessAnalysis.cpp' l='909' u='c' c='_ZN12_GLOBAL__N_114AccessAnalysis18processMemAccessesEv'/>
<def f='llvm/llvm/lib/Analysis/ValueTracking.cpp' l='3916' ll='3956' type='void llvm::GetUnderlyingObjects(const llvm::Value * V, SmallVectorImpl&lt;const llvm::Value *&gt; &amp; Objects, const llvm::DataLayout &amp; DL, llvm::LoopInfo * LI = nullptr, unsigned int MaxLookup = 6)'/>
<use f='llvm/llvm/lib/Analysis/ValueTracking.cpp' l='3998' u='c' c='_ZN4llvm30getUnderlyingObjectsForCodeGenEPKNS_5ValueERNS_15SmallVectorImplIPS0_EERKNS_10DataLayoutE'/>
<use f='llvm/llvm/lib/CodeGen/MachinePipeliner.cpp' l='602' u='c' c='_ZL20getUnderlyingObjectsPKN4llvm12MachineInstrERNS_15SmallVectorImplIPKNS_5ValueEEERKNS_10DataLayoutE'/>
<use f='llvm/llvm/lib/Target/Mips/MipsDelaySlotFiller.cpp' l='560' u='c' c='_ZNK12_GLOBAL__N_111MemDefsUses20getUnderlyingObjectsERKN4llvm12MachineInstrERNS1_15SmallVectorImplINS1_12PointerUnionIJPKNS1_5ValueEPKNS1_17PseudoSourceValueEEEEEE'/>
<use f='llvm/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp' l='706' u='c' c='_ZL13canLowerToLDGPN4llvm9MemSDNodeERKNS_14NVPTXSubtargetEjPNS_15MachineFunctionE'/>
<use f='llvm/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp' l='1194' u='c' c='_ZN12_GLOBAL__N_113DFSanFunction10loadShadowEPN4llvm5ValueEmmPNS1_11InstructionE'/>
<use f='llvm/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp' l='786' u='c' c='_ZL14handleEndBlockRN4llvm10BasicBlockEPNS_9AAResultsEPNS_23MemoryDependenceResultsEPKNS_17TargetLibraryInfoERNS_8DenseMapIPNS_11InstructionESt3mapIll11858614'/>
<use f='llvm/llvm/lib/Transforms/Utils/InlineFunction.cpp' l='1039' u='c' c='_ZL21AddAliasScopeMetadataN4llvm8CallSiteERNS_8ValueMapIPKNS_5ValueENS_14WeakTrackingVHENS_14ValueMapConfigIS4_NS_3sys10SmartMutexILb0EEEEEEERKNS_10Da10846726'/>
