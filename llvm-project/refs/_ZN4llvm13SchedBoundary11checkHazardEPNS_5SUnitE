<dec f='llvm/llvm/include/llvm/CodeGen/MachineScheduler.h' l='753' type='bool llvm::SchedBoundary::checkHazard(llvm::SUnit * SU)'/>
<def f='llvm/llvm/lib/CodeGen/MachineScheduler.cpp' l='1992' ll='2035' type='bool llvm::SchedBoundary::checkHazard(llvm::SUnit * SU)'/>
<use f='llvm/llvm/lib/CodeGen/MachineScheduler.cpp' l='2103' u='c' c='_ZN4llvm13SchedBoundary11releaseNodeEPNS_5SUnitEj'/>
<use f='llvm/llvm/lib/CodeGen/MachineScheduler.cpp' l='2358' u='c' c='_ZN4llvm13SchedBoundary14releasePendingEv'/>
<use f='llvm/llvm/lib/CodeGen/MachineScheduler.cpp' l='2391' u='c' c='_ZN4llvm13SchedBoundary14pickOnlyChoiceEv'/>
<doc f='llvm/llvm/lib/CodeGen/MachineScheduler.cpp' l='1979'>/// Does this SU have a hazard within the current instruction group.
///
/// The scheduler supports two modes of hazard recognition. The first is the
/// ScheduleHazardRecognizer API. It is a fully general hazard recognizer that
/// supports highly complicated in-order reservation tables
/// (ScoreboardHazardRecognizer) and arbitrary target-specific logic.
///
/// The second is a streamlined mechanism that checks for hazards based on
/// simple counters that the scheduler itself maintains. It explicitly checks
/// for instruction dispatch limitations, including the number of micro-ops that
/// can dispatch per cycle.
///
/// TODO: Also check whether the SU must start a new group.</doc>
