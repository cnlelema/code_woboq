<dec f='llvm/llvm/lib/Target/Mips/MipsSEISelLowering.h' l='158' type='llvm::MachineBasicBlock * llvm::MipsSETargetLowering::emitFPEXTEND_PSEUDO(llvm::MachineInstr &amp; MI, llvm::MachineBasicBlock * BB, bool IsFGR64) const'/>
<def f='llvm/llvm/lib/Target/Mips/MipsSEISelLowering.cpp' l='3813' ll='3868' type='llvm::MachineBasicBlock * llvm::MipsSETargetLowering::emitFPEXTEND_PSEUDO(llvm::MachineInstr &amp; MI, llvm::MachineBasicBlock * BB, bool IsFGR64) const'/>
<doc f='llvm/llvm/lib/Target/Mips/MipsSEISelLowering.cpp' l='3771'>// Emit the FPEXTEND_PSEUDO instruction.
//
// Expand an f16 to either a FGR32Opnd or FGR64Opnd.
//
// Safety: Cycle the result through the GPRs so the result always ends up
//         the correct floating point register.
//
// FIXME: This copying is strictly unnecessary. If we could tie FGR32Opnd:$Fd
//        / FGR64Opnd:$Fd and MSA128F16:$Ws to the same physical register
//        (which they can be, as the MSA registers are defined to alias the
//        FPU&apos;s 64 bit and 32 bit registers) the result can be accessed using
//        the correct register class. That requires operands be tie-able across
//        register classes which have a sub/super register class relationship. I
//        haven&apos;t checked.
//
// For FGR32Opnd:
//
// FPEXTEND FGR32Opnd:$fd, MSA128F16:$ws
// =&gt;
//  fexupr.w $wtemp, $ws
//  copy_s.w $rtemp, $ws[0]
//  mtc1 $rtemp, $fd
//
// For FGR64Opnd on Mips64:
//
// FPEXTEND FGR64Opnd:$fd, MSA128F16:$ws
// =&gt;
//  fexupr.w $wtemp, $ws
//  fexupr.d $wtemp2, $wtemp
//  copy_s.d $rtemp, $wtemp2s[0]
//  dmtc1 $rtemp, $fd
//
// For FGR64Opnd on Mips32:
//
// FPEXTEND FGR64Opnd:$fd, MSA128F16:$ws
// =&gt;
//  fexupr.w $wtemp, $ws
//  fexupr.d $wtemp2, $wtemp
//  copy_s.w $rtemp, $wtemp2[0]
//  mtc1 $rtemp, $ftemp
//  copy_s.w $rtemp2, $wtemp2[1]
//  $fd = mthc1 $rtemp2, $ftemp</doc>
<doc f='llvm/llvm/lib/Target/Mips/MipsSEISelLowering.h' l='157'>/// Emit the FEXP2_W_1 pseudo instructions.</doc>
