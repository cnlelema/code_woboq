<def f='llvm/clang/include/clang/Sema/Sema.h' l='479' ll='483' type='void clang::Sema::PragmaStack::SentinelAction(clang::Sema::PragmaMsStackAction Action, llvm::StringRef Label)'/>
<doc f='llvm/clang/include/clang/Sema/Sema.h' l='465'>// MSVC seems to add artificial slots to #pragma stacks on entering a C++
    // method body to restore the stacks on exit, so it works like this:
    //
    //   struct S {
    //     #pragma &lt;name&gt;(push, InternalPragmaSlot, &lt;current_pragma_value&gt;)
    //     void Method {}
    //     #pragma &lt;name&gt;(pop, InternalPragmaSlot)
    //   };
    //
    // It works even with #pragma vtordisp, although MSVC doesn&apos;t support
    //   #pragma vtordisp(push [, id], n)
    // syntax.
    //
    // Push / pop a named sentinel slot.</doc>
<use f='llvm/clang/lib/Sema/SemaAttr.cpp' l='33' u='c' c='_ZN5clang4Sema23PragmaStackSentinelRAIIC1ERS0_N4llvm9StringRefEb'/>
<use f='llvm/clang/lib/Sema/SemaAttr.cpp' l='34' u='c' c='_ZN5clang4Sema23PragmaStackSentinelRAIIC1ERS0_N4llvm9StringRefEb'/>
<use f='llvm/clang/lib/Sema/SemaAttr.cpp' l='35' u='c' c='_ZN5clang4Sema23PragmaStackSentinelRAIIC1ERS0_N4llvm9StringRefEb'/>
<use f='llvm/clang/lib/Sema/SemaAttr.cpp' l='36' u='c' c='_ZN5clang4Sema23PragmaStackSentinelRAIIC1ERS0_N4llvm9StringRefEb'/>
<use f='llvm/clang/lib/Sema/SemaAttr.cpp' l='43' u='c' c='_ZN5clang4Sema23PragmaStackSentinelRAIID1Ev'/>
<use f='llvm/clang/lib/Sema/SemaAttr.cpp' l='44' u='c' c='_ZN5clang4Sema23PragmaStackSentinelRAIID1Ev'/>
<use f='llvm/clang/lib/Sema/SemaAttr.cpp' l='45' u='c' c='_ZN5clang4Sema23PragmaStackSentinelRAIID1Ev'/>
<use f='llvm/clang/lib/Sema/SemaAttr.cpp' l='46' u='c' c='_ZN5clang4Sema23PragmaStackSentinelRAIID1Ev'/>
