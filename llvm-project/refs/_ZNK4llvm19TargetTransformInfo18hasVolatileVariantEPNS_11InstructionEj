<dec f='llvm/llvm/include/llvm/Analysis/TargetTransformInfo.h' l='558' type='bool llvm::TargetTransformInfo::hasVolatileVariant(llvm::Instruction * I, unsigned int AddrSpace) const'/>
<doc f='llvm/llvm/include/llvm/Analysis/TargetTransformInfo.h' l='553'>/// Return true if the given instruction (assumed to be a memory access
  /// instruction) has a volatile variant. If that&apos;s the case then we can avoid
  /// addrspacecast to generic AS for volatile loads/stores. Default
  /// implementation returns false, which prevents address space inference for
  /// volatile loads/stores.</doc>
<def f='llvm/llvm/lib/Analysis/TargetTransformInfo.cpp' l='206' ll='209' type='bool llvm::TargetTransformInfo::hasVolatileVariant(llvm::Instruction * I, unsigned int AddrSpace) const'/>
<use f='llvm/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp' l='770' u='c' c='_ZL32isSimplePointerUseValidToReplaceRKN4llvm19TargetTransformInfoERNS_3UseEj'/>
