<dec f='llvm/clang/include/clang/Sema/Sema.h' l='6785' type='clang::TypeSourceInfo * clang::Sema::RebuildTypeInCurrentInstantiation(clang::TypeSourceInfo * T, clang::SourceLocation Loc, clang::DeclarationName Name)'/>
<use f='llvm/clang/lib/Sema/SemaDecl.cpp' l='5191' u='c' c='_ZL39RebuildDeclaratorInCurrentInstantiationRN5clang4SemaERNS_10DeclaratorENS_15DeclarationNameE'/>
<def f='llvm/clang/lib/Sema/SemaTemplate.cpp' l='10038' ll='10046' type='clang::TypeSourceInfo * clang::Sema::RebuildTypeInCurrentInstantiation(clang::TypeSourceInfo * T, clang::SourceLocation Loc, clang::DeclarationName Name)'/>
<doc f='llvm/clang/lib/Sema/SemaTemplate.cpp' l='10012'>/// Rebuilds a type within the context of the current instantiation.
///
/// The type \p T is part of the type of an out-of-line member definition of
/// a class template (or class template partial specialization) that was parsed
/// and constructed before we entered the scope of the class template (or
/// partial specialization thereof). This routine will rebuild that type now
/// that we have entered the declarator&apos;s scope, which may produce different
/// canonical types, e.g.,
///
/// \code
/// template&lt;typename T&gt;
/// struct X {
///   typedef T* pointer;
///   pointer data();
/// };
///
/// template&lt;typename T&gt;
/// typename X&lt;T&gt;::pointer X&lt;T&gt;::data() { ... }
/// \endcode
///
/// Here, the type &quot;typename X&lt;T&gt;::pointer&quot; will be created as a DependentNameType,
/// since we do not know that we can look into X&lt;T&gt; when we parsed the type.
/// This function will rebuild the type, performing the lookup of &quot;pointer&quot;
/// in X&lt;T&gt; and returning an ElaboratedType whose canonical type is the same
/// as the canonical type of T*, allowing the return types of the out-of-line
/// definition and the declaration to match.</doc>
