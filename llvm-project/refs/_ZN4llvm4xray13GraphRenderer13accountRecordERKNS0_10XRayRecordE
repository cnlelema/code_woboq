<dec f='llvm/llvm/tools/llvm-xray/xray-graph.h' l='140' type='llvm::Error llvm::xray::GraphRenderer::accountRecord(const llvm::xray::XRayRecord &amp; Record)'/>
<doc f='llvm/llvm/tools/llvm-xray/xray-graph.h' l='133'>/// Process an Xray record and expand the graph.
  ///
  /// This Function will return true on success, or false if records are not
  /// presented in per-thread call-tree DFS order. (That is for each thread the
  /// Records should be in order runtime on an ideal system.)
  ///
  /// FIXME: Make this more robust against small irregularities.</doc>
<def f='llvm/llvm/tools/llvm-xray/xray-graph.cpp' l='191' ll='255' type='llvm::Error llvm::xray::GraphRenderer::accountRecord(const llvm::xray::XRayRecord &amp; Record)'/>
<use f='llvm/llvm/tools/llvm-xray/xray-graph.cpp' l='447' u='c' c='_ZN4llvm4xray13GraphRenderer7Factory16getGraphRendererEv'/>
<doc f='llvm/llvm/tools/llvm-xray/xray-graph.cpp' l='173'>// Evaluates an XRay record and performs accounting on it.
//
// If the record is an ENTER record it pushes the FuncID and TSC onto a
// structure representing the call stack for that function.
// If the record is an EXIT record it checks computes computes the ammount of
// time the function took to complete and then stores that information in an
// edge of the graph. If there is no matching ENTER record the function tries
// to recover by assuming that there were EXIT records which were missed, for
// example caused by tail call elimination and if the option is enabled then
// then tries to recover from this.
//
// This funciton will also error if the records are out of order, as the trace
// is expected to be sorted.
//
// The graph generated has an immaginary root for functions called by no-one at
// FuncId 0.
//
// FIXME: Refactor this and account subcommand to reduce code duplication.</doc>
