<dec f='llvm/llvm/lib/Target/PowerPC/PPCISelLowering.h' l='665' type='bool llvm::PPCTargetLowering::SelectAddressRegReg(llvm::SDValue N, llvm::SDValue &amp; Base, llvm::SDValue &amp; Index, llvm::SelectionDAG &amp; DAG, unsigned int EncodingAlignment = 0) const'/>
<doc f='llvm/llvm/lib/Target/PowerPC/PPCISelLowering.h' l='661'>/// SelectAddressRegReg - Given the specified addressed, check to see if it
    /// can be more efficiently represented as [r+imm]. If \p EncodingAlignment
    /// is non-zero, only accept displacement which is not suitable for [r+imm].
    /// Returns false if it can be represented by [r+imm], which are preferred.</doc>
<use f='llvm/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp' l='241' u='c' c='_ZN12_GLOBAL__N_115PPCDAGToDAGISel13SelectAddrIdxEN4llvm7SDValueERS2_S3_'/>
<use f='llvm/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp' l='251' u='c' c='_ZN12_GLOBAL__N_115PPCDAGToDAGISel15SelectAddrIdxX4EN4llvm7SDValueERS2_S3_'/>
<use f='llvm/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp' l='261' u='c' c='_ZN12_GLOBAL__N_115PPCDAGToDAGISel16SelectAddrIdxX16EN4llvm7SDValueERS2_S3_'/>
<def f='llvm/llvm/lib/Target/PowerPC/PPCISelLowering.cpp' l='2247' ll='2284' type='bool llvm::PPCTargetLowering::SelectAddressRegReg(llvm::SDValue N, llvm::SDValue &amp; Base, llvm::SDValue &amp; Index, llvm::SelectionDAG &amp; DAG, unsigned int EncodingAlignment = 0) const'/>
<use f='llvm/llvm/lib/Target/PowerPC/PPCISelLowering.cpp' l='2337' u='c' c='_ZNK4llvm17PPCTargetLowering19SelectAddressRegImmENS_7SDValueERS1_S2_RNS_12SelectionDAGEj'/>
<use f='llvm/llvm/lib/Target/PowerPC/PPCISelLowering.cpp' l='2435' u='c' c='_ZNK4llvm17PPCTargetLowering23SelectAddressRegRegOnlyENS_7SDValueERS1_S2_RNS_12SelectionDAGE'/>
<use f='llvm/llvm/lib/Target/PowerPC/PPCISelLowering.cpp' l='2545' u='c' c='_ZNK4llvm17PPCTargetLowering25getPreIndexedAddressPartsEPNS_6SDNodeERNS_7SDValueES4_RNS_3ISD14MemIndexedModeERNS_12SelectionDAGE'/>
<doc f='llvm/llvm/lib/Target/PowerPC/PPCISelLowering.cpp' l='2241'>/// SelectAddressRegReg - Given the specified addressed, check to see if it
/// can be represented as an indexed [r+r] operation.  Returns false if it
/// can be more efficiently represented as [r+imm]. If \p EncodingAlignment is
/// non-zero and N can be represented by a base register plus a signed 16-bit
/// displacement, make a more precise judgement by checking (displacement % \p
/// EncodingAlignment).</doc>
