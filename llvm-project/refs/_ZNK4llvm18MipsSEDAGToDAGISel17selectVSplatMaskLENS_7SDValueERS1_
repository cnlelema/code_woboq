<dec f='llvm/llvm/lib/Target/Mips/MipsSEISelDAGToDAG.h' l='127' type='bool llvm::MipsSEDAGToDAGISel::selectVSplatMaskL(llvm::SDValue N, llvm::SDValue &amp; Imm) const'/>
<doc f='llvm/llvm/lib/Target/Mips/MipsSEISelDAGToDAG.h' l='125'>/// Select constant vector splats whose value is a run of set bits
  /// ending at the most significant bit</doc>
<inh f='llvm/llvm/lib/Target/Mips/MipsISelDAGToDAG.h' l='124' c='_ZNK4llvm16MipsDAGToDAGISel17selectVSplatMaskLENS_7SDValueERS1_'/>
<def f='llvm/llvm/lib/Target/Mips/MipsSEISelDAGToDAG.cpp' l='766' ll='787' type='bool llvm::MipsSEDAGToDAGISel::selectVSplatMaskL(llvm::SDValue N, llvm::SDValue &amp; Imm) const'/>
<doc f='llvm/llvm/lib/Target/Mips/MipsSEISelDAGToDAG.cpp' l='755'>// Select constant vector splats whose value only has a consecutive sequence
// of left-most bits set (e.g. 0b11...1100...00).
//
// In addition to the requirements of selectVSplat(), this function returns
// true and sets Imm if:
// * The splat value is the same width as the elements of the vector
// * The splat value is a consecutive sequence of left-most bits.
//
// This function looks through ISD::BITCAST nodes.
// TODO: This might not be appropriate for big-endian MSA since BITCAST is
//       sometimes a shuffle in big-endian mode.</doc>
