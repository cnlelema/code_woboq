<dec f='llvm/llvm/lib/Target/Hexagon/HexagonISelLowering.h' l='296' type='llvm::EVT llvm::HexagonTargetLowering::getOptimalMemOpType(uint64_t Size, unsigned int DstAlign, unsigned int SrcAlign, bool IsMemset, bool ZeroMemset, bool MemcpyStrSrc, const llvm::AttributeList &amp; FuncAttributes) const'/>
<inh f='llvm/llvm/include/llvm/CodeGen/TargetLowering.h' l='1483' c='_ZNK4llvm18TargetLoweringBase19getOptimalMemOpTypeEmjjbbbRKNS_13AttributeListE'/>
<def f='llvm/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp' l='3050' ll='3066' type='llvm::EVT llvm::HexagonTargetLowering::getOptimalMemOpType(uint64_t Size, unsigned int DstAlign, unsigned int SrcAlign, bool IsMemset, bool ZeroMemset, bool MemcpyStrSrc, const llvm::AttributeList &amp; FuncAttributes) const'/>
<doc f='llvm/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp' l='3039'>/// Returns the target specific optimal type for load and store operations as
/// a result of memset, memcpy, and memmove lowering.
///
/// If DstAlign is zero that means it&apos;s safe to destination alignment can
/// satisfy any constraint. Similarly if SrcAlign is zero it means there isn&apos;t
/// a need to check it against alignment requirement, probably because the
/// source does not need to be loaded. If &apos;IsMemset&apos; is true, that means it&apos;s
/// expanding a memset. If &apos;ZeroMemset&apos; is true, that means it&apos;s a memset of
/// zero. &apos;MemcpyStrSrc&apos; indicates whether the memcpy source is constant so it
/// does not need to be loaded.  It returns EVT::Other if the type should be
/// determined using generic target-independent logic.</doc>
