<dec f='llvm/llvm/include/llvm/Transforms/IPO/Attributor.h' l='253' type='void llvm::Attributor::identifyDefaultAbstractAttributes(llvm::Function &amp; F, llvm::InformationCache &amp; InfoCache, DenseSet&lt;unsigned int&gt; * Whitelist = nullptr)'/>
<doc f='llvm/llvm/include/llvm/Transforms/IPO/Attributor.h' l='241'>/// Determine opportunities to derive &apos;default&apos; attributes in \p F and create
  /// abstract attribute objects for them.
  ///
  /// \param F The function that is checked for attribute opportunities.
  /// \param InfoCache A cache for information queryable by the new attributes.
  /// \param Whitelist If not null, a set limiting the attribute opportunities.
  ///
  /// Note that abstract attribute instances are generally created even if the
  /// IR already contains the information they would deduce. The most important
  /// reason for this is the single interface, the one of the abstract attribute
  /// instance, which can be queried without the need to look at the IR in
  /// various places.</doc>
<def f='llvm/llvm/lib/Transforms/IPO/Attributor.cpp' l='382' ll='409' type='void llvm::Attributor::identifyDefaultAbstractAttributes(llvm::Function &amp; F, llvm::InformationCache &amp; InfoCache, DenseSet&lt;unsigned int&gt; * Whitelist = nullptr)'/>
<use f='llvm/llvm/lib/Transforms/IPO/Attributor.cpp' l='486' u='c' c='_ZL21runAttributorOnModuleRN4llvm6ModuleE'/>
