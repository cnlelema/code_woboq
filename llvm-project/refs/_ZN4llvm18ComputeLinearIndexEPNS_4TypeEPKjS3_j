<dec f='llvm/llvm/include/llvm/CodeGen/Analysis.h' l='54' type='unsigned int llvm::ComputeLinearIndex(llvm::Type * Ty, const unsigned int * Indices, const unsigned int * IndicesEnd, unsigned int CurIndex = 0)'/>
<use f='llvm/llvm/include/llvm/CodeGen/Analysis.h' l='62' u='c' c='_ZN4llvm18ComputeLinearIndexEPNS_4TypeENS_8ArrayRefIjEEj'/>
<doc f='llvm/llvm/include/llvm/CodeGen/Analysis.h' l='39'>/// Compute the linearized index of a member in a nested
/// aggregate/struct/array.
///
/// Given an LLVM IR aggregate type and a sequence of insertvalue or
/// extractvalue indices that identify a member, return the linearized index of
/// the start of the member, i.e the number of element in memory before the
/// sought one. This is disconnected from the number of bytes.
///
/// \param Ty is the type indexed by \p Indices.
/// \param Indices is an optional pointer in the indices list to the current
/// index.
/// \param IndicesEnd is the end of the indices list.
/// \param CurIndex is the current index in the recursion.
///
/// \returns \p CurIndex plus the linear index in \p Ty  the indices list.</doc>
<def f='llvm/llvm/lib/CodeGen/Analysis.cpp' l='35' ll='74' type='unsigned int llvm::ComputeLinearIndex(llvm::Type * Ty, const unsigned int * Indices, const unsigned int * IndicesEnd, unsigned int CurIndex = 0)'/>
<use f='llvm/llvm/lib/CodeGen/Analysis.cpp' l='50' u='c' c='_ZN4llvm18ComputeLinearIndexEPNS_4TypeEPKjS3_j'/>
<use f='llvm/llvm/lib/CodeGen/Analysis.cpp' l='51' u='c' c='_ZN4llvm18ComputeLinearIndexEPNS_4TypeEPKjS3_j'/>
<use f='llvm/llvm/lib/CodeGen/Analysis.cpp' l='61' u='c' c='_ZN4llvm18ComputeLinearIndexEPNS_4TypeEPKjS3_j'/>
<use f='llvm/llvm/lib/CodeGen/Analysis.cpp' l='67' u='c' c='_ZN4llvm18ComputeLinearIndexEPNS_4TypeEPKjS3_j'/>
<doc f='llvm/llvm/lib/CodeGen/Analysis.cpp' l='32'>/// Compute the linearized index of a member in a nested aggregate/struct/array
/// by recursing and accumulating CurIndex as long as there are indices in the
/// index list.</doc>
