<dec f='llvm/llvm/include/llvm/Transforms/Scalar/JumpThreading.h' l='148' type='bool llvm::JumpThreadingPass::ProcessGuards(llvm::BasicBlock * BB)'/>
<use f='llvm/llvm/lib/Transforms/Scalar/JumpThreading.cpp' l='1036' u='c' c='_ZN4llvm17JumpThreadingPass12ProcessBlockEPNS_10BasicBlockE'/>
<def f='llvm/llvm/lib/Transforms/Scalar/JumpThreading.cpp' l='2630' ll='2659' type='bool llvm::JumpThreadingPass::ProcessGuards(llvm::BasicBlock * BB)'/>
<doc f='llvm/llvm/lib/Transforms/Scalar/JumpThreading.cpp' l='2611'>/// Try to propagate a guard from the current BB into one of its predecessors
/// in case if another branch of execution implies that the condition of this
/// guard is always true. Currently we only process the simplest case that
/// looks like:
///
/// Start:
///   %cond = ...
///   br i1 %cond, label %T1, label %F1
/// T1:
///   br label %Merge
/// F1:
///   br label %Merge
/// Merge:
///   %condGuard = ...
///   call void(i1, ...) @llvm.experimental.guard( i1 %condGuard )[ &quot;deopt&quot;() ]
///
/// And cond either implies condGuard or !condGuard. In this case all the
/// instructions before the guard can be duplicated in both branches, and the
/// guard is then threaded to one of them.</doc>
