<dec f='llvm/llvm/include/llvm/MC/MCInstrAnalysis.h' l='90' type='bool llvm::MCInstrAnalysis::clearsSuperRegisters(const llvm::MCRegisterInfo &amp; MRI, const llvm::MCInst &amp; Inst, llvm::APInt &amp; Writes) const'/>
<def f='llvm/llvm/lib/MC/MCInstrAnalysis.cpp' l='19' ll='24' type='bool llvm::MCInstrAnalysis::clearsSuperRegisters(const llvm::MCRegisterInfo &amp; MRI, const llvm::MCInst &amp; Inst, llvm::APInt &amp; Writes) const'/>
<doc f='llvm/llvm/include/llvm/MC/MCInstrAnalysis.h' l='69'>/// Returns true if at least one of the register writes performed by
  /// \param Inst implicitly clears the upper portion of all super-registers.
  ///
  /// Example: on X86-64, a write to EAX implicitly clears the upper half of
  /// RAX. Also (still on x86) an XMM write perfomed by an AVX 128-bit
  /// instruction implicitly clears the upper portion of the correspondent
  /// YMM register.
  ///
  /// This method also updates an APInt which is used as mask of register
  /// writes. There is one bit for every explicit/implicit write performed by
  /// the instruction. If a write implicitly clears its super-registers, then
  /// the corresponding bit is set (vic. the corresponding bit is cleared).
  ///
  /// The first bits in the APint are related to explicit writes. The remaining
  /// bits are related to implicit writes. The sequence of writes follows the
  /// machine operand sequence. For implicit writes, the sequence is defined by
  /// the MCInstrDesc.
  ///
  /// The assumption is that the bit-width of the APInt is correctly set by
  /// the caller. The default implementation conservatively assumes that none of
  /// the writes clears the upper portion of a super-register.</doc>
<ovr f='llvm/llvm/lib/Target/X86/MCTargetDesc/X86MCTargetDesc.cpp' l='407' c='_ZNK4llvm6X86_MC18X86MCInstrAnalysis20clearsSuperRegistersERKNS_14MCRegisterInfoERKNS_6MCInstERNS_5APIntE'/>
