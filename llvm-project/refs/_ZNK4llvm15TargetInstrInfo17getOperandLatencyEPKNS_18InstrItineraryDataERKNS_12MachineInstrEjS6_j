<dec f='llvm/llvm/include/llvm/CodeGen/TargetInstrInfo.h' l='1373' type='int llvm::TargetInstrInfo::getOperandLatency(const llvm::InstrItineraryData * ItinData, const llvm::MachineInstr &amp; DefMI, unsigned int DefIdx, const llvm::MachineInstr &amp; UseMI, unsigned int UseIdx) const'/>
<doc f='llvm/llvm/include/llvm/CodeGen/TargetInstrInfo.h' l='1365'>/// Compute and return the use operand latency of a given pair of def and use.
  /// In most cases, the static scheduling itinerary was enough to determine the
  /// operand latency. But it may not be possible for instructions with variable
  /// number of defs / uses.
  ///
  /// This is a raw interface to the itinerary that may be directly overridden
  /// by a target. Use computeOperandLatency to get the best estimate of
  /// latency.</doc>
<def f='llvm/llvm/lib/CodeGen/TargetInstrInfo.cpp' l='1119' ll='1127' type='int llvm::TargetInstrInfo::getOperandLatency(const llvm::InstrItineraryData * ItinData, const llvm::MachineInstr &amp; DefMI, unsigned int DefIdx, const llvm::MachineInstr &amp; UseMI, unsigned int UseIdx) const'/>
<doc f='llvm/llvm/lib/CodeGen/TargetInstrInfo.cpp' l='1117'>/// Both DefMI and UseMI must be valid.  By default, call directly to the
/// itinerary. This may be overriden by the target.</doc>
<use f='llvm/llvm/lib/CodeGen/TargetSchedule.cpp' l='194' u='c' c='_ZNK4llvm16TargetSchedModel21computeOperandLatencyEPKNS_12MachineInstrEjS3_j'/>
