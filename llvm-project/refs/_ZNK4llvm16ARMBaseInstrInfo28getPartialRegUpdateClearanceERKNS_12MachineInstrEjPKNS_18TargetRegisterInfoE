<dec f='llvm/llvm/lib/Target/ARM/ARMBaseInstrInfo.h' l='328' type='unsigned int llvm::ARMBaseInstrInfo::getPartialRegUpdateClearance(const llvm::MachineInstr &amp; , unsigned int , const llvm::TargetRegisterInfo * ) const'/>
<def f='llvm/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp' l='4996' ll='5053' type='unsigned int llvm::ARMBaseInstrInfo::getPartialRegUpdateClearance(const llvm::MachineInstr &amp; MI, unsigned int OpNum, const llvm::TargetRegisterInfo * TRI) const'/>
<doc f='llvm/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp' l='4980'>//===----------------------------------------------------------------------===//
// Partial register updates
//===----------------------------------------------------------------------===//
//
// Swift renames NEON registers with 64-bit granularity.  That means any
// instruction writing an S-reg implicitly reads the containing D-reg.  The
// problem is mostly avoided by translating f32 operations to v2f32 operations
// on D-registers, but f32 loads are still a problem.
//
// These instructions can load an f32 into a NEON register:
//
// VLDRS - Only writes S, partial D update.
// VLD1LNd32 - Writes all D-regs, explicit partial D update, 2 uops.
// VLD1DUPd32 - Writes all D-regs, no partial reg update, 2 uops.
//
// FCONSTD can be used as a dependency-breaking instruction.</doc>
