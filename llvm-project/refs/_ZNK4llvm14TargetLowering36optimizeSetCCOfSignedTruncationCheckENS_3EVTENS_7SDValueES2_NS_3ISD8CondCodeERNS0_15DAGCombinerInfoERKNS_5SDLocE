<dec f='llvm/llvm/include/llvm/CodeGen/TargetLowering.h' l='4120' type='llvm::SDValue llvm::TargetLowering::optimizeSetCCOfSignedTruncationCheck(llvm::EVT SCCVT, llvm::SDValue N0, llvm::SDValue N1, ISD::CondCode Cond, llvm::TargetLowering::DAGCombinerInfo &amp; DCI, const llvm::SDLoc &amp; DL) const'/>
<def f='llvm/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp' l='2524' ll='2609' type='llvm::SDValue llvm::TargetLowering::optimizeSetCCOfSignedTruncationCheck(llvm::EVT SCCVT, llvm::SDValue N0, llvm::SDValue N1, ISD::CondCode Cond, llvm::TargetLowering::DAGCombinerInfo &amp; DCI, const llvm::SDLoc &amp; DL) const'/>
<use f='llvm/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp' l='3054' u='c' c='_ZNK4llvm14TargetLowering13SimplifySetCCENS_3EVTENS_7SDValueES2_NS_3ISD8CondCodeEbRNS0_15DAGCombinerInfoERKNS_5SDLocE'/>
<doc f='llvm/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp' l='2514'>/// There are multiple IR patterns that could be checking whether certain
/// truncation of a signed number would be lossy or not. The pattern which is
/// best at IR level, may not lower optimally. Thus, we want to unfold it.
/// We are looking for the following pattern: (KeptBits is a constant)
///   (add %x, (1 &lt;&lt; (KeptBits-1))) srccond (1 &lt;&lt; KeptBits)
/// KeptBits won&apos;t be bitwidth(x), that will be constant-folded to true/false.
/// KeptBits also can&apos;t be 1, that would have been folded to  %x dstcond 0
/// We will unfold it into the natural trunc+sext pattern:
///   ((%x &lt;&lt; C) a&gt;&gt; C) dstcond %x
/// Where  C = bitwidth(x) - KeptBits  and  C u&lt; bitwidth(x)</doc>
