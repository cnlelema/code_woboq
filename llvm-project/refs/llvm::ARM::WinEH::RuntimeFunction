<def f='llvm/llvm/include/llvm/Support/ARMWinEH.h' l='100' ll='181'/>
<size>8</size>
<doc f='llvm/llvm/include/llvm/Support/ARMWinEH.h' l='32'>/// RuntimeFunction - An entry in the table of procedure data (.pdata)
///
///  3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1 0 0 0 0 0 0 0 0 0 0
///  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
/// +---------------------------------------------------------------+
/// |                     Function Start RVA                        |
/// +-------------------+-+-+-+-----+-+---+---------------------+---+
/// |    Stack Adjust   |C|L|R| Reg |H|Ret|   Function Length   |Flg|
/// +-------------------+-+-+-+-----+-+---+---------------------+---+
///
/// Flag : 2-bit field with the following meanings:
///   - 00 = packed unwind data not used; reamining bits point to .xdata record
///   - 01 = packed unwind data
///   - 10 = packed unwind data, function assumed to have no prologue; useful
///          for function fragments that are discontiguous with the start of the
///          function
///   - 11 = reserved
/// Function Length : 11-bit field providing the length of the entire function
///                   in bytes, divided by 2; if the function is greater than
///                   4KB, a full .xdata record must be used instead
/// Ret : 2-bit field indicating how the function returns
///   - 00 = return via pop {pc} (the L bit must be set)
///   - 01 = return via 16-bit branch
///   - 10 = return via 32-bit branch
///   - 11 = no epilogue; useful for function fragments that may only contain a
///          prologue but the epilogue is elsewhere
/// H : 1-bit flag indicating whether the function &quot;homes&quot; the integer parameter
///     registers (r0-r3), allocating 16-bytes on the stack
/// Reg : 3-bit field indicating the index of the last saved non-volatile
///       register.  If the R bit is set to 0, then only integer registers are
///       saved (r4-rN, where N is 4 + Reg).  If the R bit is set to 1, then
///       only floating-point registers are being saved (d8-dN, where N is
///       8 + Reg).  The special case of the R bit being set to 1 and Reg equal
///       to 7 indicates that no registers are saved.
/// R : 1-bit flag indicating whether the non-volatile registers are integer or
///     floating-point.  0 indicates integer, 1 indicates floating-point.  The
///     special case of the R-flag being set and Reg being set to 7 indicates
///     that no non-volatile registers are saved.
/// L : 1-bit flag indicating whether the function saves/restores the link
///     register (LR)
/// C : 1-bit flag indicating whether the function includes extra instructions
///     to setup a frame chain for fast walking.  If this flag is set, r11 is
///     implicitly added to the list of saved non-volatile integer registers.
/// Stack Adjust : 10-bit field indicating the number of bytes of stack that are
///                allocated for this function.  Only values between 0x000 and
///                0x3f3 can be directly encoded.  If the value is 0x3f4 or
///                greater, then the low 4 bits have special meaning as follows:
///                - Bit 0-1
///                  indicate the number of words&apos; of adjustment (1-4), minus 1
///                - Bit 2
///                  indicates if the prologue combined adjustment into push
///                - Bit 3
///                  indicates if the epilogue combined adjustment into pop
///
/// RESTRICTIONS:
///   - IF C is SET:
///     + L flag must be set since frame chaining requires r11 and lr
///     + r11 must NOT be included in the set of registers described by Reg
///   - IF Ret is 0:
///     + L flag must be set

// NOTE: RuntimeFunction is meant to be a simple class that provides raw access
// to all fields in the structure.  The accessor methods reflect the names of
// the bitfields that they correspond to.  Although some obvious simplifications
// are possible via merging of methods, it would prevent the use of this class
// to fully inspect the contents of the data structure which is particularly
// useful for scenarios such as llvm-readobj to aid in testing.</doc>
<mbr r='llvm::ARM::WinEH::RuntimeFunction::BeginAddress' o='0' t='const support::ulittle32_t'/>
<mbr r='llvm::ARM::WinEH::RuntimeFunction::UnwindData' o='32' t='const support::ulittle32_t'/>
<fun r='_ZN4llvm3ARM5WinEH15RuntimeFunctionC1EPKNS_7support6detail31packed_endian_specific_integralIjLNS3_10endiannessE1ELm1EEE'/>
<fun r='_ZN4llvm3ARM5WinEH15RuntimeFunctionC1ENS_7support6detail31packed_endian_specific_integralIjLNS3_10endiannessE1ELm1EEES7_'/>
<fun r='_ZNK4llvm3ARM5WinEH15RuntimeFunction4FlagEv'/>
<fun r='_ZNK4llvm3ARM5WinEH15RuntimeFunction23ExceptionInformationRVAEv'/>
<fun r='_ZNK4llvm3ARM5WinEH15RuntimeFunction16PackedUnwindDataEv'/>
<fun r='_ZNK4llvm3ARM5WinEH15RuntimeFunction14FunctionLengthEv'/>
<fun r='_ZNK4llvm3ARM5WinEH15RuntimeFunction3RetEv'/>
<fun r='_ZNK4llvm3ARM5WinEH15RuntimeFunction1HEv'/>
<fun r='_ZNK4llvm3ARM5WinEH15RuntimeFunction3RegEv'/>
<fun r='_ZNK4llvm3ARM5WinEH15RuntimeFunction1REv'/>
<fun r='_ZNK4llvm3ARM5WinEH15RuntimeFunction1LEv'/>
<fun r='_ZNK4llvm3ARM5WinEH15RuntimeFunction1CEv'/>
<fun r='_ZNK4llvm3ARM5WinEH15RuntimeFunction11StackAdjustEv'/>
