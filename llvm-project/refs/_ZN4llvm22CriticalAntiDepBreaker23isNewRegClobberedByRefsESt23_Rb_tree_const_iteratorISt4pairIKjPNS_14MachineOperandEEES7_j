<dec f='llvm/llvm/lib/CodeGen/CriticalAntiDepBreaker.h' l='99' type='bool llvm::CriticalAntiDepBreaker::isNewRegClobberedByRefs(RegRefIter RegRefBegin, RegRefIter RegRefEnd, unsigned int NewReg)'/>
<def f='llvm/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp' l='346' ll='388' type='bool llvm::CriticalAntiDepBreaker::isNewRegClobberedByRefs(RegRefIter RegRefBegin, RegRefIter RegRefEnd, unsigned int NewReg)'/>
<use f='llvm/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp' l='409' u='c' c='_ZN4llvm22CriticalAntiDepBreaker24findSuitableFreeRegisterESt23_Rb_tree_const_iteratorISt4pairIKjPNS_14MachineOperandEEES7_jjPKNS_19TargetRegisterClas1629196'/>
<doc f='llvm/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp' l='335'>// Check all machine operands that reference the antidependent register and must
// be replaced by NewReg. Return true if any of their parent instructions may
// clobber the new register.
//
// Note: AntiDepReg may be referenced by a two-address instruction such that
// it&apos;s use operand is tied to a def operand. We guard against the case in which
// the two-address instruction also defines NewReg, as may happen with
// pre/postincrement loads. In this case, both the use and def operands are in
// RegRefs because the def is inserted by PrescanInstruction and not erased
// during ScanInstruction. So checking for an instruction with definitions of
// both NewReg and AntiDepReg covers it.</doc>
