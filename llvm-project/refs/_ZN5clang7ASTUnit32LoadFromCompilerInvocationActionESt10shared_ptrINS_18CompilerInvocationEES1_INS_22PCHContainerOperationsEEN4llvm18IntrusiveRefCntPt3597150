<dec f='llvm/clang/include/clang/Frontend/ASTUnit.h' l='749' type='static clang::ASTUnit * clang::ASTUnit::LoadFromCompilerInvocationAction(std::shared_ptr&lt;CompilerInvocation&gt; CI, std::shared_ptr&lt;PCHContainerOperations&gt; PCHContainerOps, IntrusiveRefCntPtr&lt;clang::DiagnosticsEngine&gt; Diags, clang::FrontendAction * Action = nullptr, clang::ASTUnit * Unit = nullptr, bool Persistent = true, llvm::StringRef ResourceFilesPath = llvm::StringRef(), bool OnlyLocalDecls = false, clang::CaptureDiagsKind CaptureDiagnostics = CaptureDiagsKind::None, unsigned int PrecompilePreambleAfterNParses = 0, bool CacheCodeCompletionResults = false, bool IncludeBriefCommentsInCodeCompletion = false, bool UserFilesAreVolatile = false, std::unique_ptr&lt;ASTUnit&gt; * ErrAST = nullptr)'/>
<doc f='llvm/clang/include/clang/Frontend/ASTUnit.h' l='721'>/// Create an ASTUnit from a source file, via a CompilerInvocation
  /// object, by invoking the optionally provided ASTFrontendAction.
  ///
  /// \param CI - The compiler invocation to use; it must have exactly one input
  /// source file. The ASTUnit takes ownership of the CompilerInvocation object.
  ///
  /// \param PCHContainerOps - The PCHContainerOperations to use for loading and
  /// creating modules.
  ///
  /// \param Diags - The diagnostics engine to use for reporting errors; its
  /// lifetime is expected to extend past that of the returned ASTUnit.
  ///
  /// \param Action - The ASTFrontendAction to invoke. Its ownership is not
  /// transferred.
  ///
  /// \param Unit - optionally an already created ASTUnit. Its ownership is not
  /// transferred.
  ///
  /// \param Persistent - if true the returned ASTUnit will be complete.
  /// false means the caller is only interested in getting info through the
  /// provided \see Action.
  ///
  /// \param ErrAST - If non-null and parsing failed without any AST to return
  /// (e.g. because the PCH could not be loaded), this accepts the ASTUnit
  /// mainly to allow the caller to see the diagnostics.
  /// This will only receive an ASTUnit if a new one was created. If an already
  /// created ASTUnit was passed in \p Unit then the caller can check that.
  ///</doc>
<def f='llvm/clang/lib/Frontend/ASTUnit.cpp' l='1509' ll='1652' type='static clang::ASTUnit * clang::ASTUnit::LoadFromCompilerInvocationAction(std::shared_ptr&lt;CompilerInvocation&gt; CI, std::shared_ptr&lt;PCHContainerOperations&gt; PCHContainerOps, IntrusiveRefCntPtr&lt;clang::DiagnosticsEngine&gt; Diags, clang::FrontendAction * Action = nullptr, clang::ASTUnit * Unit = nullptr, bool Persistent = true, llvm::StringRef ResourceFilesPath = llvm::StringRef(), bool OnlyLocalDecls = false, clang::CaptureDiagsKind CaptureDiagnostics = CaptureDiagsKind::None, unsigned int PrecompilePreambleAfterNParses = 0, bool CacheCodeCompletionResults = false, bool IncludeBriefCommentsInCodeCompletion = false, bool UserFilesAreVolatile = false, std::unique_ptr&lt;ASTUnit&gt; * ErrAST = nullptr)'/>
<use f='llvm/clang/tools/c-index-test/core_main.cpp' l='229' u='c' c='_ZL18printSourceSymbolsPKcN4llvm8ArrayRefIS0_EEbb'/>
<use f='llvm/clang/tools/libclang/Indexing.cpp' l='593' u='c' c='_ZL26clang_indexSourceFile_ImplPvS_P16IndexerCallbacksjjPKcPKS3_iN4llvm8ArrayRefI13CXUnsavedFileEEPP21CXTranslationUnitImplj'/>
