<def f='llvm/llvm/include/llvm/CodeGen/TargetInstrInfo.h' l='1444' ll='1447' type='std::pair&lt;uint16_t, uint16_t&gt; llvm::TargetInstrInfo::getExecutionDomain(const llvm::MachineInstr &amp; MI) const'/>
<doc f='llvm/llvm/include/llvm/CodeGen/TargetInstrInfo.h' l='1425'>/// Return the current execution domain and bit mask of
  /// possible domains for instruction.
  ///
  /// Some micro-architectures have multiple execution domains, and multiple
  /// opcodes that perform the same operation in different domains.  For
  /// example, the x86 architecture provides the por, orps, and orpd
  /// instructions that all do the same thing.  There is a latency penalty if a
  /// register is written in one domain and read in another.
  ///
  /// This function returns a pair (domain, mask) containing the execution
  /// domain of MI, and a bit mask of possible domains.  The setExecutionDomain
  /// function can be used to change the opcode to one of the domains in the
  /// bit mask.  Instructions whose execution domain can&apos;t be changed should
  /// return a 0 mask.
  ///
  /// The execution domain numbers don&apos;t have any special meaning except domain
  /// 0 is used for instructions that are not associated with any interesting
  /// execution domain.
  ///</doc>
<use f='llvm/llvm/lib/CodeGen/ExecutionDomainFix.cpp' l='223' u='c' c='_ZN4llvm18ExecutionDomainFix10visitInstrEPNS_12MachineInstrE'/>
