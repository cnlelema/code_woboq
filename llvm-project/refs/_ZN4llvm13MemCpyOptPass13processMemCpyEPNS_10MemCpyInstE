<dec f='llvm/llvm/include/llvm/Transforms/Scalar/MemCpyOptimizer.h' l='62' type='bool llvm::MemCpyOptPass::processMemCpy(llvm::MemCpyInst * M)'/>
<def f='llvm/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp' l='1223' ll='1308' type='bool llvm::MemCpyOptPass::processMemCpy(llvm::MemCpyInst * M)'/>
<use f='llvm/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp' l='1442' u='c' c='_ZN4llvm13MemCpyOptPass17iterateOnFunctionERNS_8FunctionE'/>
<doc f='llvm/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp' l='1218'>/// Perform simplification of memcpy&apos;s.  If we have memcpy A
/// which copies X to Y, and memcpy B which copies Y to Z, then we can rewrite
/// B to be a memcpy from X to Z (or potentially a memmove, depending on
/// circumstances). This allows later passes to remove the first memcpy
/// altogether.</doc>
