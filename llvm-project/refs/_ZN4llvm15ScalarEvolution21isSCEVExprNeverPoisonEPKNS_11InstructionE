<dec f='llvm/llvm/include/llvm/Analysis/ScalarEvolution.h' l='1807' type='bool llvm::ScalarEvolution::isSCEVExprNeverPoison(const llvm::Instruction * I)'/>
<doc f='llvm/llvm/include/llvm/Analysis/ScalarEvolution.h' l='1791'>/// Return true if the SCEV corresponding to \p I is never poison.  Proving
  /// this is more complex than proving that just \p I is never poison, since
  /// SCEV commons expressions across control flow, and you can have cases
  /// like:
  ///
  ///   idx0 = a + b;
  ///   ptr[idx0] = 100;
  ///   if (&lt;condition&gt;) {
  ///     idx1 = a +nsw b;
  ///     ptr[idx1] = 200;
  ///   }
  ///
  /// where the SCEV expression (+ a b) is guaranteed to not be poison (and
  /// hence not sign-overflow) only if &quot;&lt;condition&gt;&quot; is true.  Since both
  /// `idx0` and `idx1` will be mapped to the same SCEV expression, (+ a b),
  /// it is not okay to annotate (+ a b) with &lt;nsw&gt; in the above example.</doc>
<use f='llvm/llvm/lib/Analysis/ScalarEvolution.cpp' l='5951' u='c' c='_ZN4llvm15ScalarEvolution20getNoWrapFlagsFromUBEPKNS_5ValueE'/>
<def f='llvm/llvm/lib/Analysis/ScalarEvolution.cpp' l='5954' ll='6008' type='bool llvm::ScalarEvolution::isSCEVExprNeverPoison(const llvm::Instruction * I)'/>
<use f='llvm/llvm/lib/Analysis/ScalarEvolution.cpp' l='6012' u='c' c='_ZN4llvm15ScalarEvolution19isAddRecNeverPoisonEPKNS_11InstructionEPKNS_4LoopE'/>
