<dec f='llvm/llvm/include/llvm/Transforms/Utils/Cloning.h' l='146' type='void llvm::CloneAndPruneIntoFromInst(llvm::Function * NewFunc, const llvm::Function * OldFunc, const llvm::Instruction * StartingInst, ValueToValueMapTy &amp; VMap, bool ModuleLevelChanges, SmallVectorImpl&lt;llvm::ReturnInst *&gt; &amp; Returns, const char * NameSuffix = &quot;&quot;, llvm::ClonedCodeInfo * CodeInfo = nullptr)'/>
<def f='llvm/llvm/lib/Transforms/Utils/CloneFunction.cpp' l='433' ll='701' type='void llvm::CloneAndPruneIntoFromInst(llvm::Function * NewFunc, const llvm::Function * OldFunc, const llvm::Instruction * StartingInst, ValueToValueMapTy &amp; VMap, bool ModuleLevelChanges, SmallVectorImpl&lt;llvm::ReturnInst *&gt; &amp; Returns, const char * NameSuffix = &quot;&quot;, llvm::ClonedCodeInfo * CodeInfo = nullptr)'/>
<use f='llvm/llvm/lib/Transforms/Utils/CloneFunction.cpp' l='718' u='c' c='_ZN4llvm25CloneAndPruneFunctionIntoEPNS_8FunctionEPKS0_RNS_8ValueMapIPKNS_5ValueENS_14WeakTrackingVHENS_14ValueMapConfigIS7_NS_3sys10SmartMutexILb0EEE1278870'/>
<doc f='llvm/llvm/lib/Transforms/Utils/CloneFunction.cpp' l='430'>/// This works like CloneAndPruneFunctionInto, except that it does not clone the
/// entire function. Instead it starts at an instruction provided by the caller
/// and copies (and prunes) only the code reachable from that instruction.</doc>
