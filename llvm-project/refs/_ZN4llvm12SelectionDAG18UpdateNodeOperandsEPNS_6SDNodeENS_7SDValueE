<dec f='llvm/llvm/include/llvm/CodeGen/SelectionDAG.h' l='1201' type='llvm::SDNode * llvm::SelectionDAG::UpdateNodeOperands(llvm::SDNode * N, llvm::SDValue Op)'/>
<doc f='llvm/llvm/include/llvm/CodeGen/SelectionDAG.h' l='1195'>/// *Mutate* the specified node in-place to have the
  /// specified operands.  If the resultant node already exists in the DAG,
  /// this does not modify the specified node, instead it returns the node that
  /// already exists.  If the resultant node does not exist in the DAG, the
  /// input node is returned.  As a degenerate case, if you specify the same
  /// input operands as the node already has, the input node is returned.</doc>
<use f='llvm/llvm/lib/CodeGen/SelectionDAG/LegalizeFloatTypes.cpp' l='920' u='c' c='_ZN4llvm16DAGTypeLegalizer18SoftenFloatOp_FABSEPNS_6SDNodeE'/>
<use f='llvm/llvm/lib/CodeGen/SelectionDAG/LegalizeFloatTypes.cpp' l='939' u='c' c='_ZN4llvm16DAGTypeLegalizer18SoftenFloatOp_FNEGEPNS_6SDNodeE'/>
<use f='llvm/llvm/lib/CodeGen/SelectionDAG/LegalizeIntegerTypes.cpp' l='1356' u='c' c='_ZN4llvm16DAGTypeLegalizer29PromoteIntOp_SCALAR_TO_VECTOREPNS_6SDNodeE'/>
<use f='llvm/llvm/lib/CodeGen/SelectionDAG/LegalizeIntegerTypes.cpp' l='1414' u='c' c='_ZN4llvm16DAGTypeLegalizer23PromoteIntOp_SINT_TO_FPEPNS_6SDNodeE'/>
<use f='llvm/llvm/lib/CodeGen/SelectionDAG/LegalizeIntegerTypes.cpp' l='1504' u='c' c='_ZN4llvm16DAGTypeLegalizer23PromoteIntOp_UINT_TO_FPEPNS_6SDNodeE'/>
<use f='llvm/llvm/lib/CodeGen/SelectionDAG/LegalizeIntegerTypes.cpp' l='1538' u='c' c='_ZN4llvm16DAGTypeLegalizer28PromoteIntOp_FRAMERETURNADDREPNS_6SDNodeE'/>
<use f='llvm/llvm/lib/CodeGen/SelectionDAG/LegalizeIntegerTypes.cpp' l='3775' u='c' c='_ZN4llvm16DAGTypeLegalizer22ExpandIntOp_RETURNADDREPNS_6SDNodeE'/>
<def f='llvm/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp' l='7625' ll='7648' type='llvm::SDNode * llvm::SelectionDAG::UpdateNodeOperands(llvm::SDNode * N, llvm::SDValue Op)'/>
<doc f='llvm/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp' l='7619'>/// UpdateNodeOperands - *Mutate* the specified node in-place to have the
/// specified operands.  If the resultant node already exists in the DAG,
/// this does not modify the specified node, instead it returns the node that
/// already exists.  If the resultant node does not exist in the DAG, the
/// input node is returned.  As a degenerate case, if you specify the same
/// input operands as the node already has, the input node is returned.</doc>
