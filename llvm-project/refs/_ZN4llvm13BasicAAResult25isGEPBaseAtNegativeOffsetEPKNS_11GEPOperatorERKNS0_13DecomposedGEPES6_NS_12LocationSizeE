<dec f='llvm/llvm/include/llvm/Analysis/BasicAliasAnalysis.h' l='175' type='static bool llvm::BasicAAResult::isGEPBaseAtNegativeOffset(const llvm::GEPOperator * GEPOp, const llvm::BasicAAResult::DecomposedGEP &amp; DecompGEP, const llvm::BasicAAResult::DecomposedGEP &amp; DecompObject, llvm::LocationSize ObjectAccessSize)'/>
<def f='llvm/llvm/lib/Analysis/BasicAliasAnalysis.cpp' l='1251' ll='1282' type='static bool llvm::BasicAAResult::isGEPBaseAtNegativeOffset(const llvm::GEPOperator * GEPOp, const llvm::BasicAAResult::DecomposedGEP &amp; DecompGEP, const llvm::BasicAAResult::DecomposedGEP &amp; DecompObject, llvm::LocationSize MaybeObjectAccessSize)'/>
<use f='llvm/llvm/lib/Analysis/BasicAliasAnalysis.cpp' l='1315' u='c' c='_ZN4llvm13BasicAAResult8aliasGEPEPKNS_11GEPOperatorENS_12LocationSizeERKNS_9AAMDNodesEPKNS_5ValueES4_S7_SA_SA_RNS_11AAQueryInfoE'/>
<use f='llvm/llvm/lib/Analysis/BasicAliasAnalysis.cpp' l='1324' u='c' c='_ZN4llvm13BasicAAResult8aliasGEPEPKNS_11GEPOperatorENS_12LocationSizeERKNS_9AAMDNodesEPKNS_5ValueES4_S7_SA_SA_RNS_11AAQueryInfoE'/>
<doc f='llvm/llvm/lib/Analysis/BasicAliasAnalysis.cpp' l='1220'>// If a we have (a) a GEP and (b) a pointer based on an alloca, and the
// beginning of the object the GEP points would have a negative offset with
// repsect to the alloca, that means the GEP can not alias pointer (b).
// Note that the pointer based on the alloca may not be a GEP. For
// example, it may be the alloca itself.
// The same applies if (b) is based on a GlobalVariable. Note that just being
// based on isIdentifiedObject() is not enough - we need an identified object
// that does not permit access to negative offsets. For example, a negative
// offset from a noalias argument or call can be inbounds w.r.t the actual
// underlying object.
//
// For example, consider:
//
//   struct { int f0, int f1, ...} foo;
//   foo alloca;
//   foo* random = bar(alloca);
//   int *f0 = &amp;alloca.f0
//   int *f1 = &amp;random-&gt;f1;
//
// Which is lowered, approximately, to:
//
//  %alloca = alloca %struct.foo
//  %random = call %struct.foo* @random(%struct.foo* %alloca)
//  %f0 = getelementptr inbounds %struct, %struct.foo* %alloca, i32 0, i32 0
//  %f1 = getelementptr inbounds %struct, %struct.foo* %random, i32 0, i32 1
//
// Assume %f1 and %f0 alias. Then %f1 would point into the object allocated
// by %alloca. Since the %f1 GEP is inbounds, that means %random must also
// point into the same object. But since %f0 points to the beginning of %alloca,
// the highest %f1 can be is (%alloca + 3). This means %random can not be higher
// than (%alloca - 1), and so is not inbounds, a contradiction.</doc>
