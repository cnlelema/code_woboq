<dec f='llvm/llvm/include/llvm/IR/DebugInfoMetadata.h' l='1499' type='unsigned int llvm::DILocation::getDiscriminator() const'/>
<def f='llvm/llvm/include/llvm/IR/DebugInfoMetadata.h' l='1961' ll='1965' type='unsigned int llvm::DILocation::getDiscriminator() const'/>
<use f='llvm/llvm/include/llvm/IR/DebugInfoMetadata.h' l='1985' u='c' c='_ZNK4llvm10DILocation20getBaseDiscriminatorEv'/>
<use f='llvm/llvm/include/llvm/IR/DebugInfoMetadata.h' l='1989' u='c' c='_ZNK4llvm10DILocation20getDuplicationFactorEv'/>
<use f='llvm/llvm/include/llvm/IR/DebugInfoMetadata.h' l='1993' u='c' c='_ZNK4llvm10DILocation17getCopyIdentifierEv'/>
<use f='llvm/llvm/include/llvm/IR/DebugInfoMetadata.h' l='1998' u='c' c='_ZNK4llvm10DILocation26cloneWithBaseDiscriminatorEj'/>
<doc f='llvm/llvm/include/llvm/IR/DebugInfoMetadata.h' l='1465'>/// Get the DWARF discriminator.
  ///
  /// DWARF discriminators distinguish identical file locations between
  /// instructions that are on different basic blocks.
  ///
  /// There are 3 components stored in discriminator, from lower bits:
  ///
  /// Base discriminator: assigned by AddDiscriminators pass to identify IRs
  ///                     that are defined by the same source line, but
  ///                     different basic blocks.
  /// Duplication factor: assigned by optimizations that will scale down
  ///                     the execution frequency of the original IR.
  /// Copy Identifier: assigned by optimizations that clones the IR.
  ///                  Each copy of the IR will be assigned an identifier.
  ///
  /// Encoding:
  ///
  /// The above 3 components are encoded into a 32bit unsigned integer in
  /// order. If the lowest bit is 1, the current component is empty, and the
  /// next component will start in the next bit. Otherwise, the current
  /// component is non-empty, and its content starts in the next bit. The
  /// value of each components is either 5 bit or 12 bit: if the 7th bit
  /// is 0, the bit 2~6 (5 bits) are used to represent the component; if the
  /// 7th bit is 1, the bit 2~6 (5 bits) and 8~14 (7 bits) are combined to
  /// represent the component. Thus, the number of bits used for a component
  /// is either 0 (if it and all the next components are empty); 1 - if it is
  /// empty; 7 - if its value is up to and including 0x1f (lsb and msb are both
  /// 0); or 14, if its value is up to and including 0x1ff. Note that the last
  /// component is also capped at 0x1ff, even in the case when both first
  /// components are 0, and we&apos;d technically have 29 bits available.
  ///
  /// For precise control over the data being encoded in the discriminator,
  /// use encodeDiscriminator/decodeDiscriminator.</doc>
<use f='llvm/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp' l='546' u='c' c='_ZN4llvm16DwarfCompileUnit24constructInlinedScopeDIEEPNS_12LexicalScopeE'/>
<use f='llvm/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp' l='548' u='c' c='_ZN4llvm16DwarfCompileUnit24constructInlinedScopeDIEEPNS_12LexicalScopeE'/>
<use f='llvm/llvm/lib/Target/X86/X86DiscriminateMemOps.cpp' l='144' u='c' c='_ZN12_GLOBAL__N_121X86DiscriminateMemOps20runOnMachineFunctionERN4llvm15MachineFunctionE'/>
