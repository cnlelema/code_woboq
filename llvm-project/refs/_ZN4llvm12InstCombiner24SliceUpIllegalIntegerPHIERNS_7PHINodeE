<dec f='llvm/llvm/lib/Transforms/InstCombine/InstCombineInternal.h' l='368' type='llvm::Instruction * llvm::InstCombiner::SliceUpIllegalIntegerPHI(llvm::PHINode &amp; PN)'/>
<def f='llvm/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp' l='951' ll='1118' type='llvm::Instruction * llvm::InstCombiner::SliceUpIllegalIntegerPHI(llvm::PHINode &amp; FirstPhi)'/>
<use f='llvm/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp' l='1257' u='c' c='_ZN4llvm12InstCombiner12visitPHINodeERNS_7PHINodeE'/>
<doc f='llvm/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp' l='943'>/// This is an integer PHI and we know that it has an illegal type: see if it is
/// only used by trunc or trunc(lshr) operations. If so, we split the PHI into
/// the various pieces being extracted. This sort of thing is introduced when
/// SROA promotes an aggregate to large integer values.
///
/// TODO: The user of the trunc may be an bitcast to float/double/vector or an
/// inttoptr.  We should produce new PHIs in the right type.
///</doc>
