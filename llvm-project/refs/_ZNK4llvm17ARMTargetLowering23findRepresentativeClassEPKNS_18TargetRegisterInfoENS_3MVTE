<dec f='llvm/llvm/lib/Target/ARM/ARMISelLowering.h' l='607' type='std::pair&lt;const TargetRegisterClass *, uint8_t&gt; llvm::ARMTargetLowering::findRepresentativeClass(const llvm::TargetRegisterInfo * TRI, llvm::MVT VT) const'/>
<inh f='llvm/llvm/include/llvm/CodeGen/TargetLowering.h' l='1989' c='_ZNK4llvm18TargetLoweringBase23findRepresentativeClassEPKNS_18TargetRegisterInfoENS_3MVTE'/>
<def f='llvm/llvm/lib/Target/ARM/ARMISelLowering.cpp' l='1247' ll='1283' type='std::pair&lt;const TargetRegisterClass *, uint8_t&gt; llvm::ARMTargetLowering::findRepresentativeClass(const llvm::TargetRegisterInfo * TRI, llvm::MVT VT) const'/>
<doc f='llvm/llvm/lib/Target/ARM/ARMISelLowering.cpp' l='1237'>// FIXME: It might make sense to define the representative register class as the
// nearest super-register that has a non-null superset. For example, DPR_VFP2 is
// a super-register of SPR, and DPR is a superset if DPR_VFP2. Consequently,
// SPR&apos;s representative would be DPR_VFP2. This should work well if register
// pressure tracking were modified such that a register use would increment the
// pressure of the register class&apos;s representative and all of it&apos;s super
// classes&apos; representatives transitively. We have not implemented this because
// of the difficulty prior to coalescing of modeling operand register classes
// due to the common occurrence of cross class copies and subregister insertions
// and extractions.</doc>
