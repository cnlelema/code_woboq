<def f='llvm/clang/lib/Format/BreakableToken.h' l='89' ll='243'/>
<ovr f='llvm/clang/lib/Format/BreakableToken.h' l='245' c='clang::format::BreakableStringLiteral'/>
<ovr f='llvm/clang/lib/Format/BreakableToken.h' l='286' c='clang::format::BreakableComment'/>
<size>32</size>
<doc f='llvm/clang/lib/Format/BreakableToken.h' l='36'>/// Base class for tokens / ranges of tokens that can allow breaking
/// within the tokens - for example, to avoid whitespace beyond the column
/// limit, or to reflow text.
///
/// Generally, a breakable token consists of logical lines, addressed by a line
/// index. For example, in a sequence of line comments, each line comment is its
/// own logical line; similarly, for a block comment, each line in the block
/// comment is on its own logical line.
///
/// There are two methods to compute the layout of the token:
/// - getRangeLength measures the number of columns needed for a range of text
///   within a logical line, and
/// - getContentStartColumn returns the start column at which we want the
///   content of a logical line to start (potentially after introducing a line
///   break).
///
/// The mechanism to adapt the layout of the breakable token is organised
/// around the concept of a \c Split, which is a whitespace range that signifies
/// a position of the content of a token where a reformatting might be done.
///
/// Operating with splits is divided into two operations:
/// - getSplit, for finding a split starting at a position,
/// - insertBreak, for executing the split using a whitespace manager.
///
/// There is a pair of operations that are used to compress a long whitespace
/// range with a single space if that will bring the line length under the
/// column limit:
/// - getLineLengthAfterCompression, for calculating the size in columns of the
///   line after a whitespace range has been compressed, and
/// - compressWhitespace, for executing the whitespace compression using a
///   whitespace manager; note that the compressed whitespace may be in the
///   middle of the original line and of the reformatted line.
///
/// For tokens where the whitespace before each line needs to be also
/// reformatted, for example for tokens supporting reflow, there are analogous
/// operations that might be executed before the main line breaking occurs:
/// - getReflowSplit, for finding a split such that the content preceding it
///   needs to be specially reflown,
/// - reflow, for executing the split using a whitespace manager,
/// - introducesBreakBefore, for checking if reformatting the beginning
///   of the content introduces a line break before it,
/// - adaptStartOfLine, for executing the reflow using a whitespace
///   manager.
///
/// For tokens that require the whitespace after the last line to be
/// reformatted, for example in multiline jsdoc comments that require the
/// trailing &apos;*/&apos; to be on a line of itself, there are analogous operations
/// that might be executed after the last line has been reformatted:
/// - getSplitAfterLastLine, for finding a split after the last line that needs
///   to be reflown,
/// - replaceWhitespaceAfterLastLine, for executing the reflow using a
///   whitespace manager.
///</doc>
<fun r='_ZN5clang6format14BreakableTokenD1Ev'/>
<fun r='_ZNK5clang6format14BreakableToken12getLineCountEv'/>
<fun r='_ZNK5clang6format14BreakableToken14getRangeLengthEjjmj'/>
<fun r='_ZNK5clang6format14BreakableToken18getRemainingLengthEjjj'/>
<fun r='_ZNK5clang6format14BreakableToken21getContentStartColumnEjb'/>
<fun r='_ZNK5clang6format14BreakableToken16getContentIndentEj'/>
<fun r='_ZNK5clang6format14BreakableToken8getSplitEjjjjRN4llvm5RegexE'/>
<fun r='_ZNK5clang6format14BreakableToken11insertBreakEjjSt4pairImjEjRNS0_17WhitespaceManagerE'/>
<fun r='_ZNK5clang6format14BreakableToken25getLengthAfterCompressionEjSt4pairImjE'/>
<fun r='_ZNK5clang6format14BreakableToken18compressWhitespaceEjjSt4pairImjERNS0_17WhitespaceManagerE'/>
<fun r='_ZNK5clang6format14BreakableToken14supportsReflowEv'/>
<fun r='_ZNK5clang6format14BreakableToken14getReflowSplitEjRN4llvm5RegexE'/>
<fun r='_ZNK5clang6format14BreakableToken6reflowEjRNS0_17WhitespaceManagerE'/>
<fun r='_ZNK5clang6format14BreakableToken26introducesBreakBeforeTokenEv'/>
<fun r='_ZNK5clang6format14BreakableToken16adaptStartOfLineEjRNS0_17WhitespaceManagerE'/>
<fun r='_ZNK5clang6format14BreakableToken21getSplitAfterLastLineEj'/>
<fun r='_ZNK5clang6format14BreakableToken30replaceWhitespaceAfterLastLineEjSt4pairImjERNS0_17WhitespaceManagerE'/>
<fun r='_ZNK5clang6format14BreakableToken15updateNextTokenERNS0_9LineStateE'/>
<fun r='_ZN5clang6format14BreakableTokenC1ERKNS0_11FormatTokenEbNS0_8encoding8EncodingERKNS0_11FormatStyleE'/>
<mbr r='clang::format::BreakableToken::Tok' o='64' t='const clang::format::FormatToken &amp;'/>
<mbr r='clang::format::BreakableToken::InPPDirective' o='128' t='const bool'/>
<mbr r='clang::format::BreakableToken::Encoding' o='160' t='const encoding::Encoding'/>
<mbr r='clang::format::BreakableToken::Style' o='192' t='const clang::format::FormatStyle &amp;'/>
<fun r='_ZNK5clang6format14BreakableToken25getLengthAfterCompressionEjSt4pairImjE'/>
