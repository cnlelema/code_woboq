<dec f='llvm/clang/include/clang/Sema/Sema.h' l='4497' type='bool clang::Sema::CheckQualifiedMemberReference(clang::Expr * BaseExpr, clang::QualType BaseType, const clang::CXXScopeSpec &amp; SS, const clang::LookupResult &amp; R)'/>
<def f='llvm/clang/lib/Sema/SemaExprMember.cpp' l='549' ll='586' type='bool clang::Sema::CheckQualifiedMemberReference(clang::Expr * BaseExpr, clang::QualType BaseType, const clang::CXXScopeSpec &amp; SS, const clang::LookupResult &amp; R)'/>
<use f='llvm/clang/lib/Sema/SemaExprMember.cpp' l='1053' u='c' c='_ZN5clang4Sema24BuildMemberReferenceExprEPNS_4ExprENS_8QualTypeENS_14SourceLocationEbRKNS_12CXXScopeSpecES4_PNS_9NamedDeclERNS_12LookupResultEPKNS_24T696367'/>
<doc f='llvm/clang/lib/Sema/SemaExprMember.cpp' l='537'>// Check whether the declarations we found through a nested-name
// specifier in a member expression are actually members of the base
// type.  The restriction here is:
//
//   C++ [expr.ref]p2:
//     ... In these cases, the id-expression shall name a
//     member of the class or of one of its base classes.
//
// So it&apos;s perfectly legitimate for the nested-name specifier to name
// an unrelated class, and for us to find an overload set including
// decls from classes which are not superclasses, as long as the decl
// we actually pick through overload resolution is from a superclass.</doc>
