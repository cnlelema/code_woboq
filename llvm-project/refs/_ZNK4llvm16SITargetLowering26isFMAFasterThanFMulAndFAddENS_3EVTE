<dec f='llvm/llvm/lib/Target/AMDGPU/SIISelLowering.h' l='325' type='bool llvm::SITargetLowering::isFMAFasterThanFMulAndFAdd(llvm::EVT VT) const'/>
<inh f='llvm/llvm/include/llvm/CodeGen/TargetLowering.h' l='2517' c='_ZNK4llvm18TargetLoweringBase26isFMAFasterThanFMulAndFAddENS_3EVTE'/>
<def f='llvm/llvm/lib/Target/AMDGPU/SIISelLowering.cpp' l='3632' ll='3656' type='bool llvm::SITargetLowering::isFMAFasterThanFMulAndFAdd(llvm::EVT VT) const'/>
<use f='llvm/llvm/lib/Target/AMDGPU/SIISelLowering.cpp' l='8789' u='c' c='_ZNK4llvm16SITargetLowering14getFusedOpcodeERKNS_12SelectionDAGEPKNS_6SDNodeES6_'/>
<doc f='llvm/llvm/lib/Target/AMDGPU/SIISelLowering.cpp' l='3617'>// Answering this is somewhat tricky and depends on the specific device which
// have different rates for fma or all f64 operations.
//
// v_fma_f64 and v_mul_f64 always take the same number of cycles as each other
// regardless of which device (although the number of cycles differs between
// devices), so it is always profitable for f64.
//
// v_fma_f32 takes 4 or 16 cycles depending on the device, so it is profitable
// only on full rate devices. Normally, we should prefer selecting v_mad_f32
// which we can always do even without fused FP ops since it returns the same
// result as the separate operations and since it is always full
// rate. Therefore, we lie and report that it is not faster for f32. v_mad_f32
// however does not support denormals, so we do report fma as faster if we have
// a fast fma device and require denormals.
//</doc>
