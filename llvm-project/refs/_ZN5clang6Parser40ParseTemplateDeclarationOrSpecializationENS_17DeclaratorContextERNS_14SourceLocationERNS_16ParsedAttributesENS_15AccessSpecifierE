<dec f='llvm/clang/include/clang/Parse/Parser.h' l='2975' type='clang::Decl * clang::Parser::ParseTemplateDeclarationOrSpecialization(clang::DeclaratorContext Context, clang::SourceLocation &amp; DeclEnd, clang::ParsedAttributes &amp; AccessAttrs, clang::AccessSpecifier AS)'/>
<use f='llvm/clang/lib/Parse/ParseDeclCXX.cpp' l='2543' u='c' c='_ZN5clang6Parser30ParseCXXClassMemberDeclarationENS_15AccessSpecifierERNS_16ParsedAttributesERKNS0_18ParsedTemplateInfoEPNS_21ParsingDeclRAIIObjectE'/>
<use f='llvm/clang/lib/Parse/ParseTemplate.cpp' l='35' u='c' c='_ZN5clang6Parser36ParseDeclarationStartingWithTemplateENS_17DeclaratorContextERNS_14SourceLocationERNS_16ParsedAttributesENS_15AccessSpecifierE'/>
<def f='llvm/clang/lib/Parse/ParseTemplate.cpp' l='54' ll='149' type='clang::Decl * clang::Parser::ParseTemplateDeclarationOrSpecialization(clang::DeclaratorContext Context, clang::SourceLocation &amp; DeclEnd, clang::ParsedAttributes &amp; AccessAttrs, clang::AccessSpecifier AS)'/>
<doc f='llvm/clang/lib/Parse/ParseTemplate.cpp' l='39'>/// Parse a template declaration or an explicit specialization.
///
/// Template declarations include one or more template parameter lists
/// and either the function or class template declaration. Explicit
/// specializations contain one or more &apos;template &lt; &gt;&apos; prefixes
/// followed by a (possibly templated) declaration. Since the
/// syntactic form of both features is nearly identical, we parse all
/// of the template headers together and let semantic analysis sort
/// the declarations from the explicit specializations.
///
///       template-declaration: [C++ temp]
///         &apos;export&apos;[opt] &apos;template&apos; &apos;&lt;&apos; template-parameter-list &apos;&gt;&apos; declaration
///
///       explicit-specialization: [ C++ temp.expl.spec]
///         &apos;template&apos; &apos;&lt;&apos; &apos;&gt;&apos; declaration</doc>
