<dec f='llvm/llvm/include/llvm/Transforms/Utils/UnrollLoop.h' l='81' type='llvm::LoopUnrollResult llvm::UnrollLoop(llvm::Loop * L, llvm::UnrollLoopOptions ULO, llvm::LoopInfo * LI, llvm::ScalarEvolution * SE, llvm::DominatorTree * DT, llvm::AssumptionCache * AC, llvm::OptimizationRemarkEmitter * ORE, bool PreserveLCSSA, llvm::Loop ** RemainderLoop = nullptr)'/>
<use f='llvm/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp' l='1107' u='c' c='_ZL15tryToUnrollLoopPN4llvm4LoopERNS_13DominatorTreeEPNS_8LoopInfoERNS_15ScalarEvolutionERKNS_19TargetTransformInfoERNS_15AssumptionCacheERNS_25Optimi6926510'/>
<def f='llvm/llvm/lib/Transforms/Utils/LoopUnroll.cpp' l='274' ll='839' type='llvm::LoopUnrollResult llvm::UnrollLoop(llvm::Loop * L, llvm::UnrollLoopOptions ULO, llvm::LoopInfo * LI, llvm::ScalarEvolution * SE, llvm::DominatorTree * DT, llvm::AssumptionCache * AC, llvm::OptimizationRemarkEmitter * ORE, bool PreserveLCSSA, llvm::Loop ** RemainderLoop = nullptr)'/>
<doc f='llvm/llvm/lib/Transforms/Utils/LoopUnroll.cpp' l='235'>/// Unroll the given loop by Count. The loop must be in LCSSA form.  Unrolling
/// can only fail when the loop&apos;s latch block is not terminated by a conditional
/// branch instruction. However, if the trip count (and multiple) are not known,
/// loop unrolling will mostly produce more code that is no faster.
///
/// TripCount is the upper bound of the iteration on which control exits
/// LatchBlock. Control may exit the loop prior to TripCount iterations either
/// via an early branch in other loop block or via LatchBlock terminator. This
/// is relaxed from the general definition of trip count which is the number of
/// times the loop header executes. Note that UnrollLoop assumes that the loop
/// counter test is in LatchBlock in order to remove unnecesssary instances of
/// the test.  If control can exit the loop from the LatchBlock&apos;s terminator
/// prior to TripCount iterations, flag PreserveCondBr needs to be set.
///
/// PreserveCondBr indicates whether the conditional branch of the LatchBlock
/// needs to be preserved.  It is needed when we use trip count upper bound to
/// fully unroll the loop. If PreserveOnlyFirst is also set then only the first
/// conditional branch needs to be preserved.
///
/// Similarly, TripMultiple divides the number of times that the LatchBlock may
/// execute without exiting the loop.
///
/// If AllowRuntime is true then UnrollLoop will consider unrolling loops that
/// have a runtime (i.e. not compile time constant) trip count.  Unrolling these
/// loops require a unroll &quot;prologue&quot; that runs &quot;RuntimeTripCount % Count&quot;
/// iterations before branching into the unrolled loop.  UnrollLoop will not
/// runtime-unroll the loop if computing RuntimeTripCount will be expensive and
/// AllowExpensiveTripCount is false.
///
/// If we want to perform PGO-based loop peeling, PeelCount is set to the
/// number of iterations we want to peel off.
///
/// The LoopInfo Analysis that is passed will be kept consistent.
///
/// This utility preserves LoopInfo. It will also preserve ScalarEvolution and
/// DominatorTree if they are non-null.
///
/// If RemainderLoop is non-null, it will receive the remainder loop (if
/// required and not fully unrolled).</doc>
<use f='llvm/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp' l='952' u='c' c='_ZN4llvm26UnrollRuntimeLoopRemainderEPNS_4LoopEjbbbbPNS_8LoopInfoEPNS_15ScalarEvolutionEPNS_13DominatorTreeEPNS_15AssumptionCacheEbPS1_'/>
