<inh f='llvm/lld/wasm/Symbols.h' l='42' c='lld::wasm::Symbol'/>
<def f='llvm/lld/wasm/Symbols.h' l='396' ll='414'/>
<size>80</size>
<doc f='llvm/lld/wasm/Symbols.h' l='387'>// LazySymbol represents a symbol that is not yet in the link, but we know where
// to find it if needed. If the resolver finds both Undefined and Lazy for the
// same name, it will ask the Lazy to load a file.
//
// A special complication is the handling of weak undefined symbols. They should
// not load a file, but we have to remember we have seen both the weak undefined
// and the lazy. We represent that with a lazy symbol with a weak binding. This
// means that code looking for undefined symbols normally also has to take lazy
// symbols into consideration.</doc>
<fun r='_ZN3lld4wasm10LazySymbolC1EN4llvm9StringRefEjPNS0_9InputFileERKNS2_6object7Archive6SymbolE'/>
<fun r='_ZN3lld4wasm10LazySymbol7classofEPKNS0_6SymbolE'/>
<fun r='_ZN3lld4wasm10LazySymbol5fetchEv'/>
<mbr r='lld::wasm::LazySymbol::Signature' o='448' t='const llvm::wasm::WasmSignature *'/>
<mbr r='lld::wasm::LazySymbol::ArchiveSymbol' o='512' t='llvm::object::Archive::Symbol'/>
