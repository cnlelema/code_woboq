<dec f='llvm/clang/include/clang/Sema/SemaLambda.h' l='33' type='Optional&lt;unsigned int&gt; clang::getStackIndexOfNearestEnclosingCaptureCapableLambda(ArrayRef&lt;const sema::FunctionScopeInfo *&gt; FunctionScopes, clang::VarDecl * VarToCapture, clang::Sema &amp; S)'/>
<use f='llvm/clang/lib/Sema/SemaExprCXX.cpp' l='7469' u='c' c='_ZL57CheckIfAnyEnclosingLambdasMustCaptureAnyPotentialCapturesPN5clang4ExprEPNS_4sema15LambdaScopeInfoERNS_4SemaE'/>
<use f='llvm/clang/lib/Sema/SemaExprCXX.cpp' l='7503' u='c' c='_ZL57CheckIfAnyEnclosingLambdasMustCaptureAnyPotentialCapturesPN5clang4ExprEPNS_4sema15LambdaScopeInfoERNS_4SemaE'/>
<doc f='llvm/clang/include/clang/Sema/SemaLambda.h' l='26'>/// Examines the FunctionScopeInfo stack to determine the nearest
/// enclosing lambda (to the current lambda) that is &apos;capture-capable&apos; for
/// the variable referenced in the current lambda (i.e. \p VarToCapture).
/// If successful, returns the index into Sema&apos;s FunctionScopeInfo stack
/// of the capture-capable lambda&apos;s LambdaScopeInfo.
/// See Implementation for more detailed comments.</doc>
<def f='llvm/clang/lib/Sema/SemaLambda.cpp' l='173' ll='225' type='Optional&lt;unsigned int&gt; clang::getStackIndexOfNearestEnclosingCaptureCapableLambda(ArrayRef&lt;const sema::FunctionScopeInfo *&gt; FunctionScopes, clang::VarDecl * VarToCapture, clang::Sema &amp; S)'/>
<doc f='llvm/clang/lib/Sema/SemaLambda.cpp' l='138'>/// Examines the FunctionScopeInfo stack to determine the nearest
/// enclosing lambda (to the current lambda) that is &apos;capture-capable&apos; for
/// the variable referenced in the current lambda (i.e. \p VarToCapture).
/// If successful, returns the index into Sema&apos;s FunctionScopeInfo stack
/// of the capture-capable lambda&apos;s LambdaScopeInfo.
///
/// Given the current stack of lambdas being processed by Sema and
/// the variable of interest, to identify the nearest enclosing lambda (to the
/// current lambda at the top of the stack) that can truly capture
/// a variable, it has to have the following two properties:
///  a) &apos;capture-ready&apos; - be the innermost lambda that is &apos;capture-ready&apos;:
///     - climb down the stack (i.e. starting from the innermost and examining
///       each outer lambda step by step) checking if each enclosing
///       lambda can either implicitly or explicitly capture the variable.
///       Record the first such lambda that is enclosed in a non-dependent
///       context. If no such lambda currently exists return failure.
///  b) &apos;capture-capable&apos; - make sure the &apos;capture-ready&apos; lambda can truly
///  capture the variable by checking all its enclosing lambdas:
///     - check if all outer lambdas enclosing the &apos;capture-ready&apos; lambda
///       identified above in &apos;a&apos; can also capture the variable (this is done
///       via tryCaptureVariable for variables and CheckCXXThisCapture for
///       &apos;this&apos; by passing in the index of the Lambda identified in step &apos;a&apos;)
///
/// \param FunctionScopes - Sema&apos;s stack of nested FunctionScopeInfo&apos;s (which a
/// LambdaScopeInfo inherits from).  The current/deepest/innermost lambda
/// is at the top of the stack.
///
/// \param VarToCapture - the variable to capture.  If NULL, capture &apos;this&apos;.
///
///
/// \returns An Optional&lt;unsigned&gt; Index that if evaluates to &apos;true&apos; contains
/// the index (into Sema&apos;s FunctionScopeInfo stack) of the innermost lambda
/// which is capture-capable.  If the return value evaluates to &apos;false&apos; then
/// no lambda is capture-capable for \p VarToCapture.</doc>
