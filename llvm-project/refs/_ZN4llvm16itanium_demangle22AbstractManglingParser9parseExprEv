<dec f='llvm/llvm/include/llvm/Demangle/ItaniumDemangle.h' l='2244' type='llvm::itanium_demangle::Node * llvm::itanium_demangle::AbstractManglingParser::parseExpr()'/>
<def f='llvm/llvm/include/llvm/Demangle/ItaniumDemangle.h' l='4186' ll='4653' type='llvm::itanium_demangle::Node * llvm::itanium_demangle::AbstractManglingParser::parseExpr()'/>
<doc f='llvm/llvm/include/llvm/Demangle/ItaniumDemangle.h' l='2243'>/// Parse the &lt;expr&gt; production.</doc>
<doc f='llvm/llvm/include/llvm/Demangle/ItaniumDemangle.h' l='4142'>// &lt;expression&gt; ::= &lt;unary operator-name&gt; &lt;expression&gt;
//              ::= &lt;binary operator-name&gt; &lt;expression&gt; &lt;expression&gt;
//              ::= &lt;ternary operator-name&gt; &lt;expression&gt; &lt;expression&gt; &lt;expression&gt;
//              ::= cl &lt;expression&gt;+ E                                   # call
//              ::= cv &lt;type&gt; &lt;expression&gt;                               # conversion with one argument
//              ::= cv &lt;type&gt; _ &lt;expression&gt;* E                          # conversion with a different number of arguments
//              ::= [gs] nw &lt;expression&gt;* _ &lt;type&gt; E                     # new (expr-list) type
//              ::= [gs] nw &lt;expression&gt;* _ &lt;type&gt; &lt;initializer&gt;         # new (expr-list) type (init)
//              ::= [gs] na &lt;expression&gt;* _ &lt;type&gt; E                     # new[] (expr-list) type
//              ::= [gs] na &lt;expression&gt;* _ &lt;type&gt; &lt;initializer&gt;         # new[] (expr-list) type (init)
//              ::= [gs] dl &lt;expression&gt;                                 # delete expression
//              ::= [gs] da &lt;expression&gt;                                 # delete[] expression
//              ::= pp_ &lt;expression&gt;                                     # prefix ++
//              ::= mm_ &lt;expression&gt;                                     # prefix --
//              ::= ti &lt;type&gt;                                            # typeid (type)
//              ::= te &lt;expression&gt;                                      # typeid (expression)
//              ::= dc &lt;type&gt; &lt;expression&gt;                               # dynamic_cast&lt;type&gt; (expression)
//              ::= sc &lt;type&gt; &lt;expression&gt;                               # static_cast&lt;type&gt; (expression)
//              ::= cc &lt;type&gt; &lt;expression&gt;                               # const_cast&lt;type&gt; (expression)
//              ::= rc &lt;type&gt; &lt;expression&gt;                               # reinterpret_cast&lt;type&gt; (expression)
//              ::= st &lt;type&gt;                                            # sizeof (a type)
//              ::= sz &lt;expression&gt;                                      # sizeof (an expression)
//              ::= at &lt;type&gt;                                            # alignof (a type)
//              ::= az &lt;expression&gt;                                      # alignof (an expression)
//              ::= nx &lt;expression&gt;                                      # noexcept (expression)
//              ::= &lt;template-param&gt;
//              ::= &lt;function-param&gt;
//              ::= dt &lt;expression&gt; &lt;unresolved-name&gt;                    # expr.name
//              ::= pt &lt;expression&gt; &lt;unresolved-name&gt;                    # expr-&gt;name
//              ::= ds &lt;expression&gt; &lt;expression&gt;                         # expr.*expr
//              ::= sZ &lt;template-param&gt;                                  # size of a parameter pack
//              ::= sZ &lt;function-param&gt;                                  # size of a function parameter pack
//              ::= sP &lt;template-arg&gt;* E                                 # sizeof...(T), size of a captured template parameter pack from an alias template
//              ::= sp &lt;expression&gt;                                      # pack expansion
//              ::= tw &lt;expression&gt;                                      # throw expression
//              ::= tr                                                   # throw with no operand (rethrow)
//              ::= &lt;unresolved-name&gt;                                    # f(p), N::f(p), ::f(p),
//                                                                       # freestanding dependent name (e.g., T::x),
//                                                                       # objectless nonstatic member reference
//              ::= fL &lt;binary-operator-name&gt; &lt;expression&gt; &lt;expression&gt;
//              ::= fR &lt;binary-operator-name&gt; &lt;expression&gt; &lt;expression&gt;
//              ::= fl &lt;binary-operator-name&gt; &lt;expression&gt;
//              ::= fr &lt;binary-operator-name&gt; &lt;expression&gt;
//              ::= &lt;expr-primary&gt;</doc>
