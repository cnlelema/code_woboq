<def f='llvm/llvm/lib/Transforms/Scalar/GVNHoist.cpp' l='579' ll='592' type='bool llvm::GVNHoist::valueAnticipable(CHIArgs C, llvm::Instruction * TI) const'/>
<use f='llvm/llvm/lib/Transforms/Scalar/GVNHoist.cpp' l='722' u='c' c='_ZN4llvm8GVNHoist23findHoistableCandidatesERNS_8DenseMapIPNS_10BasicBlockENS_11SmallVectorINS_6CHIArgELj2EEENS_12DenseMapInfoIS3_EENS_6detail12DenseMa4112303'/>
<doc f='llvm/llvm/lib/Transforms/Scalar/GVNHoist.cpp' l='565'>// In the inverse CFG, the dominance frontier of basic block (BB) is the
  // point where ANTIC needs to be computed for instructions which are going
  // to be hoisted. Since this point does not change during gvn-hoist,
  // we compute it only once (on demand).
  // The ides is inspired from:
  // &quot;Partial Redundancy Elimination in SSA Form&quot;
  // ROBERT KENNEDY, SUN CHAN, SHIN-MING LIU, RAYMOND LO, PENG TU and FRED CHOW
  // They use similar idea in the forward graph to find fully redundant and
  // partially redundant expressions, here it is used in the inverse graph to
  // find fully anticipable instructions at merge point (post-dominator in
  // the inverse CFG).
  // Returns the edge via which an instruction in BB will get the values from.

  // Returns true when the values are flowing out to each edge.</doc>
