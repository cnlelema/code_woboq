<dec f='llvm/llvm/include/llvm/Transforms/Scalar/Reassociate.h' l='117' type='llvm::Value * llvm::ReassociatePass::buildMinimalMultiplyDAG(IRBuilder&lt;&gt; &amp; Builder, SmallVectorImpl&lt;reassociate::Factor&gt; &amp; Factors)'/>
<def f='llvm/llvm/lib/Transforms/Scalar/Reassociate.cpp' l='1739' ll='1795' type='llvm::Value * llvm::ReassociatePass::buildMinimalMultiplyDAG(IRBuilder&lt;&gt; &amp; Builder, SmallVectorImpl&lt;llvm::reassociate::Factor&gt; &amp; Factors)'/>
<use f='llvm/llvm/lib/Transforms/Scalar/Reassociate.cpp' l='1786' u='c' c='_ZN4llvm15ReassociatePass23buildMinimalMultiplyDAGERNS_9IRBuilderINS_14ConstantFolderENS_24IRBuilderDefaultInserterEEERNS_15SmallVectorImplINS_11reassociate6FactorEEE'/>
<use f='llvm/llvm/lib/Transforms/Scalar/Reassociate.cpp' l='1818' u='c' c='_ZN4llvm15ReassociatePass11OptimizeMulEPNS_14BinaryOperatorERNS_15SmallVectorImplINS_11reassociate10ValueEntryEEE'/>
<doc f='llvm/llvm/lib/Transforms/Scalar/Reassociate.cpp' l='1733'>/// Build a minimal multiplication DAG for (a^x)*(b^y)*(c^z)*...
///
/// Given a vector of values raised to various powers, where no two values are
/// equal and the powers are sorted in decreasing order, compute the minimal
/// DAG of multiplies to compute the final product, and return that product
/// value.</doc>
