<dec f='llvm/llvm/lib/Target/X86/X86ISelLowering.h' l='1425' type='void llvm::X86TargetLowering::emitSetJmpShadowStackFix(llvm::MachineInstr &amp; MI, llvm::MachineBasicBlock * MBB) const'/>
<def f='llvm/llvm/lib/Target/X86/X86ISelLowering.cpp' l='29864' ll='29904' type='void llvm::X86TargetLowering::emitSetJmpShadowStackFix(llvm::MachineInstr &amp; MI, llvm::MachineBasicBlock * MBB) const'/>
<use f='llvm/llvm/lib/Target/X86/X86ISelLowering.cpp' l='30017' u='c' c='_ZNK4llvm17X86TargetLowering16emitEHSjLjSetJmpERNS_12MachineInstrEPNS_17MachineBasicBlockE'/>
<doc f='llvm/llvm/lib/Target/X86/X86ISelLowering.cpp' l='29852'>/// SetJmp implies future control flow change upon calling the corresponding
/// LongJmp.
/// Instead of using the &apos;return&apos; instruction, the long jump fixes the stack and
/// performs an indirect branch. To do so it uses the registers that were stored
/// in the jump buffer (when calling SetJmp).
/// In case the shadow stack is enabled we need to fix it as well, because some
/// return addresses will be skipped.
/// The function will save the SSP for future fixing in the function
/// emitLongJmpShadowStackFix.
/// \sa emitLongJmpShadowStackFix
/// \param [in] MI The temporary Machine Instruction for the builtin.
/// \param [in] MBB The Machine Basic Block that will be modified.</doc>
