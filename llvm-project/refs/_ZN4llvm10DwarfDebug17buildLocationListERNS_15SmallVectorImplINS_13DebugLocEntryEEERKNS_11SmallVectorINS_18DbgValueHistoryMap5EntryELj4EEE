<dec f='llvm/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h' l='556' type='bool llvm::DwarfDebug::buildLocationList(SmallVectorImpl&lt;llvm::DebugLocEntry&gt; &amp; DebugLoc, const DbgValueHistoryMap::Entries &amp; Entries)'/>
<doc f='llvm/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h' l='552'>/// Build the location list for all DBG_VALUEs in the
  /// function that describe the same variable. If the resulting 
  /// list has only one entry that is valid for entire variable&apos;s
  /// scope return true.</doc>
<def f='llvm/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp' l='1206' ll='1304' type='bool llvm::DwarfDebug::buildLocationList(SmallVectorImpl&lt;llvm::DebugLocEntry&gt; &amp; DebugLoc, const DbgValueHistoryMap::Entries &amp; Entries)'/>
<use f='llvm/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp' l='1386' u='c' c='_ZN4llvm10DwarfDebug17collectEntityInfoERNS_16DwarfCompileUnitEPKNS_12DISubprogramERNS_8DenseSetISt4pairIPKNS_6DINodeEPKNS_10DILocationEENS_12DenseMapInfoISE_EEEE'/>
<doc f='llvm/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp' l='1173'>/// Build the location list for all DBG_VALUEs in the function that
/// describe the same variable. The resulting DebugLocEntries will have
/// strict monotonically increasing begin addresses and will never
/// overlap. If the resulting list has only one entry that is valid
/// throughout variable&apos;s scope return true.
//
// See the definition of DbgValueHistoryMap::Entry for an explanation of the
// different kinds of history map entries. One thing to be aware of is that if
// a debug value is ended by another entry (rather than being valid until the
// end of the function), that entry&apos;s instruction may or may not be included in
// the range, depending on if the entry is a clobbering entry (it has an
// instruction that clobbers one or more preceding locations), or if it is an
// (overlapping) debug value entry. This distinction can be seen in the example
// below. The first debug value is ended by the clobbering entry 2, and the
// second and third debug values are ended by the overlapping debug value entry
// 4.
//
// Input:
//
//   History map entries [type, end index, mi]
//
// 0 |      [DbgValue, 2, DBG_VALUE $reg0, [...] (fragment 0, 32)]
// 1 | |    [DbgValue, 4, DBG_VALUE $reg1, [...] (fragment 32, 32)]
// 2 | |    [Clobber, $reg0 = [...], -, -]
// 3   | |  [DbgValue, 4, DBG_VALUE 123, [...] (fragment 64, 32)]
// 4        [DbgValue, ~0, DBG_VALUE @g, [...] (fragment 0, 96)]
//
// Output [start, end) [Value...]:
//
// [0-1)    [(reg0, fragment 0, 32)]
// [1-3)    [(reg0, fragment 0, 32), (reg1, fragment 32, 32)]
// [3-4)    [(reg1, fragment 32, 32), (123, fragment 64, 32)]
// [4-)     [(@g, fragment 0, 96)]</doc>
