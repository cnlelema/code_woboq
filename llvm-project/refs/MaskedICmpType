<def f='llvm/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp' l='217' ll='228'/>
<doc f='llvm/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp' l='190'>/// Classify (icmp eq (A &amp; B), C) and (icmp ne (A &amp; B), C) as matching patterns
/// that can be simplified.
/// One of A and B is considered the mask. The other is the value. This is
/// described as the &quot;AMask&quot; or &quot;BMask&quot; part of the enum. If the enum contains
/// only &quot;Mask&quot;, then both A and B can be considered masks. If A is the mask,
/// then it was proven that (A &amp; C) == C. This is trivial if C == A or C == 0.
/// If both A and C are constants, this proof is also easy.
/// For the following explanations, we assume that A is the mask.
///
/// &quot;AllOnes&quot; declares that the comparison is true only if (A &amp; B) == A or all
/// bits of A are set in B.
///   Example: (icmp eq (A &amp; 3), 3) -&gt; AMask_AllOnes
///
/// &quot;AllZeros&quot; declares that the comparison is true only if (A &amp; B) == 0 or all
/// bits of A are cleared in B.
///   Example: (icmp eq (A &amp; 3), 0) -&gt; Mask_AllZeroes
///
/// &quot;Mixed&quot; declares that (A &amp; B) == C and C might or might not contain any
/// number of one bits and zero bits.
///   Example: (icmp eq (A &amp; 3), 1) -&gt; AMask_Mixed
///
/// &quot;Not&quot; means that in above descriptions &quot;==&quot; should be replaced by &quot;!=&quot;.
///   Example: (icmp ne (A &amp; 3), 3) -&gt; AMask_NotAllOnes
///
/// If the mask A contains a single bit, then the following is equivalent:
///    (icmp eq (A &amp; B), A) equals (icmp ne (A &amp; B), 0)
///    (icmp ne (A &amp; B), A) equals (icmp eq (A &amp; B), 0)</doc>
