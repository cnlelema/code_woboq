<dec f='llvm/clang/include/clang/Parse/Parser.h' l='2811' type='TypeResult clang::Parser::ParseBaseTypeSpecifier(clang::SourceLocation &amp; BaseLoc, clang::SourceLocation &amp; EndLocation)'/>
<doc f='llvm/clang/include/clang/Parse/Parser.h' l='2809'>//===--------------------------------------------------------------------===//
  // C++ 10: Derived classes [class.derived]</doc>
<def f='llvm/clang/lib/Parse/ParseDeclCXX.cpp' l='1104' ll='1236' type='TypeResult clang::Parser::ParseBaseTypeSpecifier(clang::SourceLocation &amp; BaseLoc, clang::SourceLocation &amp; EndLocation)'/>
<use f='llvm/clang/lib/Parse/ParseDeclCXX.cpp' l='2116' u='c' c='_ZN5clang6Parser18ParseBaseSpecifierEPNS_4DeclE'/>
<doc f='llvm/clang/lib/Parse/ParseDeclCXX.cpp' l='1086'>/// ParseBaseTypeSpecifier - Parse a C++ base-type-specifier which is either a
/// class name or decltype-specifier. Note that we only check that the result
/// names a type; semantic analysis will need to verify that the type names a
/// class. The result is either a type or null, depending on whether a type
/// name was found.
///
///       base-type-specifier: [C++11 class.derived]
///         class-or-decltype
///       class-or-decltype: [C++11 class.derived]
///         nested-name-specifier[opt] class-name
///         decltype-specifier
///       class-name: [C++ class.name]
///         identifier
///         simple-template-id
///
/// In C++98, instead of base-type-specifier, we have:
///
///         ::[opt] nested-name-specifier[opt] class-name</doc>
