<dec f='llvm/clang/include/clang/Analysis/RetainSummaryManager.h' l='713' type='void clang::ento::RetainSummaryManager::updateSummaryForReceiverUnconsumedSelf(const clang::ento::RetainSummary *&amp; S)'/>
<def f='llvm/clang/lib/Analysis/RetainSummaryManager.cpp' l='610' ll='617' type='void clang::ento::RetainSummaryManager::updateSummaryForReceiverUnconsumedSelf(const clang::ento::RetainSummary *&amp; S)'/>
<use f='llvm/clang/lib/Analysis/RetainSummaryManager.cpp' l='685' u='c' c='_ZN5clang4ento20RetainSummaryManager10getSummaryENS_7AnyCallEbbNS_8QualTypeE'/>
<doc f='llvm/clang/include/clang/Analysis/RetainSummaryManager.h' l='701'>/// Special case &apos;[super init];&apos; and &apos;[self init];&apos;
  ///
  /// Even though calling &apos;[super init]&apos; without assigning the result to self
  /// and checking if the parent returns &apos;nil&apos; is a bad pattern, it is common.
  /// Additionally, our Self Init checker already warns about it. To avoid
  /// overwhelming the user with messages from both checkers, we model the case
  /// of &apos;[super init]&apos; in cases when it is not consumed by another expression
  /// as if the call preserves the value of &apos;self&apos;; essentially, assuming it can
  /// never fail and return &apos;nil&apos;.
  /// Note, we don&apos;t want to just stop tracking the value since we want the
  /// RetainCount checker to report leaks and use-after-free if SelfInit checker
  /// is turned off.</doc>
