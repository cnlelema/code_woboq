<dec f='llvm/llvm/include/llvm/CodeGen/GlobalISel/MachineIRBuilder.h' l='404' type='Optional&lt;llvm::MachineInstrBuilder&gt; llvm::MachineIRBuilder::materializeGEP(unsigned int &amp; Res, unsigned int Op0, const llvm::LLT &amp; ValueTy, uint64_t Value)'/>
<doc f='llvm/llvm/include/llvm/CodeGen/GlobalISel/MachineIRBuilder.h' l='388'>/// Materialize and insert \p Res = G_GEP \p Op0, (G_CONSTANT \p Value)
  ///
  /// G_GEP adds \p Value bytes to the pointer specified by \p Op0,
  /// storing the resulting pointer in \p Res. If \p Value is zero then no
  /// G_GEP or G_CONSTANT will be created and \pre Op0 will be assigned to
  /// \p Res.
  ///
  /// \pre setBasicBlock or setMI must have been called.
  /// \pre \p Op0 must be a generic virtual register with pointer type.
  /// \pre \p ValueTy must be a scalar type.
  /// \pre \p Res must be 0. This is to detect confusion between
  ///      materializeGEP() and buildGEP().
  /// \post \p Res will either be a new generic virtual register of the same
  ///       type as \p Op0 or \p Op0 itself.
  ///
  /// \return a MachineInstrBuilder for the newly created instruction.</doc>
<use f='llvm/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp' l='491' u='c' c='_ZN4llvm12IRTranslator13translateLoadERKNS_4UserERNS_16MachineIRBuilderE'/>
<use f='llvm/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp' l='532' u='c' c='_ZN4llvm12IRTranslator14translateStoreERKNS_4UserERNS_16MachineIRBuilderE'/>
<use f='llvm/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp' l='2147' u='c' c='_ZN4llvm15LegalizerHelper20reduceLoadStoreWidthERNS_12MachineInstrEjNS_3LLTE'/>
<def f='llvm/llvm/lib/CodeGen/GlobalISel/MachineIRBuilder.cpp' l='212' ll='226' type='Optional&lt;llvm::MachineInstrBuilder&gt; llvm::MachineIRBuilder::materializeGEP(unsigned int &amp; Res, unsigned int Op0, const llvm::LLT &amp; ValueTy, uint64_t Value)'/>
