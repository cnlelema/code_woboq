<use f='llvm/clang/include/clang/Parse/Parser.h' l='2451' u='c' c='_ZN5clang6Parser23MaybeParseGNUAttributesERNS_10DeclaratorEPNS0_18LateParsedAttrListE'/>
<use f='llvm/clang/include/clang/Parse/Parser.h' l='2459' u='c' c='_ZN5clang6Parser23MaybeParseGNUAttributesERNS_16ParsedAttributesEPNS_14SourceLocationEPNS0_18LateParsedAttrListE'/>
<dec f='llvm/clang/include/clang/Parse/Parser.h' l='2461' type='void clang::Parser::ParseGNUAttributes(clang::ParsedAttributes &amp; attrs, clang::SourceLocation * endLoc = nullptr, clang::Parser::LateParsedAttrList * LateAttrs = nullptr, clang::Declarator * D = nullptr)'/>
<def f='llvm/clang/lib/Parse/ParseDecl.cpp' l='146' ll='244' type='void clang::Parser::ParseGNUAttributes(clang::ParsedAttributes &amp; attrs, clang::SourceLocation * endLoc = nullptr, clang::Parser::LateParsedAttrList * LateAttrs = nullptr, clang::Declarator * D = nullptr)'/>
<use f='llvm/clang/lib/Parse/ParseDecl.cpp' l='3423' u='c' c='_ZN5clang6Parser26ParseDeclarationSpecifiersERNS_8DeclSpecERKNS0_18ParsedTemplateInfoENS_15AccessSpecifierENS0_15DeclSpecContextEPNS0_18LateParsedAttrListE'/>
<use f='llvm/clang/lib/Parse/ParseDecl.cpp' l='5371' u='c' c='_ZN5clang6Parser25ParseTypeQualifierListOptERNS_8DeclSpecEjbbN4llvm8OptionalINS3_12function_refIFvvEEEEE'/>
<use f='llvm/clang/lib/Parse/ParseDecl.cpp' l='6081' u='c' c='_ZN5clang6Parser20ParseParenDeclaratorERNS_10DeclaratorE'/>
<doc f='llvm/clang/lib/Parse/ParseDecl.cpp' l='105'>/// ParseGNUAttributes - Parse a non-empty attributes list.
///
/// [GNU] attributes:
///         attribute
///         attributes attribute
///
/// [GNU]  attribute:
///          &apos;__attribute__&apos; &apos;(&apos; &apos;(&apos; attribute-list &apos;)&apos; &apos;)&apos;
///
/// [GNU]  attribute-list:
///          attrib
///          attribute_list &apos;,&apos; attrib
///
/// [GNU]  attrib:
///          empty
///          attrib-name
///          attrib-name &apos;(&apos; identifier &apos;)&apos;
///          attrib-name &apos;(&apos; identifier &apos;,&apos; nonempty-expr-list &apos;)&apos;
///          attrib-name &apos;(&apos; argument-expression-list [C99 6.5.2] &apos;)&apos;
///
/// [GNU]  attrib-name:
///          identifier
///          typespec
///          typequal
///          storageclass
///
/// Whether an attribute takes an &apos;identifier&apos; is determined by the
/// attrib-name. GCC&apos;s behavior here is not worth imitating:
///
///  * In C mode, if the attribute argument list starts with an identifier
///    followed by a &apos;,&apos; or an &apos;)&apos;, and the identifier doesn&apos;t resolve to
///    a type, it is parsed as an identifier. If the attribute actually
///    wanted an expression, it&apos;s out of luck (but it turns out that no
///    attributes work that way, because C constant expressions are very
///    limited).
///  * In C++ mode, if the attribute argument list starts with an identifier,
///    and the attribute *wants* an identifier, it is parsed as an identifier.
///    At block scope, any additional tokens between the identifier and the
///    &apos;,&apos; or &apos;)&apos; are ignored, otherwise they produce a parse error.
///
/// We follow the C++ model, but don&apos;t allow junk after the identifier.</doc>
<use f='llvm/clang/lib/Parse/ParseDeclCXX.cpp' l='566' u='c' c='_ZN5clang6Parser19ParseUsingDirectiveENS_17DeclaratorContextENS_14SourceLocationERS2_RNS_16ParsedAttributesE'/>
<use f='llvm/clang/lib/Parse/ParseObjc.cpp' l='35' u='c' c='_ZN5clang6Parser19MaybeSkipAttributesENS_3tok15ObjCKeywordKindE'/>
