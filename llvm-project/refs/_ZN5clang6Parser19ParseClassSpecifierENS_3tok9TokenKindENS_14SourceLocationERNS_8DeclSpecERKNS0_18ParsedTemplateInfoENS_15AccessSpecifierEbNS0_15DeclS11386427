<dec f='llvm/clang/include/clang/Parse/Parser.h' l='2775' type='void clang::Parser::ParseClassSpecifier(tok::TokenKind TagTokKind, clang::SourceLocation TagLoc, clang::DeclSpec &amp; DS, const clang::Parser::ParsedTemplateInfo &amp; TemplateInfo, clang::AccessSpecifier AS, bool EnteringContext, clang::Parser::DeclSpecContext DSC, clang::Parser::ParsedAttributesWithRange &amp; Attributes)'/>
<use f='llvm/clang/lib/Parse/ParseDecl.cpp' l='2641' u='c' c='_ZN5clang6Parser16ParseImplicitIntERNS_8DeclSpecEPNS_12CXXScopeSpecERKNS0_18ParsedTemplateInfoENS_15AccessSpecifierENS0_15DeclSpecContextERNS0_25Parse1090808'/>
<use f='llvm/clang/lib/Parse/ParseDecl.cpp' l='3809' u='c' c='_ZN5clang6Parser26ParseDeclarationSpecifiersERNS_8DeclSpecERKNS0_18ParsedTemplateInfoENS_15AccessSpecifierENS0_15DeclSpecContextEPNS0_18LateParsedAttrListE'/>
<def f='llvm/clang/lib/Parse/ParseDeclCXX.cpp' l='1386' ll='2020' type='void clang::Parser::ParseClassSpecifier(tok::TokenKind TagTokKind, clang::SourceLocation StartLoc, clang::DeclSpec &amp; DS, const clang::Parser::ParsedTemplateInfo &amp; TemplateInfo, clang::AccessSpecifier AS, bool EnteringContext, clang::Parser::DeclSpecContext DSC, clang::Parser::ParsedAttributesWithRange &amp; Attributes)'/>
<doc f='llvm/clang/lib/Parse/ParseDeclCXX.cpp' l='1346'>/// ParseClassSpecifier - Parse a C++ class-specifier [C++ class] or
/// elaborated-type-specifier [C++ dcl.type.elab]; we can&apos;t tell which
/// until we reach the start of a definition or see a token that
/// cannot start a definition.
///
///       class-specifier: [C++ class]
///         class-head &apos;{&apos; member-specification[opt] &apos;}&apos;
///         class-head &apos;{&apos; member-specification[opt] &apos;}&apos; attributes[opt]
///       class-head:
///         class-key identifier[opt] base-clause[opt]
///         class-key nested-name-specifier identifier base-clause[opt]
///         class-key nested-name-specifier[opt] simple-template-id
///                          base-clause[opt]
/// [GNU]   class-key attributes[opt] identifier[opt] base-clause[opt]
/// [GNU]   class-key attributes[opt] nested-name-specifier
///                          identifier base-clause[opt]
/// [GNU]   class-key attributes[opt] nested-name-specifier[opt]
///                          simple-template-id base-clause[opt]
///       class-key:
///         &apos;class&apos;
///         &apos;struct&apos;
///         &apos;union&apos;
///
///       elaborated-type-specifier: [C++ dcl.type.elab]
///         class-key ::[opt] nested-name-specifier[opt] identifier
///         class-key ::[opt] nested-name-specifier[opt] &apos;template&apos;[opt]
///                          simple-template-id
///
///  Note that the C++ class-specifier and elaborated-type-specifier,
///  together, subsume the C99 struct-or-union-specifier:
///
///       struct-or-union-specifier: [C99 6.7.2.1]
///         struct-or-union identifier[opt] &apos;{&apos; struct-contents &apos;}&apos;
///         struct-or-union identifier
/// [GNU]   struct-or-union attributes[opt] identifier[opt] &apos;{&apos; struct-contents
///                                                         &apos;}&apos; attributes[opt]
/// [GNU]   struct-or-union attributes[opt] identifier
///       struct-or-union:
///         &apos;struct&apos;
///         &apos;union&apos;</doc>
