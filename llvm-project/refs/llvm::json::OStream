<def f='llvm/llvm/include/llvm/Support/JSON.h' l='751' ll='836'/>
<size>160</size>
<doc f='llvm/llvm/include/llvm/Support/JSON.h' l='698'>/// json::OStream allows writing well-formed JSON without materializing
/// all structures as json::Value ahead of time.
/// It&apos;s faster, lower-level, and less safe than OS &lt;&lt; json::Value.
///
/// Only one &quot;top-level&quot; object can be written to a stream.
/// Simplest usage involves passing lambdas (Blocks) to fill in containers:
///
///   json::OStream J(OS);
///   J.array([&amp;]{
///     for (const Event &amp;E : Events)
///       J.object([&amp;] {
///         J.attribute(&quot;timestamp&quot;, int64_t(E.Time));
///         J.attributeArray(&quot;participants&quot;, [&amp;] {
///           for (const Participant &amp;P : E.Participants)
///             J.string(P.toString());
///         });
///       });
///   });
///
/// This would produce JSON like:
///
///   [
///     {
///       &quot;timestamp&quot;: 19287398741,
///       &quot;participants&quot;: [
///         &quot;King Kong&quot;,
///         &quot;Miley Cyrus&quot;,
///         &quot;Cleopatra&quot;
///       ]
///     },
///     ...
///   ]
///
/// The lower level begin/end methods (arrayBegin()) are more flexible but
/// care must be taken to pair them correctly:
///
///   json::OStream J(OS);
//    J.arrayBegin();
///   for (const Event &amp;E : Events) {
///     J.objectBegin();
///     J.attribute(&quot;timestamp&quot;, int64_t(E.Time));
///     J.attributeBegin(&quot;participants&quot;);
///     for (const Participant &amp;P : E.Participants)
///       J.value(P.toString());
///     J.attributeEnd();
///     J.objectEnd();
///   }
///   J.arrayEnd();
///
/// If the call sequence isn&apos;t valid JSON, asserts will fire in debug mode.
/// This can be mismatched begin()/end() pairs, trying to emit attributes inside
/// an array, and so on.
/// With asserts disabled, this is undefined behavior.</doc>
<fun r='_ZN4llvm4json7OStreamC1ERNS_11raw_ostreamEj'/>
<fun r='_ZN4llvm4json7OStreamD1Ev'/>
<fun r='_ZN4llvm4json7OStream5flushEv'/>
<fun r='_ZN4llvm4json7OStream5valueERKNS0_5ValueE'/>
<fun r='_ZN4llvm4json7OStream5arrayENS_12function_refIFvvEEE'/>
<fun r='_ZN4llvm4json7OStream6objectENS_12function_refIFvvEEE'/>
<fun r='_ZN4llvm4json7OStream9attributeENS_9StringRefERKNS0_5ValueE'/>
<fun r='_ZN4llvm4json7OStream14attributeArrayENS_9StringRefENS_12function_refIFvvEEE'/>
<fun r='_ZN4llvm4json7OStream15attributeObjectENS_9StringRefENS_12function_refIFvvEEE'/>
<fun r='_ZN4llvm4json7OStream10arrayBeginEv'/>
<fun r='_ZN4llvm4json7OStream8arrayEndEv'/>
<fun r='_ZN4llvm4json7OStream11objectBeginEv'/>
<fun r='_ZN4llvm4json7OStream9objectEndEv'/>
<fun r='_ZN4llvm4json7OStream14attributeBeginENS_9StringRefE'/>
<fun r='_ZN4llvm4json7OStream12attributeEndEv'/>
<fun r='_ZN4llvm4json7OStream13attributeImplENS_9StringRefENS_12function_refIFvvEEE'/>
<fun r='_ZN4llvm4json7OStream10valueBeginEv'/>
<fun r='_ZN4llvm4json7OStream7newlineEv'/>
<mbr r='llvm::json::OStream::Stack' o='0' t='llvm::SmallVector&lt;State, 16&gt;'/>
<mbr r='llvm::json::OStream::OS' o='1152' t='llvm::raw_ostream &amp;'/>
<mbr r='llvm::json::OStream::IndentSize' o='1216' t='unsigned int'/>
<mbr r='llvm::json::OStream::Indent' o='1248' t='unsigned int'/>
