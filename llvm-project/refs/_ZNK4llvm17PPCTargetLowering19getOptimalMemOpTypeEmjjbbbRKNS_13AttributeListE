<dec f='llvm/llvm/lib/Target/PowerPC/PPCISelLowering.h' l='843' type='llvm::EVT llvm::PPCTargetLowering::getOptimalMemOpType(uint64_t Size, unsigned int DstAlign, unsigned int SrcAlign, bool IsMemset, bool ZeroMemset, bool MemcpyStrSrc, const llvm::AttributeList &amp; FuncAttributes) const'/>
<doc f='llvm/llvm/lib/Target/PowerPC/PPCISelLowering.h' l='831'>/// getOptimalMemOpType - Returns the target specific optimal type for load
    /// and store operations as a result of memset, memcpy, and memmove
    /// lowering. If DstAlign is zero that means it&apos;s safe to destination
    /// alignment can satisfy any constraint. Similarly if SrcAlign is zero it
    /// means there isn&apos;t a need to check it against alignment requirement,
    /// probably because the source does not need to be loaded. If &apos;IsMemset&apos; is
    /// true, that means it&apos;s expanding a memset. If &apos;ZeroMemset&apos; is true, that
    /// means it&apos;s a memset of zero. &apos;MemcpyStrSrc&apos; indicates whether the memcpy
    /// source is constant so it does not need to be loaded.
    /// It returns EVT::Other if the type should be determined using generic
    /// target-independent logic.</doc>
<inh f='llvm/llvm/include/llvm/CodeGen/TargetLowering.h' l='1483' c='_ZNK4llvm18TargetLoweringBase19getOptimalMemOpTypeEmjjbbbRKNS_13AttributeListE'/>
<def f='llvm/llvm/lib/Target/PowerPC/PPCISelLowering.cpp' l='14474' ll='14500' type='llvm::EVT llvm::PPCTargetLowering::getOptimalMemOpType(uint64_t Size, unsigned int DstAlign, unsigned int SrcAlign, bool IsMemset, bool ZeroMemset, bool MemcpyStrSrc, const llvm::AttributeList &amp; FuncAttributes) const'/>
<doc f='llvm/llvm/lib/Target/PowerPC/PPCISelLowering.cpp' l='14463'>/// getOptimalMemOpType - Returns the target specific optimal type for load
/// and store operations as a result of memset, memcpy, and memmove
/// lowering. If DstAlign is zero that means it&apos;s safe to destination
/// alignment can satisfy any constraint. Similarly if SrcAlign is zero it
/// means there isn&apos;t a need to check it against alignment requirement,
/// probably because the source does not need to be loaded. If &apos;IsMemset&apos; is
/// true, that means it&apos;s expanding a memset. If &apos;ZeroMemset&apos; is true, that
/// means it&apos;s a memset of zero. &apos;MemcpyStrSrc&apos; indicates whether the memcpy
/// source is constant so it does not need to be loaded.
/// It returns EVT::Other if the type should be determined using generic
/// target-independent logic.</doc>
