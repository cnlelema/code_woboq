<!doctype html>
<html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1.0"><title>OperationKinds.def source code [llvm/clang/include/clang/AST/OperationKinds.def] - Woboq Code Browser</title>
<link rel="stylesheet" href="../../../../../../data/qtcreator.css" title="QtCreator"/>
<link rel="alternate stylesheet" href="../../../../../../data/kdevelop.css" title="KDevelop"/>
<script type="text/javascript" src="../../../../../../data/jquery/jquery.min.js"></script>
<script type="text/javascript" src="../../../../../../data/jquery/jquery-ui.min.js"></script>
<script>var file = 'llvm/clang/include/clang/AST/OperationKinds.def'; var root_path = '../../../../..'; var data_path = '../../../../../../data';</script>
<script src='../../../../../../data/codebrowser.js'></script>
</head>
<body><div id='header'><h1 id='breadcrumb'><span>Browse the source code of </span><a href='../../../..'>llvm</a>/<a href='../../..'>clang</a>/<a href='../..'>include</a>/<a href='..'>clang</a>/<a href='./'>AST</a>/<a href='OperationKinds.def.html'>OperationKinds.def</a></h1></div>
<hr/><div id='content'><table class="code">
<tr><th id="1">1</th><td><i>//===--- OperationKinds.def - Operations Database ---------------*- C++ -*-===//</i></td></tr>
<tr><th id="2">2</th><td><i>//</i></td></tr>
<tr><th id="3">3</th><td><i>// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.</i></td></tr>
<tr><th id="4">4</th><td><i>// See <a href="https://llvm.org/LICENSE.txt">https://llvm.org/LICENSE.txt</a> for license information.</i></td></tr>
<tr><th id="5">5</th><td><i>// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception</i></td></tr>
<tr><th id="6">6</th><td><i>//</i></td></tr>
<tr><th id="7">7</th><td><i>//===----------------------------------------------------------------------===//</i></td></tr>
<tr><th id="8">8</th><td><i>//</i></td></tr>
<tr><th id="9">9</th><td><i>// This file enumerates the different kinds of operations that can be</i></td></tr>
<tr><th id="10">10</th><td><i>// performed by various expressions.</i></td></tr>
<tr><th id="11">11</th><td><i>//</i></td></tr>
<tr><th id="12">12</th><td><i>//===----------------------------------------------------------------------===//</i></td></tr>
<tr><th id="13">13</th><td><i>//</i></td></tr>
<tr><th id="14">14</th><td><i>/// @file OperationKinds.def</i></td></tr>
<tr><th id="15">15</th><td><i>///</i></td></tr>
<tr><th id="16">16</th><td><i>/// In this file, each of the C/C++ operations is enumerated CAST_OPERATION,</i></td></tr>
<tr><th id="17">17</th><td><i>/// BINARY_OPERATION or UNARY_OPERATION macro, each of which can be specified by</i></td></tr>
<tr><th id="18">18</th><td><i>/// the code including this file.</i></td></tr>
<tr><th id="19">19</th><td><i>///</i></td></tr>
<tr><th id="20">20</th><td><i>/// Macros had one or two arguments:</i></td></tr>
<tr><th id="21">21</th><td><i>///</i></td></tr>
<tr><th id="22">22</th><td><i>/// Name: The name of the operation. Name (prefixed with CK_, UO_ or BO_) will</i></td></tr>
<tr><th id="23">23</th><td><i>/// be the name of the corresponding enumerator (see OperationsKinds.h).</i></td></tr>
<tr><th id="24">24</th><td><i>///</i></td></tr>
<tr><th id="25">25</th><td><i>/// Spelling: A string that provides a canonical spelling for the operation.</i></td></tr>
<tr><th id="26">26</th><td></td></tr>
<tr><th id="27">27</th><td><u>#<span data-ppcond="27">ifndef</span> <a class="macro" href="OperationKinds.h.html#21" data-ref="_M/CAST_OPERATION">CAST_OPERATION</a></u></td></tr>
<tr><th id="28">28</th><td><u>#  define CAST_OPERATION(Name)</u></td></tr>
<tr><th id="29">29</th><td><u>#<span data-ppcond="27">endif</span></u></td></tr>
<tr><th id="30">30</th><td></td></tr>
<tr><th id="31">31</th><td><u>#<span data-ppcond="31">ifndef</span> <span class="macro" data-ref="_M/BINARY_OPERATION">BINARY_OPERATION</span></u></td></tr>
<tr><th id="32">32</th><td><u>#  define <dfn class="macro" id="_M/BINARY_OPERATION" data-ref="_M/BINARY_OPERATION">BINARY_OPERATION</dfn>(Name, Spelling)</u></td></tr>
<tr><th id="33">33</th><td><u>#<span data-ppcond="31">endif</span></u></td></tr>
<tr><th id="34">34</th><td></td></tr>
<tr><th id="35">35</th><td><u>#<span data-ppcond="35">ifndef</span> <span class="macro" data-ref="_M/UNARY_OPERATION">UNARY_OPERATION</span></u></td></tr>
<tr><th id="36">36</th><td><u>#  define <dfn class="macro" id="_M/UNARY_OPERATION" data-ref="_M/UNARY_OPERATION">UNARY_OPERATION</dfn>(Name, Spelling)</u></td></tr>
<tr><th id="37">37</th><td><u>#<span data-ppcond="35">endif</span></u></td></tr>
<tr><th id="38">38</th><td></td></tr>
<tr><th id="39">39</th><td><i>//===- Cast Operations  ---------------------------------------------------===//</i></td></tr>
<tr><th id="40">40</th><td><i></i></td></tr>
<tr><th id="41">41</th><td><i>/// CK_Dependent - A conversion which cannot yet be analyzed because</i></td></tr>
<tr><th id="42">42</th><td><i>/// either the expression or target type is dependent.  These are</i></td></tr>
<tr><th id="43">43</th><td><i>/// created only for explicit casts; dependent ASTs aren't required</i></td></tr>
<tr><th id="44">44</th><td><i>/// to even approximately type-check.</i></td></tr>
<tr><th id="45">45</th><td><i>///   (T*) malloc(sizeof(T))</i></td></tr>
<tr><th id="46">46</th><td><i>///   reinterpret_cast&lt;intptr_t&gt;(A&lt;T&gt;::alloc());</i></td></tr>
<tr><th id="47">47</th><td><a class="macro" href="OperationKinds.h.html#21" title="CK_Dependent," data-ref="_M/CAST_OPERATION">CAST_OPERATION</a>(Dependent)</td></tr>
<tr><th id="48">48</th><td></td></tr>
<tr><th id="49">49</th><td><i class="doc">/// CK_BitCast - A conversion which causes a bit pattern of one type</i></td></tr>
<tr><th id="50">50</th><td><i class="doc">/// to be reinterpreted as a bit pattern of another type.  Generally</i></td></tr>
<tr><th id="51">51</th><td><i class="doc">/// the operands must have equivalent size and unrelated types.</i></td></tr>
<tr><th id="52">52</th><td><i class="doc">///</i></td></tr>
<tr><th id="53">53</th><td><i class="doc">/// The pointer conversion char* -&gt; int* is a bitcast.  A conversion</i></td></tr>
<tr><th id="54">54</th><td><i class="doc">/// from any pointer type to a C pointer type is a bitcast unless</i></td></tr>
<tr><th id="55">55</th><td><i class="doc">/// it's actually BaseToDerived or DerivedToBase.  A conversion to a</i></td></tr>
<tr><th id="56">56</th><td><i class="doc">/// block pointer or ObjC pointer type is a bitcast only if the</i></td></tr>
<tr><th id="57">57</th><td><i class="doc">/// operand has the same type kind; otherwise, it's one of the</i></td></tr>
<tr><th id="58">58</th><td><i class="doc">/// specialized casts below.</i></td></tr>
<tr><th id="59">59</th><td><i class="doc">///</i></td></tr>
<tr><th id="60">60</th><td><i class="doc">/// Vector coercions are bitcasts.</i></td></tr>
<tr><th id="61">61</th><td><a class="macro" href="OperationKinds.h.html#21" title="CK_BitCast," data-ref="_M/CAST_OPERATION">CAST_OPERATION</a>(BitCast)</td></tr>
<tr><th id="62">62</th><td></td></tr>
<tr><th id="63">63</th><td><i class="doc">/// CK_LValueBitCast - A conversion which reinterprets the address of</i></td></tr>
<tr><th id="64">64</th><td><i class="doc">/// an l-value as an l-value of a different kind.  Used for</i></td></tr>
<tr><th id="65">65</th><td><i class="doc">/// reinterpret_casts of l-value expressions to reference types.</i></td></tr>
<tr><th id="66">66</th><td><i class="doc">///    bool b; reinterpret_cast&lt;char&amp;&gt;(b) = 'a';</i></td></tr>
<tr><th id="67">67</th><td><a class="macro" href="OperationKinds.h.html#21" title="CK_LValueBitCast," data-ref="_M/CAST_OPERATION">CAST_OPERATION</a>(LValueBitCast)</td></tr>
<tr><th id="68">68</th><td></td></tr>
<tr><th id="69">69</th><td><i class="doc">/// CK_LValueToRValue - A conversion which causes the extraction of</i></td></tr>
<tr><th id="70">70</th><td><i class="doc">/// an r-value from the operand gl-value.  The result of an r-value</i></td></tr>
<tr><th id="71">71</th><td><i class="doc">/// conversion is always unqualified.</i></td></tr>
<tr><th id="72">72</th><td><a class="macro" href="OperationKinds.h.html#21" title="CK_LValueToRValue," data-ref="_M/CAST_OPERATION">CAST_OPERATION</a>(LValueToRValue)</td></tr>
<tr><th id="73">73</th><td></td></tr>
<tr><th id="74">74</th><td><i class="doc">/// CK_NoOp - A conversion which does not affect the type other than</i></td></tr>
<tr><th id="75">75</th><td><i class="doc">/// (possibly) adding qualifiers.</i></td></tr>
<tr><th id="76">76</th><td><i class="doc">///   int    -&gt; int</i></td></tr>
<tr><th id="77">77</th><td><i class="doc">///   char** -&gt; const char * const *</i></td></tr>
<tr><th id="78">78</th><td><a class="macro" href="OperationKinds.h.html#21" title="CK_NoOp," data-ref="_M/CAST_OPERATION">CAST_OPERATION</a>(NoOp)</td></tr>
<tr><th id="79">79</th><td></td></tr>
<tr><th id="80">80</th><td><i class="doc">/// CK_BaseToDerived - A conversion from a C++ class pointer/reference</i></td></tr>
<tr><th id="81">81</th><td><i class="doc">/// to a derived class pointer/reference.</i></td></tr>
<tr><th id="82">82</th><td><i class="doc">///   B *b = static_cast&lt;B*&gt;(a);</i></td></tr>
<tr><th id="83">83</th><td><a class="macro" href="OperationKinds.h.html#21" title="CK_BaseToDerived," data-ref="_M/CAST_OPERATION">CAST_OPERATION</a>(BaseToDerived)</td></tr>
<tr><th id="84">84</th><td></td></tr>
<tr><th id="85">85</th><td><i class="doc">/// CK_DerivedToBase - A conversion from a C++ class pointer</i></td></tr>
<tr><th id="86">86</th><td><i class="doc">/// to a base class pointer.</i></td></tr>
<tr><th id="87">87</th><td><i class="doc">///   A *a = new B();</i></td></tr>
<tr><th id="88">88</th><td><a class="macro" href="OperationKinds.h.html#21" title="CK_DerivedToBase," data-ref="_M/CAST_OPERATION">CAST_OPERATION</a>(DerivedToBase)</td></tr>
<tr><th id="89">89</th><td></td></tr>
<tr><th id="90">90</th><td><i class="doc">/// CK_UncheckedDerivedToBase - A conversion from a C++ class</i></td></tr>
<tr><th id="91">91</th><td><i class="doc">/// pointer/reference to a base class that can assume that the</i></td></tr>
<tr><th id="92">92</th><td><i class="doc">/// derived pointer is not null.</i></td></tr>
<tr><th id="93">93</th><td><i class="doc">///   const A &amp;a = B();</i></td></tr>
<tr><th id="94">94</th><td><i class="doc">///   b-&gt;method_from_a();</i></td></tr>
<tr><th id="95">95</th><td><a class="macro" href="OperationKinds.h.html#21" title="CK_UncheckedDerivedToBase," data-ref="_M/CAST_OPERATION">CAST_OPERATION</a>(UncheckedDerivedToBase)</td></tr>
<tr><th id="96">96</th><td></td></tr>
<tr><th id="97">97</th><td><i class="doc">/// CK_Dynamic - A C++ dynamic_cast.</i></td></tr>
<tr><th id="98">98</th><td><a class="macro" href="OperationKinds.h.html#21" title="CK_Dynamic," data-ref="_M/CAST_OPERATION">CAST_OPERATION</a>(Dynamic)</td></tr>
<tr><th id="99">99</th><td></td></tr>
<tr><th id="100">100</th><td><i class="doc">/// CK_ToUnion - The GCC cast-to-union extension.</i></td></tr>
<tr><th id="101">101</th><td><i class="doc">///   int   -&gt; union { int x; float y; }</i></td></tr>
<tr><th id="102">102</th><td><i class="doc">///   float -&gt; union { int x; float y; }</i></td></tr>
<tr><th id="103">103</th><td><a class="macro" href="OperationKinds.h.html#21" title="CK_ToUnion," data-ref="_M/CAST_OPERATION">CAST_OPERATION</a>(ToUnion)</td></tr>
<tr><th id="104">104</th><td></td></tr>
<tr><th id="105">105</th><td><i class="doc">/// CK_ArrayToPointerDecay - Array to pointer decay.</i></td></tr>
<tr><th id="106">106</th><td><i class="doc">///   int[10] -&gt; int*</i></td></tr>
<tr><th id="107">107</th><td><i class="doc">///   char[5][6] -&gt; char(*)[6]</i></td></tr>
<tr><th id="108">108</th><td><a class="macro" href="OperationKinds.h.html#21" title="CK_ArrayToPointerDecay," data-ref="_M/CAST_OPERATION">CAST_OPERATION</a>(ArrayToPointerDecay)</td></tr>
<tr><th id="109">109</th><td></td></tr>
<tr><th id="110">110</th><td><i class="doc">/// CK_FunctionToPointerDecay - Function to pointer decay.</i></td></tr>
<tr><th id="111">111</th><td><i class="doc">///   void(int) -&gt; void(*)(int)</i></td></tr>
<tr><th id="112">112</th><td><a class="macro" href="OperationKinds.h.html#21" title="CK_FunctionToPointerDecay," data-ref="_M/CAST_OPERATION">CAST_OPERATION</a>(FunctionToPointerDecay)</td></tr>
<tr><th id="113">113</th><td></td></tr>
<tr><th id="114">114</th><td><i class="doc">/// CK_NullToPointer - Null pointer constant to pointer, ObjC</i></td></tr>
<tr><th id="115">115</th><td><i class="doc">/// pointer, or block pointer.</i></td></tr>
<tr><th id="116">116</th><td><i class="doc">///   (void*) 0</i></td></tr>
<tr><th id="117">117</th><td><i class="doc">///   void (^block)() = 0;</i></td></tr>
<tr><th id="118">118</th><td><a class="macro" href="OperationKinds.h.html#21" title="CK_NullToPointer," data-ref="_M/CAST_OPERATION">CAST_OPERATION</a>(NullToPointer)</td></tr>
<tr><th id="119">119</th><td></td></tr>
<tr><th id="120">120</th><td><i class="doc">/// CK_NullToMemberPointer - Null pointer constant to member pointer.</i></td></tr>
<tr><th id="121">121</th><td><i class="doc">///   int A::*mptr = 0;</i></td></tr>
<tr><th id="122">122</th><td><i class="doc">///   int (A::*fptr)(int) = nullptr;</i></td></tr>
<tr><th id="123">123</th><td><a class="macro" href="OperationKinds.h.html#21" title="CK_NullToMemberPointer," data-ref="_M/CAST_OPERATION">CAST_OPERATION</a>(NullToMemberPointer)</td></tr>
<tr><th id="124">124</th><td></td></tr>
<tr><th id="125">125</th><td><i class="doc">/// CK_BaseToDerivedMemberPointer - Member pointer in base class to</i></td></tr>
<tr><th id="126">126</th><td><i class="doc">/// member pointer in derived class.</i></td></tr>
<tr><th id="127">127</th><td><i class="doc">///   int B::*mptr = &amp;A::member;</i></td></tr>
<tr><th id="128">128</th><td><a class="macro" href="OperationKinds.h.html#21" title="CK_BaseToDerivedMemberPointer," data-ref="_M/CAST_OPERATION">CAST_OPERATION</a>(BaseToDerivedMemberPointer)</td></tr>
<tr><th id="129">129</th><td></td></tr>
<tr><th id="130">130</th><td><i class="doc">/// CK_DerivedToBaseMemberPointer - Member pointer in derived class to</i></td></tr>
<tr><th id="131">131</th><td><i class="doc">/// member pointer in base class.</i></td></tr>
<tr><th id="132">132</th><td><i class="doc">///   int A::*mptr = static_cast&lt;int A::*&gt;(&amp;B::member);</i></td></tr>
<tr><th id="133">133</th><td><a class="macro" href="OperationKinds.h.html#21" title="CK_DerivedToBaseMemberPointer," data-ref="_M/CAST_OPERATION">CAST_OPERATION</a>(DerivedToBaseMemberPointer)</td></tr>
<tr><th id="134">134</th><td></td></tr>
<tr><th id="135">135</th><td><i class="doc">/// CK_MemberPointerToBoolean - Member pointer to boolean.  A check</i></td></tr>
<tr><th id="136">136</th><td><i class="doc">/// against the null member pointer.</i></td></tr>
<tr><th id="137">137</th><td><a class="macro" href="OperationKinds.h.html#21" title="CK_MemberPointerToBoolean," data-ref="_M/CAST_OPERATION">CAST_OPERATION</a>(MemberPointerToBoolean)</td></tr>
<tr><th id="138">138</th><td></td></tr>
<tr><th id="139">139</th><td><i class="doc">/// CK_ReinterpretMemberPointer - Reinterpret a member pointer as a</i></td></tr>
<tr><th id="140">140</th><td><i class="doc">/// different kind of member pointer.  C++ forbids this from</i></td></tr>
<tr><th id="141">141</th><td><i class="doc">/// crossing between function and object types, but otherwise does</i></td></tr>
<tr><th id="142">142</th><td><i class="doc">/// not restrict it.  However, the only operation that is permitted</i></td></tr>
<tr><th id="143">143</th><td><i class="doc">/// on a "punned" member pointer is casting it back to the original</i></td></tr>
<tr><th id="144">144</th><td><i class="doc">/// type, which is required to be a lossless operation (although</i></td></tr>
<tr><th id="145">145</th><td><i class="doc">/// many ABIs do not guarantee this on all possible intermediate types).</i></td></tr>
<tr><th id="146">146</th><td><a class="macro" href="OperationKinds.h.html#21" title="CK_ReinterpretMemberPointer," data-ref="_M/CAST_OPERATION">CAST_OPERATION</a>(ReinterpretMemberPointer)</td></tr>
<tr><th id="147">147</th><td></td></tr>
<tr><th id="148">148</th><td><i class="doc">/// CK_UserDefinedConversion - Conversion using a user defined type</i></td></tr>
<tr><th id="149">149</th><td><i class="doc">/// conversion function.</i></td></tr>
<tr><th id="150">150</th><td><i class="doc">///    struct A { operator int(); }; int i = int(A());</i></td></tr>
<tr><th id="151">151</th><td><a class="macro" href="OperationKinds.h.html#21" title="CK_UserDefinedConversion," data-ref="_M/CAST_OPERATION">CAST_OPERATION</a>(UserDefinedConversion)</td></tr>
<tr><th id="152">152</th><td></td></tr>
<tr><th id="153">153</th><td><i class="doc">/// CK_ConstructorConversion - Conversion by constructor.</i></td></tr>
<tr><th id="154">154</th><td><i class="doc">///    struct A { A(int); }; A a = A(10);</i></td></tr>
<tr><th id="155">155</th><td><a class="macro" href="OperationKinds.h.html#21" title="CK_ConstructorConversion," data-ref="_M/CAST_OPERATION">CAST_OPERATION</a>(ConstructorConversion)</td></tr>
<tr><th id="156">156</th><td></td></tr>
<tr><th id="157">157</th><td><i class="doc">/// CK_IntegralToPointer - Integral to pointer.  A special kind of</i></td></tr>
<tr><th id="158">158</th><td><i class="doc">/// reinterpreting conversion.  Applies to normal, ObjC, and block</i></td></tr>
<tr><th id="159">159</th><td><i class="doc">/// pointers.</i></td></tr>
<tr><th id="160">160</th><td><i class="doc">///    (char*) 0x1001aab0</i></td></tr>
<tr><th id="161">161</th><td><i class="doc">///    reinterpret_cast&lt;int*&gt;(0)</i></td></tr>
<tr><th id="162">162</th><td><a class="macro" href="OperationKinds.h.html#21" title="CK_IntegralToPointer," data-ref="_M/CAST_OPERATION">CAST_OPERATION</a>(IntegralToPointer)</td></tr>
<tr><th id="163">163</th><td></td></tr>
<tr><th id="164">164</th><td><i class="doc">/// CK_PointerToIntegral - Pointer to integral.  A special kind of</i></td></tr>
<tr><th id="165">165</th><td><i class="doc">/// reinterpreting conversion.  Applies to normal, ObjC, and block</i></td></tr>
<tr><th id="166">166</th><td><i class="doc">/// pointers.</i></td></tr>
<tr><th id="167">167</th><td><i class="doc">///    (intptr_t) "help!"</i></td></tr>
<tr><th id="168">168</th><td><a class="macro" href="OperationKinds.h.html#21" title="CK_PointerToIntegral," data-ref="_M/CAST_OPERATION">CAST_OPERATION</a>(PointerToIntegral)</td></tr>
<tr><th id="169">169</th><td></td></tr>
<tr><th id="170">170</th><td><i class="doc">/// CK_PointerToBoolean - Pointer to boolean conversion.  A check</i></td></tr>
<tr><th id="171">171</th><td><i class="doc">/// against null.  Applies to normal, ObjC, and block pointers.</i></td></tr>
<tr><th id="172">172</th><td><a class="macro" href="OperationKinds.h.html#21" title="CK_PointerToBoolean," data-ref="_M/CAST_OPERATION">CAST_OPERATION</a>(PointerToBoolean)</td></tr>
<tr><th id="173">173</th><td></td></tr>
<tr><th id="174">174</th><td><i class="doc">/// CK_ToVoid - Cast to void, discarding the computed value.</i></td></tr>
<tr><th id="175">175</th><td><i class="doc">///    (void) malloc(2048)</i></td></tr>
<tr><th id="176">176</th><td><a class="macro" href="OperationKinds.h.html#21" title="CK_ToVoid," data-ref="_M/CAST_OPERATION">CAST_OPERATION</a>(ToVoid)</td></tr>
<tr><th id="177">177</th><td></td></tr>
<tr><th id="178">178</th><td><i class="doc">/// CK_VectorSplat - A conversion from an arithmetic type to a</i></td></tr>
<tr><th id="179">179</th><td><i class="doc">/// vector of that element type.  Fills all elements ("splats") with</i></td></tr>
<tr><th id="180">180</th><td><i class="doc">/// the source value.</i></td></tr>
<tr><th id="181">181</th><td><i class="doc">///    __attribute__((ext_vector_type(4))) int v = 5;</i></td></tr>
<tr><th id="182">182</th><td><a class="macro" href="OperationKinds.h.html#21" title="CK_VectorSplat," data-ref="_M/CAST_OPERATION">CAST_OPERATION</a>(VectorSplat)</td></tr>
<tr><th id="183">183</th><td></td></tr>
<tr><th id="184">184</th><td><i class="doc">/// CK_IntegralCast - A cast between integral types (other than to</i></td></tr>
<tr><th id="185">185</th><td><i class="doc">/// boolean).  Variously a bitcast, a truncation, a sign-extension,</i></td></tr>
<tr><th id="186">186</th><td><i class="doc">/// or a zero-extension.</i></td></tr>
<tr><th id="187">187</th><td><i class="doc">///    long l = 5;</i></td></tr>
<tr><th id="188">188</th><td><i class="doc">///    (unsigned) i</i></td></tr>
<tr><th id="189">189</th><td><a class="macro" href="OperationKinds.h.html#21" title="CK_IntegralCast," data-ref="_M/CAST_OPERATION">CAST_OPERATION</a>(IntegralCast)</td></tr>
<tr><th id="190">190</th><td></td></tr>
<tr><th id="191">191</th><td><i class="doc">/// CK_IntegralToBoolean - Integral to boolean.  A check against zero.</i></td></tr>
<tr><th id="192">192</th><td><i class="doc">///    (bool) i</i></td></tr>
<tr><th id="193">193</th><td><a class="macro" href="OperationKinds.h.html#21" title="CK_IntegralToBoolean," data-ref="_M/CAST_OPERATION">CAST_OPERATION</a>(IntegralToBoolean)</td></tr>
<tr><th id="194">194</th><td></td></tr>
<tr><th id="195">195</th><td><i class="doc">/// CK_IntegralToFloating - Integral to floating point.</i></td></tr>
<tr><th id="196">196</th><td><i class="doc">///    float f = i;</i></td></tr>
<tr><th id="197">197</th><td><a class="macro" href="OperationKinds.h.html#21" title="CK_IntegralToFloating," data-ref="_M/CAST_OPERATION">CAST_OPERATION</a>(IntegralToFloating)</td></tr>
<tr><th id="198">198</th><td></td></tr>
<tr><th id="199">199</th><td><i class="doc">/// CK_FixedPointCast - Fixed point to fixed point.</i></td></tr>
<tr><th id="200">200</th><td><i class="doc">///    (_Accum) 0.5r</i></td></tr>
<tr><th id="201">201</th><td><a class="macro" href="OperationKinds.h.html#21" title="CK_FixedPointCast," data-ref="_M/CAST_OPERATION">CAST_OPERATION</a>(FixedPointCast)</td></tr>
<tr><th id="202">202</th><td></td></tr>
<tr><th id="203">203</th><td><i class="doc">/// CK_FixedPointToIntegral - Fixed point to integral.</i></td></tr>
<tr><th id="204">204</th><td><i class="doc">///    (int) 2.0k</i></td></tr>
<tr><th id="205">205</th><td><a class="macro" href="OperationKinds.h.html#21" title="CK_FixedPointToIntegral," data-ref="_M/CAST_OPERATION">CAST_OPERATION</a>(FixedPointToIntegral)</td></tr>
<tr><th id="206">206</th><td></td></tr>
<tr><th id="207">207</th><td><i class="doc">/// CK_IntegralToFixedPoint - Integral to a fixed point.</i></td></tr>
<tr><th id="208">208</th><td><i class="doc">///    (_Accum) 2</i></td></tr>
<tr><th id="209">209</th><td><a class="macro" href="OperationKinds.h.html#21" title="CK_IntegralToFixedPoint," data-ref="_M/CAST_OPERATION">CAST_OPERATION</a>(IntegralToFixedPoint)</td></tr>
<tr><th id="210">210</th><td></td></tr>
<tr><th id="211">211</th><td><i class="doc">/// CK_FixedPointToBoolean - Fixed point to boolean.</i></td></tr>
<tr><th id="212">212</th><td><i class="doc">///    (bool) 0.5r</i></td></tr>
<tr><th id="213">213</th><td><a class="macro" href="OperationKinds.h.html#21" title="CK_FixedPointToBoolean," data-ref="_M/CAST_OPERATION">CAST_OPERATION</a>(FixedPointToBoolean)</td></tr>
<tr><th id="214">214</th><td></td></tr>
<tr><th id="215">215</th><td><i class="doc">/// CK_FloatingToIntegral - Floating point to integral.  Rounds</i></td></tr>
<tr><th id="216">216</th><td><i class="doc">/// towards zero, discarding any fractional component.</i></td></tr>
<tr><th id="217">217</th><td><i class="doc">///    (int) f</i></td></tr>
<tr><th id="218">218</th><td><a class="macro" href="OperationKinds.h.html#21" title="CK_FloatingToIntegral," data-ref="_M/CAST_OPERATION">CAST_OPERATION</a>(FloatingToIntegral)</td></tr>
<tr><th id="219">219</th><td></td></tr>
<tr><th id="220">220</th><td><i class="doc">/// CK_FloatingToBoolean - Floating point to boolean.</i></td></tr>
<tr><th id="221">221</th><td><i class="doc">///    (bool) f</i></td></tr>
<tr><th id="222">222</th><td><a class="macro" href="OperationKinds.h.html#21" title="CK_FloatingToBoolean," data-ref="_M/CAST_OPERATION">CAST_OPERATION</a>(FloatingToBoolean)</td></tr>
<tr><th id="223">223</th><td></td></tr>
<tr><th id="224">224</th><td><i>// CK_BooleanToSignedIntegral - Convert a boolean to -1 or 0 for true and</i></td></tr>
<tr><th id="225">225</th><td><i>// false, respectively.</i></td></tr>
<tr><th id="226">226</th><td><a class="macro" href="OperationKinds.h.html#21" title="CK_BooleanToSignedIntegral," data-ref="_M/CAST_OPERATION">CAST_OPERATION</a>(BooleanToSignedIntegral)</td></tr>
<tr><th id="227">227</th><td></td></tr>
<tr><th id="228">228</th><td><i class="doc">/// CK_FloatingCast - Casting between floating types of different size.</i></td></tr>
<tr><th id="229">229</th><td><i class="doc">///    (double) f</i></td></tr>
<tr><th id="230">230</th><td><i class="doc">///    (float) ld</i></td></tr>
<tr><th id="231">231</th><td><a class="macro" href="OperationKinds.h.html#21" title="CK_FloatingCast," data-ref="_M/CAST_OPERATION">CAST_OPERATION</a>(FloatingCast)</td></tr>
<tr><th id="232">232</th><td></td></tr>
<tr><th id="233">233</th><td><i class="doc">/// CK_CPointerToObjCPointerCast - Casting a C pointer kind to an</i></td></tr>
<tr><th id="234">234</th><td><i class="doc">/// Objective-C pointer.</i></td></tr>
<tr><th id="235">235</th><td><a class="macro" href="OperationKinds.h.html#21" title="CK_CPointerToObjCPointerCast," data-ref="_M/CAST_OPERATION">CAST_OPERATION</a>(CPointerToObjCPointerCast)</td></tr>
<tr><th id="236">236</th><td></td></tr>
<tr><th id="237">237</th><td><i class="doc">/// CK_BlockPointerToObjCPointerCast - Casting a block pointer to an</i></td></tr>
<tr><th id="238">238</th><td><i class="doc">/// ObjC pointer.</i></td></tr>
<tr><th id="239">239</th><td><a class="macro" href="OperationKinds.h.html#21" title="CK_BlockPointerToObjCPointerCast," data-ref="_M/CAST_OPERATION">CAST_OPERATION</a>(BlockPointerToObjCPointerCast)</td></tr>
<tr><th id="240">240</th><td></td></tr>
<tr><th id="241">241</th><td><i class="doc">/// CK_AnyPointerToBlockPointerCast - Casting any non-block pointer</i></td></tr>
<tr><th id="242">242</th><td><i class="doc">/// to a block pointer.  Block-to-block casts are bitcasts.</i></td></tr>
<tr><th id="243">243</th><td><a class="macro" href="OperationKinds.h.html#21" title="CK_AnyPointerToBlockPointerCast," data-ref="_M/CAST_OPERATION">CAST_OPERATION</a>(AnyPointerToBlockPointerCast)</td></tr>
<tr><th id="244">244</th><td></td></tr>
<tr><th id="245">245</th><td><i class="doc">/// Converting between two Objective-C object types, which</i></td></tr>
<tr><th id="246">246</th><td><i class="doc">/// can occur when performing reference binding to an Objective-C</i></td></tr>
<tr><th id="247">247</th><td><i class="doc">/// object.</i></td></tr>
<tr><th id="248">248</th><td><a class="macro" href="OperationKinds.h.html#21" title="CK_ObjCObjectLValueCast," data-ref="_M/CAST_OPERATION">CAST_OPERATION</a>(ObjCObjectLValueCast)</td></tr>
<tr><th id="249">249</th><td></td></tr>
<tr><th id="250">250</th><td><i class="doc">/// A conversion of a floating point real to a floating point</i></td></tr>
<tr><th id="251">251</th><td><i class="doc">/// complex of the original type.  Injects the value as the real</i></td></tr>
<tr><th id="252">252</th><td><i class="doc">/// component with a zero imaginary component.</i></td></tr>
<tr><th id="253">253</th><td><i class="doc">///   float -&gt; _Complex float</i></td></tr>
<tr><th id="254">254</th><td><a class="macro" href="OperationKinds.h.html#21" title="CK_FloatingRealToComplex," data-ref="_M/CAST_OPERATION">CAST_OPERATION</a>(FloatingRealToComplex)</td></tr>
<tr><th id="255">255</th><td></td></tr>
<tr><th id="256">256</th><td><i class="doc">/// Converts a floating point complex to floating point real</i></td></tr>
<tr><th id="257">257</th><td><i class="doc">/// of the source's element type.  Just discards the imaginary</i></td></tr>
<tr><th id="258">258</th><td><i class="doc">/// component.</i></td></tr>
<tr><th id="259">259</th><td><i class="doc">///   _Complex long double -&gt; long double</i></td></tr>
<tr><th id="260">260</th><td><a class="macro" href="OperationKinds.h.html#21" title="CK_FloatingComplexToReal," data-ref="_M/CAST_OPERATION">CAST_OPERATION</a>(FloatingComplexToReal)</td></tr>
<tr><th id="261">261</th><td></td></tr>
<tr><th id="262">262</th><td><i class="doc">/// Converts a floating point complex to bool by comparing</i></td></tr>
<tr><th id="263">263</th><td><i class="doc">/// against 0+0i.</i></td></tr>
<tr><th id="264">264</th><td><a class="macro" href="OperationKinds.h.html#21" title="CK_FloatingComplexToBoolean," data-ref="_M/CAST_OPERATION">CAST_OPERATION</a>(FloatingComplexToBoolean)</td></tr>
<tr><th id="265">265</th><td></td></tr>
<tr><th id="266">266</th><td><i class="doc">/// Converts between different floating point complex types.</i></td></tr>
<tr><th id="267">267</th><td><i class="doc">///   _Complex float -&gt; _Complex double</i></td></tr>
<tr><th id="268">268</th><td><a class="macro" href="OperationKinds.h.html#21" title="CK_FloatingComplexCast," data-ref="_M/CAST_OPERATION">CAST_OPERATION</a>(FloatingComplexCast)</td></tr>
<tr><th id="269">269</th><td></td></tr>
<tr><th id="270">270</th><td><i class="doc">/// Converts from a floating complex to an integral complex.</i></td></tr>
<tr><th id="271">271</th><td><i class="doc">///   _Complex float -&gt; _Complex int</i></td></tr>
<tr><th id="272">272</th><td><a class="macro" href="OperationKinds.h.html#21" title="CK_FloatingComplexToIntegralComplex," data-ref="_M/CAST_OPERATION">CAST_OPERATION</a>(FloatingComplexToIntegralComplex)</td></tr>
<tr><th id="273">273</th><td></td></tr>
<tr><th id="274">274</th><td><i class="doc">/// Converts from an integral real to an integral complex</i></td></tr>
<tr><th id="275">275</th><td><i class="doc">/// whose element type matches the source.  Injects the value as</i></td></tr>
<tr><th id="276">276</th><td><i class="doc">/// the real component with a zero imaginary component.</i></td></tr>
<tr><th id="277">277</th><td><i class="doc">///   long -&gt; _Complex long</i></td></tr>
<tr><th id="278">278</th><td><a class="macro" href="OperationKinds.h.html#21" title="CK_IntegralRealToComplex," data-ref="_M/CAST_OPERATION">CAST_OPERATION</a>(IntegralRealToComplex)</td></tr>
<tr><th id="279">279</th><td></td></tr>
<tr><th id="280">280</th><td><i class="doc">/// Converts an integral complex to an integral real of the</i></td></tr>
<tr><th id="281">281</th><td><i class="doc">/// source's element type by discarding the imaginary component.</i></td></tr>
<tr><th id="282">282</th><td><i class="doc">///   _Complex short -&gt; short</i></td></tr>
<tr><th id="283">283</th><td><a class="macro" href="OperationKinds.h.html#21" title="CK_IntegralComplexToReal," data-ref="_M/CAST_OPERATION">CAST_OPERATION</a>(IntegralComplexToReal)</td></tr>
<tr><th id="284">284</th><td></td></tr>
<tr><th id="285">285</th><td><i class="doc">/// Converts an integral complex to bool by comparing against</i></td></tr>
<tr><th id="286">286</th><td><i class="doc">/// 0+0i.</i></td></tr>
<tr><th id="287">287</th><td><a class="macro" href="OperationKinds.h.html#21" title="CK_IntegralComplexToBoolean," data-ref="_M/CAST_OPERATION">CAST_OPERATION</a>(IntegralComplexToBoolean)</td></tr>
<tr><th id="288">288</th><td></td></tr>
<tr><th id="289">289</th><td><i class="doc">/// Converts between different integral complex types.</i></td></tr>
<tr><th id="290">290</th><td><i class="doc">///   _Complex char -&gt; _Complex long long</i></td></tr>
<tr><th id="291">291</th><td><i class="doc">///   _Complex unsigned int -&gt; _Complex signed int</i></td></tr>
<tr><th id="292">292</th><td><a class="macro" href="OperationKinds.h.html#21" title="CK_IntegralComplexCast," data-ref="_M/CAST_OPERATION">CAST_OPERATION</a>(IntegralComplexCast)</td></tr>
<tr><th id="293">293</th><td></td></tr>
<tr><th id="294">294</th><td><i class="doc">/// Converts from an integral complex to a floating complex.</i></td></tr>
<tr><th id="295">295</th><td><i class="doc">///   _Complex unsigned -&gt; _Complex float</i></td></tr>
<tr><th id="296">296</th><td><a class="macro" href="OperationKinds.h.html#21" title="CK_IntegralComplexToFloatingComplex," data-ref="_M/CAST_OPERATION">CAST_OPERATION</a>(IntegralComplexToFloatingComplex)</td></tr>
<tr><th id="297">297</th><td></td></tr>
<tr><th id="298">298</th><td><i class="doc">/// [ARC] Produces a retainable object pointer so that it may</i></td></tr>
<tr><th id="299">299</th><td><i class="doc">/// be consumed, e.g. by being passed to a consuming parameter.</i></td></tr>
<tr><th id="300">300</th><td><i class="doc">/// Calls objc_retain.</i></td></tr>
<tr><th id="301">301</th><td><a class="macro" href="OperationKinds.h.html#21" title="CK_ARCProduceObject," data-ref="_M/CAST_OPERATION">CAST_OPERATION</a>(ARCProduceObject)</td></tr>
<tr><th id="302">302</th><td></td></tr>
<tr><th id="303">303</th><td><i class="doc">/// [ARC] Consumes a retainable object pointer that has just</i></td></tr>
<tr><th id="304">304</th><td><i class="doc">/// been produced, e.g. as the return value of a retaining call.</i></td></tr>
<tr><th id="305">305</th><td><i class="doc">/// Enters a cleanup to call objc_release at some indefinite time.</i></td></tr>
<tr><th id="306">306</th><td><a class="macro" href="OperationKinds.h.html#21" title="CK_ARCConsumeObject," data-ref="_M/CAST_OPERATION">CAST_OPERATION</a>(ARCConsumeObject)</td></tr>
<tr><th id="307">307</th><td></td></tr>
<tr><th id="308">308</th><td><i class="doc">/// [ARC] Reclaim a retainable object pointer object that may</i></td></tr>
<tr><th id="309">309</th><td><i class="doc">/// have been produced and autoreleased as part of a function return</i></td></tr>
<tr><th id="310">310</th><td><i class="doc">/// sequence.</i></td></tr>
<tr><th id="311">311</th><td><a class="macro" href="OperationKinds.h.html#21" title="CK_ARCReclaimReturnedObject," data-ref="_M/CAST_OPERATION">CAST_OPERATION</a>(ARCReclaimReturnedObject)</td></tr>
<tr><th id="312">312</th><td></td></tr>
<tr><th id="313">313</th><td><i class="doc">/// [ARC] Causes a value of block type to be copied to the</i></td></tr>
<tr><th id="314">314</th><td><i class="doc">/// heap, if it is not already there.  A number of other operations</i></td></tr>
<tr><th id="315">315</th><td><i class="doc">/// in ARC cause blocks to be copied; this is for cases where that</i></td></tr>
<tr><th id="316">316</th><td><i class="doc">/// would not otherwise be guaranteed, such as when casting to a</i></td></tr>
<tr><th id="317">317</th><td><i class="doc">/// non-block pointer type.</i></td></tr>
<tr><th id="318">318</th><td><a class="macro" href="OperationKinds.h.html#21" title="CK_ARCExtendBlockObject," data-ref="_M/CAST_OPERATION">CAST_OPERATION</a>(ARCExtendBlockObject)</td></tr>
<tr><th id="319">319</th><td></td></tr>
<tr><th id="320">320</th><td><i class="doc">/// Converts from _Atomic(T) to T.</i></td></tr>
<tr><th id="321">321</th><td><a class="macro" href="OperationKinds.h.html#21" title="CK_AtomicToNonAtomic," data-ref="_M/CAST_OPERATION">CAST_OPERATION</a>(AtomicToNonAtomic)</td></tr>
<tr><th id="322">322</th><td><i class="doc">/// Converts from T to _Atomic(T).</i></td></tr>
<tr><th id="323">323</th><td><a class="macro" href="OperationKinds.h.html#21" title="CK_NonAtomicToAtomic," data-ref="_M/CAST_OPERATION">CAST_OPERATION</a>(NonAtomicToAtomic)</td></tr>
<tr><th id="324">324</th><td></td></tr>
<tr><th id="325">325</th><td><i class="doc">/// Causes a block literal to by copied to the heap and then</i></td></tr>
<tr><th id="326">326</th><td><i class="doc">/// autoreleased.</i></td></tr>
<tr><th id="327">327</th><td><i class="doc">///</i></td></tr>
<tr><th id="328">328</th><td><i class="doc">/// This particular cast kind is used for the conversion from a C++11</i></td></tr>
<tr><th id="329">329</th><td><i class="doc">/// lambda expression to a block pointer.</i></td></tr>
<tr><th id="330">330</th><td><a class="macro" href="OperationKinds.h.html#21" title="CK_CopyAndAutoreleaseBlockObject," data-ref="_M/CAST_OPERATION">CAST_OPERATION</a>(CopyAndAutoreleaseBlockObject)</td></tr>
<tr><th id="331">331</th><td></td></tr>
<tr><th id="332">332</th><td><i>// Convert a builtin function to a function pointer; only allowed in the</i></td></tr>
<tr><th id="333">333</th><td><i>// callee of a call expression.</i></td></tr>
<tr><th id="334">334</th><td><a class="macro" href="OperationKinds.h.html#21" title="CK_BuiltinFnToFnPtr," data-ref="_M/CAST_OPERATION">CAST_OPERATION</a>(BuiltinFnToFnPtr)</td></tr>
<tr><th id="335">335</th><td></td></tr>
<tr><th id="336">336</th><td><i>// Convert a zero value for OpenCL opaque types initialization (event_t,</i></td></tr>
<tr><th id="337">337</th><td><i>// queue_t, etc.)</i></td></tr>
<tr><th id="338">338</th><td><a class="macro" href="OperationKinds.h.html#21" title="CK_ZeroToOCLOpaqueType," data-ref="_M/CAST_OPERATION">CAST_OPERATION</a>(ZeroToOCLOpaqueType)</td></tr>
<tr><th id="339">339</th><td></td></tr>
<tr><th id="340">340</th><td><i>// Convert a pointer to a different address space.</i></td></tr>
<tr><th id="341">341</th><td><a class="macro" href="OperationKinds.h.html#21" title="CK_AddressSpaceConversion," data-ref="_M/CAST_OPERATION">CAST_OPERATION</a>(AddressSpaceConversion)</td></tr>
<tr><th id="342">342</th><td></td></tr>
<tr><th id="343">343</th><td><i>// Convert a CHERI capability to a pointer.</i></td></tr>
<tr><th id="344">344</th><td><a class="macro" href="OperationKinds.h.html#21" title="CK_CHERICapabilityToPointer," data-ref="_M/CAST_OPERATION">CAST_OPERATION</a>(CHERICapabilityToPointer)</td></tr>
<tr><th id="345">345</th><td></td></tr>
<tr><th id="346">346</th><td><i>// Convert a pointer to a CHERI capability.</i></td></tr>
<tr><th id="347">347</th><td><a class="macro" href="OperationKinds.h.html#21" title="CK_PointerToCHERICapability," data-ref="_M/CAST_OPERATION">CAST_OPERATION</a>(PointerToCHERICapability)</td></tr>
<tr><th id="348">348</th><td></td></tr>
<tr><th id="349">349</th><td><i>// Obtain the offset field of a CHERI capability</i></td></tr>
<tr><th id="350">350</th><td><a class="macro" href="OperationKinds.h.html#21" title="CK_CHERICapabilityToOffset," data-ref="_M/CAST_OPERATION">CAST_OPERATION</a>(CHERICapabilityToOffset)</td></tr>
<tr><th id="351">351</th><td></td></tr>
<tr><th id="352">352</th><td><i>// Convert a CHERI capability to its address (i.e. base+offset)</i></td></tr>
<tr><th id="353">353</th><td><a class="macro" href="OperationKinds.h.html#21" title="CK_CHERICapabilityToAddress," data-ref="_M/CAST_OPERATION">CAST_OPERATION</a>(CHERICapabilityToAddress)</td></tr>
<tr><th id="354">354</th><td></td></tr>
<tr><th id="355">355</th><td><i>// Convert an integer initializer to an OpenCL sampler.</i></td></tr>
<tr><th id="356">356</th><td><a class="macro" href="OperationKinds.h.html#21" title="CK_IntToOCLSampler," data-ref="_M/CAST_OPERATION">CAST_OPERATION</a>(IntToOCLSampler)</td></tr>
<tr><th id="357">357</th><td></td></tr>
<tr><th id="358">358</th><td><i>//===- Binary Operations  -------------------------------------------------===//</i></td></tr>
<tr><th id="359">359</th><td><i>// Operators listed in order of precedence.</i></td></tr>
<tr><th id="360">360</th><td><i>// Note that additions to this should also update the StmtVisitor class and</i></td></tr>
<tr><th id="361">361</th><td><i>// BinaryOperator::getOverloadedOperator.</i></td></tr>
<tr><th id="362">362</th><td><i></i></td></tr>
<tr><th id="363">363</th><td><i>// [C++ 5.5] Pointer-to-member operators.</i></td></tr>
<tr><th id="364">364</th><td><a class="macro" href="#32" title="" data-ref="_M/BINARY_OPERATION">BINARY_OPERATION</a>(PtrMemD, <q>".*"</q>)</td></tr>
<tr><th id="365">365</th><td><a class="macro" href="#32" title="" data-ref="_M/BINARY_OPERATION">BINARY_OPERATION</a>(PtrMemI, <q>"-&gt;*"</q>)</td></tr>
<tr><th id="366">366</th><td><i>// [C99 6.5.5] Multiplicative operators.</i></td></tr>
<tr><th id="367">367</th><td><a class="macro" href="#32" title="" data-ref="_M/BINARY_OPERATION">BINARY_OPERATION</a>(Mul, <q>"*"</q>)</td></tr>
<tr><th id="368">368</th><td><a class="macro" href="#32" title="" data-ref="_M/BINARY_OPERATION">BINARY_OPERATION</a>(Div, <q>"/"</q>)</td></tr>
<tr><th id="369">369</th><td><a class="macro" href="#32" title="" data-ref="_M/BINARY_OPERATION">BINARY_OPERATION</a>(Rem, <q>"%"</q>)</td></tr>
<tr><th id="370">370</th><td><i>// [C99 6.5.6] Additive operators.</i></td></tr>
<tr><th id="371">371</th><td><a class="macro" href="#32" title="" data-ref="_M/BINARY_OPERATION">BINARY_OPERATION</a>(Add, <q>"+"</q>)</td></tr>
<tr><th id="372">372</th><td><a class="macro" href="#32" title="" data-ref="_M/BINARY_OPERATION">BINARY_OPERATION</a>(Sub, <q>"-"</q>)</td></tr>
<tr><th id="373">373</th><td><i>// [C99 6.5.7] Bitwise shift operators.</i></td></tr>
<tr><th id="374">374</th><td><a class="macro" href="#32" title="" data-ref="_M/BINARY_OPERATION">BINARY_OPERATION</a>(Shl, <q>"&lt;&lt;"</q>)</td></tr>
<tr><th id="375">375</th><td><a class="macro" href="#32" title="" data-ref="_M/BINARY_OPERATION">BINARY_OPERATION</a>(Shr, <q>"&gt;&gt;"</q>)</td></tr>
<tr><th id="376">376</th><td><i>// C++20 [expr.spaceship] Three-way comparison operator.</i></td></tr>
<tr><th id="377">377</th><td><a class="macro" href="#32" title="" data-ref="_M/BINARY_OPERATION">BINARY_OPERATION</a>(Cmp, <q>"&lt;=&gt;"</q>)</td></tr>
<tr><th id="378">378</th><td><i>// [C99 6.5.8] Relational operators.</i></td></tr>
<tr><th id="379">379</th><td><a class="macro" href="#32" title="" data-ref="_M/BINARY_OPERATION">BINARY_OPERATION</a>(LT, <q>"&lt;"</q>)</td></tr>
<tr><th id="380">380</th><td><a class="macro" href="#32" title="" data-ref="_M/BINARY_OPERATION">BINARY_OPERATION</a>(GT, <q>"&gt;"</q>)</td></tr>
<tr><th id="381">381</th><td><a class="macro" href="#32" title="" data-ref="_M/BINARY_OPERATION">BINARY_OPERATION</a>(LE, <q>"&lt;="</q>)</td></tr>
<tr><th id="382">382</th><td><a class="macro" href="#32" title="" data-ref="_M/BINARY_OPERATION">BINARY_OPERATION</a>(GE, <q>"&gt;="</q>)</td></tr>
<tr><th id="383">383</th><td><i>// [C99 6.5.9] Equality operators.</i></td></tr>
<tr><th id="384">384</th><td><a class="macro" href="#32" title="" data-ref="_M/BINARY_OPERATION">BINARY_OPERATION</a>(EQ, <q>"=="</q>)</td></tr>
<tr><th id="385">385</th><td><a class="macro" href="#32" title="" data-ref="_M/BINARY_OPERATION">BINARY_OPERATION</a>(NE, <q>"!="</q>)</td></tr>
<tr><th id="386">386</th><td><i>// [C99 6.5.10] Bitwise AND operator.</i></td></tr>
<tr><th id="387">387</th><td><a class="macro" href="#32" title="" data-ref="_M/BINARY_OPERATION">BINARY_OPERATION</a>(And, <q>"&amp;"</q>)</td></tr>
<tr><th id="388">388</th><td><i>// [C99 6.5.11] Bitwise XOR operator.</i></td></tr>
<tr><th id="389">389</th><td><a class="macro" href="#32" title="" data-ref="_M/BINARY_OPERATION">BINARY_OPERATION</a>(Xor, <q>"^"</q>)</td></tr>
<tr><th id="390">390</th><td><i>// [C99 6.5.12] Bitwise OR operator.</i></td></tr>
<tr><th id="391">391</th><td><a class="macro" href="#32" title="" data-ref="_M/BINARY_OPERATION">BINARY_OPERATION</a>(Or, <q>"|"</q>)</td></tr>
<tr><th id="392">392</th><td><i>// [C99 6.5.13] Logical AND operator.</i></td></tr>
<tr><th id="393">393</th><td><a class="macro" href="#32" title="" data-ref="_M/BINARY_OPERATION">BINARY_OPERATION</a>(LAnd, <q>"&amp;&amp;"</q>)</td></tr>
<tr><th id="394">394</th><td><i>// [C99 6.5.14] Logical OR operator.</i></td></tr>
<tr><th id="395">395</th><td><a class="macro" href="#32" title="" data-ref="_M/BINARY_OPERATION">BINARY_OPERATION</a>(LOr, <q>"||"</q>)</td></tr>
<tr><th id="396">396</th><td><i>// [C99 6.5.16] Assignment operators.</i></td></tr>
<tr><th id="397">397</th><td><a class="macro" href="#32" title="" data-ref="_M/BINARY_OPERATION">BINARY_OPERATION</a>(Assign, <q>"="</q>)</td></tr>
<tr><th id="398">398</th><td><a class="macro" href="#32" title="" data-ref="_M/BINARY_OPERATION">BINARY_OPERATION</a>(MulAssign, <q>"*="</q>)</td></tr>
<tr><th id="399">399</th><td><a class="macro" href="#32" title="" data-ref="_M/BINARY_OPERATION">BINARY_OPERATION</a>(DivAssign, <q>"/="</q>)</td></tr>
<tr><th id="400">400</th><td><a class="macro" href="#32" title="" data-ref="_M/BINARY_OPERATION">BINARY_OPERATION</a>(RemAssign, <q>"%="</q>)</td></tr>
<tr><th id="401">401</th><td><a class="macro" href="#32" title="" data-ref="_M/BINARY_OPERATION">BINARY_OPERATION</a>(AddAssign, <q>"+="</q>)</td></tr>
<tr><th id="402">402</th><td><a class="macro" href="#32" title="" data-ref="_M/BINARY_OPERATION">BINARY_OPERATION</a>(SubAssign, <q>"-="</q>)</td></tr>
<tr><th id="403">403</th><td><a class="macro" href="#32" title="" data-ref="_M/BINARY_OPERATION">BINARY_OPERATION</a>(ShlAssign, <q>"&lt;&lt;="</q>)</td></tr>
<tr><th id="404">404</th><td><a class="macro" href="#32" title="" data-ref="_M/BINARY_OPERATION">BINARY_OPERATION</a>(ShrAssign, <q>"&gt;&gt;="</q>)</td></tr>
<tr><th id="405">405</th><td><a class="macro" href="#32" title="" data-ref="_M/BINARY_OPERATION">BINARY_OPERATION</a>(AndAssign, <q>"&amp;="</q>)</td></tr>
<tr><th id="406">406</th><td><a class="macro" href="#32" title="" data-ref="_M/BINARY_OPERATION">BINARY_OPERATION</a>(XorAssign, <q>"^="</q>)</td></tr>
<tr><th id="407">407</th><td><a class="macro" href="#32" title="" data-ref="_M/BINARY_OPERATION">BINARY_OPERATION</a>(OrAssign, <q>"|="</q>)</td></tr>
<tr><th id="408">408</th><td><i>// [C99 6.5.17] Comma operator.</i></td></tr>
<tr><th id="409">409</th><td><a class="macro" href="#32" title="" data-ref="_M/BINARY_OPERATION">BINARY_OPERATION</a>(Comma, <q>","</q>)</td></tr>
<tr><th id="410">410</th><td></td></tr>
<tr><th id="411">411</th><td></td></tr>
<tr><th id="412">412</th><td><i>//===- Unary Operations ---------------------------------------------------===//</i></td></tr>
<tr><th id="413">413</th><td><i>// Note that additions to this should also update the StmtVisitor class and</i></td></tr>
<tr><th id="414">414</th><td><i>// UnaryOperator::getOverloadedOperator.</i></td></tr>
<tr><th id="415">415</th><td><i></i></td></tr>
<tr><th id="416">416</th><td><i>// [C99 6.5.2.4] Postfix increment and decrement</i></td></tr>
<tr><th id="417">417</th><td><a class="macro" href="#36" title="" data-ref="_M/UNARY_OPERATION">UNARY_OPERATION</a>(PostInc, <q>"++"</q>)</td></tr>
<tr><th id="418">418</th><td><a class="macro" href="#36" title="" data-ref="_M/UNARY_OPERATION">UNARY_OPERATION</a>(PostDec, <q>"--"</q>)</td></tr>
<tr><th id="419">419</th><td><i>// [C99 6.5.3.1] Prefix increment and decrement</i></td></tr>
<tr><th id="420">420</th><td><a class="macro" href="#36" title="" data-ref="_M/UNARY_OPERATION">UNARY_OPERATION</a>(PreInc, <q>"++"</q>)</td></tr>
<tr><th id="421">421</th><td><a class="macro" href="#36" title="" data-ref="_M/UNARY_OPERATION">UNARY_OPERATION</a>(PreDec, <q>"--"</q>)</td></tr>
<tr><th id="422">422</th><td><i>// [C99 6.5.3.2] Address and indirection</i></td></tr>
<tr><th id="423">423</th><td><a class="macro" href="#36" title="" data-ref="_M/UNARY_OPERATION">UNARY_OPERATION</a>(AddrOf, <q>"&amp;"</q>)</td></tr>
<tr><th id="424">424</th><td><a class="macro" href="#36" title="" data-ref="_M/UNARY_OPERATION">UNARY_OPERATION</a>(Deref, <q>"*"</q>)</td></tr>
<tr><th id="425">425</th><td><i>// [C99 6.5.3.3] Unary arithmetic</i></td></tr>
<tr><th id="426">426</th><td><a class="macro" href="#36" title="" data-ref="_M/UNARY_OPERATION">UNARY_OPERATION</a>(Plus, <q>"+"</q>)</td></tr>
<tr><th id="427">427</th><td><a class="macro" href="#36" title="" data-ref="_M/UNARY_OPERATION">UNARY_OPERATION</a>(Minus, <q>"-"</q>)</td></tr>
<tr><th id="428">428</th><td><a class="macro" href="#36" title="" data-ref="_M/UNARY_OPERATION">UNARY_OPERATION</a>(Not, <q>"~"</q>)</td></tr>
<tr><th id="429">429</th><td><a class="macro" href="#36" title="" data-ref="_M/UNARY_OPERATION">UNARY_OPERATION</a>(LNot, <q>"!"</q>)</td></tr>
<tr><th id="430">430</th><td><i>// "__real expr"/"__imag expr" Extension.</i></td></tr>
<tr><th id="431">431</th><td><a class="macro" href="#36" title="" data-ref="_M/UNARY_OPERATION">UNARY_OPERATION</a>(Real, <q>"__real"</q>)</td></tr>
<tr><th id="432">432</th><td><a class="macro" href="#36" title="" data-ref="_M/UNARY_OPERATION">UNARY_OPERATION</a>(Imag, <q>"__imag"</q>)</td></tr>
<tr><th id="433">433</th><td><i>// __extension__ marker.</i></td></tr>
<tr><th id="434">434</th><td><a class="macro" href="#36" title="" data-ref="_M/UNARY_OPERATION">UNARY_OPERATION</a>(Extension, <q>"__extension__"</q>)</td></tr>
<tr><th id="435">435</th><td><i>// [C++ Coroutines] co_await operator</i></td></tr>
<tr><th id="436">436</th><td><a class="macro" href="#36" title="" data-ref="_M/UNARY_OPERATION">UNARY_OPERATION</a>(Coawait, <q>"co_await"</q>)</td></tr>
<tr><th id="437">437</th><td></td></tr>
<tr><th id="438">438</th><td><u>#undef <a class="macro" href="OperationKinds.h.html#21" data-ref="_M/CAST_OPERATION">CAST_OPERATION</a></u></td></tr>
<tr><th id="439">439</th><td><u>#undef <a class="macro" href="#32" data-ref="_M/BINARY_OPERATION">BINARY_OPERATION</a></u></td></tr>
<tr><th id="440">440</th><td><u>#undef <a class="macro" href="#36" data-ref="_M/UNARY_OPERATION">UNARY_OPERATION</a></u></td></tr>
<tr><th id="441">441</th><td></td></tr>
</table><hr/><p id='footer'>
Generated while processing <a href='../../../examples/AnnotateFunctions/AnnotateFunctions.cpp.html'>llvm/clang/examples/AnnotateFunctions/AnnotateFunctions.cpp</a><br/>Generated on <em>2019-Jul-08</em> from project llvm revision <em>2cdaed95cde</em><br />Powered by <a href='https://woboq.com'><img alt='Woboq' src='https://code.woboq.org/woboq-16.png' width='41' height='16' /></a> <a href='https://code.woboq.org'>Code Browser</a> 2.1
<br/>Generator usage only permitted with license.</p>
</div></body></html>
